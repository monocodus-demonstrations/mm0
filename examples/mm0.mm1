import "peano_hex.mm1";

-- Some additional list operations

-- all2 : (A -> B -> Bool) -> list A -> list B -> Bool
@_ def all2 {x y .n: nat} (ph: wff x y) (l1 l2: nat): wff =
$ len l1 = len l2 /\ A. n A. x A. y
  (nth n l1 = suc x -> nth n l2 = suc y -> ph) $;
theorem all2eq1i {x y} (ph1 ph2: wff x y) (h: $ ph1 <-> ph2 $):
  $ all2 x y ph1 l1 l2 <-> all2 x y ph2 l1 l2 $ = '(trud @ all2eq1d @ a1i h);
theorem all2eq2 {x y} (ph: wff x y): $ l11 = l12 ->
  (all2 x y ph l11 l2 <-> all2 x y ph l12 l2) $ = '(all2eq2d id);
theorem all2eq3 {x y} (ph: wff x y): $ l21 = l22 ->
  (all2 x y ph l1 l21 <-> all2 x y ph l1 l22) $ = '(all2eq3d id);

theorem all2len {x y} (ph: wff x y): $ all2 x y ph l1 l2 -> len l1 = len l2 $ =
(named 'anl);

theorem all2is {x y} (G ph: wff x y)
  (h1: $ G -> nth n l1 = suc a $)
  (h2: $ G -> nth n l2 = suc b $)
  (h: $ G -> all2 x y ph l1 l2 $):
  $ G -> [a / x] [b / y] ph $ =
(named '(mpd h2 @ mpd h1 @ rsyl h @ anwr @ ealie @
  ealdeh nfv (nfim nfv @ nfim nfv nfsb1) @
  ealdeh nfv (nfim nfv @ nfim nfv @ nfsb nfsb1) @ bi1d @
  imeqd (eqeqd (ntheq1d anll) @ suceqd anlr) @
  imeqd (eqeqd (ntheq1d anll) @ suceqd anr) @
  bitrd (rsyl anr sbq) (rsyl anlr sbq)));

theorem all20 {x y} (ph: wff x y): $ all2 x y ph 0 0 $ =
(named '(ian eqid @ ax_gen @ ax_gen @ ax_gen @
  rsyl eqcom @ absurd @ mpbir (neeq2 nth0) peano1));

theorem all201 {x y} (ph: wff x y): $ all2 x y ph 0 l <-> l = 0 $ =
'(ibii (sylib leneq0 @ syl6eq len0 @ eqcomd all2len) @ mpbiri all20 all2eq3);

theorem all202 {x y} (ph: wff x y): $ all2 x y ph l 0 <-> l = 0 $ =
'(ibii (sylib leneq0 @ syl6eq len0 all2len) @ mpbiri all20 all2eq2);

theorem all2S {x y} (ph: wff x y): $ all2 x y ph (a : l1) (b : l2) <->
  [a / x] [b / y] ph /\ all2 x y ph l1 l2 $ =
(named @ focus
  '(bitr _ anlass)
  (def h '(syl6bb eqcomb @ syl6bb peano2 @ eqeq1d @ syl6eq nthZ ntheq1))
  '(aneq (bitr (eqeq lenS lenS) peano2) @
    bitr (aleqi @ bitr3 (biim1 em) imor) @ bitr alan @ aneq _ _)
  '(aleqe @ syl6bbr dfsb2 @ aleqd @ syl5bb alim1 @
    imeqd ,h @ syl6bbr dfsb2 @ aleqd @ imeq1d ,h)
  '(bitr (aleqi @ bitr (imeq1i exsuc) eexb) @
    bitr alcomb @ aleqi @ aleqe @ aleqd @ aleqd @
    imeqd (eqeq1d @ syl6eq nthS ntheq1) @
    imeq1d (eqeq1d @ syl6eq nthS ntheq1)));

theorem all2S1 {x y} (ph: wff x y): $ all2 x y ph (a : l1) l2 <->
  E. b E. l2_ (l2 = b : l2_ /\ [a / x] [b / y] ph /\ all2 x y ph l1 l2_) $ =
'(bitr3 (bian1a @ sylib excons @ sylib (noteq leneq0) @
    mpbii peano1 @ neeq1d @ syl5eqr lenS all2len) @
  bitr3 exan2 @ exeqi @ bitr3 exan2 @ exeqi @
  bitr4 (aneq2a @ syl6bb all2S all2eq3) anass);

-- ex2 : (A -> B -> Bool) -> list A -> list B -> Bool
@_ def ex2 {x y .n: nat} (ph: wff x y) (l1 l2: nat): wff =
$ len l1 = len l2 /\ E. n E. x E. y
  (nth n l1 = suc x /\ nth n l2 = suc y /\ ph) $;

theorem ex2len {x y} (ph: wff x y): $ ex2 x y ph l1 l2 -> len l1 = len l2 $ =
(named 'anl);

theorem ex201 {x y} (ph: wff x y): $ ~ ex2 x y ph 0 l $ =
(named '(mt anr @ nexi @ nexi @ nexi @ mt2 (rsyl anll sucne0) nth0));

theorem ex202 {x y} (ph: wff x y): $ ~ ex2 x y ph l 0 $ =
(named '(mt anr @ nexi @ nexi @ nexi @ mt2 (rsyl anlr sucne0) nth0));

theorem all2nex {x y} (ph: wff x y):
  $ all2 x y (~ph) l1 l2 <-> len l1 = len l2 /\ ~ex2 x y ph l1 l2 $ =
(named @ focus
  '(aneq2a @ syl5bbr _ @ noteqd @ bicomd @ bian1)
  (def h '(bitr3 alnex (aleqi _))) h h h
  '(bitr notan2 impexp));

theorem dfex2_2 {x y} (ph: wff x y):
  $ ex2 x y ph l1 l2 <-> len l1 = len l2 /\ ~all2 x y (~ph) l1 l2 $ =
'(bitr3 (bian1a ex2len) @ aneq2a @ syl con2b @ syl5bb all2nex bian1);

theorem ex2nal {x y} (ph: wff x y):
  $ ex2 x y (~ph) l1 l2 <-> len l1 = len l2 /\ ~all2 x y ph l1 l2 $ =
'(bitr4 dfex2_2 @ aneq2i @ noteqi @ all2eq1i notnot);

theorem mapeqg (F: set) (a l: nat):
  $ all {x | F @ x = G @ x} l -> map F l = map G l $ =
(named @ let ([h '(imeqd alleq2 @ eqeqd mapeq2 mapeq2)])
  '(listind ,h ,h ,h ,h
    (a1i @ eqtr4 map0 map0)
    (rsyl (imim1i @ sylbi allS anr) @ a2i @ rsyl (sylbi allS anl) @ exp @
      eqtr4g mapS mapS @ conseqd (sylib (elabe @ eqeqd appeq2 appeq2) anl) anr)));

@_ local def rlrec (z: nat) (S: set) (n: nat): nat =
$ lrec z (\\ a, \\ l, \ ih, S @ (rev l <> a <> ih)) (rev n) $;
theorem rlrec0: $ rlrec z S 0 = z $ = (named '(eqtr (lreceq3 rev0) lrec0));
theorem rlrecS: $ rlrec z S (l |> a) = S @ (l <> a <> rlrec z S l) $ =
(named '(eqtr (lreceq3 revsnoc) @ ! eqtr _ $ _ @ (a <> _ <> rlrec z S l) $ _ lrecS @
  appslame @ appslamed @ applamed @
  appeq2d @ preqd (syl6eq revrev @ reveqd anlr) @ preqd anll anr));

theorem rlistindd {x l a} (n) (px: wff x) (p0 pn: wff) (pl: wff l) (ps: wff a l)
  (h0: $ x = 0 -> (px <-> p0) $)
  (hl: $ x = l -> (px <-> pl) $)
  (hs: $ x = l |> a -> (px <-> ps) $)
  (hn: $ x = n -> (px <-> pn) $)
  (h1: $ G -> p0 $) (h2: $ G /\ pl -> ps $): $ G -> pn $ =
'(!! indstr z w sbeq1 (syl6bb (sbe hn) sbeq1) @ casesda
  (mpbird (sbeq1d anr) @ anwll @ sylibr (sbe h0) h1)
  (mpd (sylib exsnoc anr) @ eexd @ eexd @ anwl @ exp @
    mpbird (syl6bb (sbe hs) @ sbeq1d anr) @
    mpd (mpd (mpbiri snoclt @ lteq2d anr) @
      rsyl anlr @ eale @ imeqd lteq1 @ syl6bb (sbe hl) sbeq1) @
    anwll @ exp h2));

theorem rlistind {x l a} (n) (px: wff x) (p0 pn: wff) (pl: wff l) (ps: wff a l)
  (h0: $ x = 0 -> (px <-> p0) $)
  (hl: $ x = l -> (px <-> pl) $)
  (hs: $ x = l |> a -> (px <-> ps) $)
  (hn: $ x = n -> (px <-> pn) $)
  (h1: $ p0 $) (h2: $ pl -> ps $): $ pn $ =
'(trud @ rlistindd h0 hl hs hn (a1i h1) (anwr h2));

-- The sort modifiers 'pure', 'strict', 'provable', 'free'
-- sPure : SortData -> Bool
@_ def sPure     (n: nat): wff = $ true (pi11 n) $;
-- sStrict : SortData -> Bool
@_ def sStrict   (n: nat): wff = $ true (pi12 n) $;
-- sProvable : SortData -> Bool
@_ def sProvable (n: nat): wff = $ true (pi21 n) $;
-- sFree : SortData -> Bool
@_ def sFree     (n: nat): wff = $ true (pi22 n) $;

-- A binder is either a bound variable with sort s, or a regular variable
-- with sort s and dependencies vs.
-- PBound : SortID -> Binder
@_ def PBound (s: nat): nat = $ b0 s $;
-- PReg : SortID -> set VarID -> Binder
@_ def PReg (s vs: nat): nat = $ b1 (s <> vs) $;

-- Get the sort of a binder.
-- binderSort : Binder -> SortID
@_ def binderSort (x: nat): nat =
$ case (\ n, n) (\ n, fst n) @ x $;
pub theorem binderSortBound (s: nat): $ binderSort (PBound s) = s $ =
(named '(eqtr casel @ applame id));
pub theorem binderSortReg (s vs: nat): $ binderSort (PReg s vs) = s $ =
(named '(eqtr caser @ applame @ syl6eq fstpr fsteq));

theorem binderSort_leid (s: nat): $ binderSort bi <= bi $ =
'(eori
  (mpbiri b0leid (leeqd (syl6eq binderSortBound binderSorteq) id))
  (mpbiri (leb1tr fstleid)
    (leeqd (syl6eq binderSortReg @ binderSorteqd @ syl6eqr (b1eq fstsnd) id) id)) b0orb1);

-- An s-expression, representing the terms and formulas. It can be either a
-- variable (v is a VarID) or an application of the term with TermID `f`
-- to arguments `x` (a list of s-expressions).
-- SVar : VarID -> SExpr
@_ def SVar (v: nat): nat = $ b0 v $;
-- SApp : TermID -> list SExpr -> SExpr
@_ def SApp (f x: nat): nat = $ b1 (f <> x) $;

theorem SApp_ltid: $ e IN es -> e < SApp f es $ =
'(rsyl lmemlt @ mpi (ltb1tr leprid2) lttr);

@_ local def SExprRec (V F: set): set =
$ \ e, srec (\ ih, case V (\\ f, \ x, F @ (f <> x <> map ih x)) @ size (Dom ih)) e $;

theorem SExprRec_val: $ SExprRec V F @ e =
  case V (\\ f, \ x, F @ (f <> x <> map (SExprRec V F |` upto e) x)) @ e $ =
(named '(eqtr (applame sreceq2) @
  ! eqtr _ $ _ @ (lower (SExprRec V F |` _)) $ _ srecval @
  applame @ appeqd
    (caseeq2d @ slameqd @ lameqd @ appeq2d @ preq2d @
      preq2d @ mapeq1d @ bi2 @ eqlower2 @ finlam finns)
    sreclem));

theorem SExprRec_Var: $ SExprRec V F @ (SVar v) = V @ v $ =
(named '(eqtr SExprRec_val casel));
theorem SExprRec_App:
  $ SExprRec V F @ (SApp f es) = F @ (f <> es <> map (SExprRec V F) es) $ =
(named '(eqtr SExprRec_val @ eqtr caser @
  appslame @ applamed @ appeq2d @ preqd anl @ preqd anr @ syl6eq
    (mapeqg @ mpbir allal @ !! ax_gen e @ syl resapp @ sylibr elupto SApp_ltid)
    (mapeq2d anr)));

theorem indd_aux (G p: wff x) (e: $ x = b -> (p <-> q) $)
  (h: $ G /\ a = b -> q $): $ G /\ a = b -> [a / x] p $ =
'(mpbird (syl6bb (sbe e) @ anwr sbeq1) h);

theorem SExpr_indd {x f es} (n) (px: wff x) (pv: wff v) (pe: wff f es)
  (hv: $ x = SVar v -> (px <-> pv) $)
  (he: $ x = SApp f es -> (px <-> pe) $)
  (hn: $ x = n -> (px <-> pn) $)
  (h1: $ G -> pv $) (h2: $ G /\ all {x | px} es -> pe $): $ G -> pn $ =
(focus
  '(sylib (sbe hn) @ !! indstr z w sbeq1 sbeq1 _)
  (split-sop '{
    ($SVar v$ => (indd_aux hv @ anwll h1)) +
    ($SApp f es$ => (indd_aux he @ sylan h2 anll @
      sylibr (alleq1 cbvabs) @ sylibr allal @ sylc _ anr anlr))
  })
  '(alimd @ imim1d @ syl5 SApp_ltid @ bi2d lteq2));

-- The environment is composed of declarations, which come in a few types:
-- A `sort` declaration has an associated `SortData` with the sort modifiers.
-- Sorts are indexed by SortID and picked out by `getSD`.
-- DSort : SortID -> SortData -> Decl
@_ def DSort (id sd: nat): nat = $ b0 (b0 (b0 (id <> sd))) $;
-- A `term` declaration has a list of binders, and a target type (a DepType,
-- which is a `(SortID, set VarID)` pair).
-- Terms are indexed by TermID and picked out by `getTerm`.
-- DTerm : TermID -> Ctx -> DepType -> Decl
@_ def DTerm (id args ret: nat): nat = $ b0 (b0 (b1 (id <> args <> ret))) $;
-- An `axiom` declaration has a list of binders, a list of hypotheses,
-- and a consequent.
-- Axioms are not indexed, they are simply found by statement.
-- DAxiom : Ctx -> list SExpr -> SExpr -> Decl
@_ def DAxiom (args hs ret: nat): nat = $ b0 (b1 (args <> hs <> ret)) $;
-- A `def` declaration is the same as a `term` except it also has an optional
-- definition component which lists the sorts of the dummy variables and the
-- definition's expression.
-- Defs are indexed by TermID and picked out by `getTerm`.
-- DDef : TermID -> Ctx -> DepType -> option (list SortID, SExpr) -> Decl
@_ def DDef (id args ret def: nat): nat =
  $ b1 (b0 (id <> args <> ret <> def)) $;
-- A `theorem` declaration is exactly the same structure as an `axiom`, but
-- the interpretation is different - theorems require proofs, while axioms are
-- added in the spec.
-- Theorems are not indexed, they are simply found by statement.
-- DThm : Ctx -> list SExpr -> SExpr -> Decl
@_ def DThm (vs hs ret: nat): nat = $ b1 (b1 (vs <> hs <> ret)) $;

-- This function extracts the `SortData` for a sort given by `SortID`.
-- getSD : Env -> SortID -> SortData -> Bool
@_ def getSD (env id sd: nat): wff = $ DSort id sd IN env $;

-- This function gets the term and definition data for a term.
-- getTerm : Env -> TermID -> Ctx -> DepType -> option (list SortID, SExpr) -> Bool
@_ def getTerm (env id a r v: nat): wff =
$ v = 0 /\ DTerm id a r IN env \/ DDef id a r v IN env $;

theorem getTerm_ltid: $ getTerm env x a r v -> x < env /\ a < env /\ r < env /\ v < env $ =
(focus
  '(eor _ _)
  (focus
    '(imp @ syl5 (rsyl lmemlt @ lelttr @ leb0tr @ leb0tr b1leid) @
      mpbiri _ (imeq2d @ aneq2d lteq1))
    '(iand (iand (iand _ _) _) (lelttr le01))
    '(lelttr leprid1)
    '(lelttr @ lepr2tr leprid1)
    '(lelttr @ lepr2tr leprid2))
  (focus
    '(rsyl lmemlt @ rsyl (lelttr @ leb1tr b0leid) _)
    '(iand (iand (iand _ _) _) _)
    '(lelttr leprid1)
    '(lelttr @ lepr2tr leprid1)
    '(lelttr @ lepr2tr @ lepr2tr leprid1)
    '(lelttr @ lepr2tr @ lepr2tr leprid2)));

theorem getTerm_retltid: $ getTerm env x a r v -> r < env $ = '(rsyl getTerm_ltid anlr);

-- This function gets the data for an axiom or theorem.
-- getThm : Env -> Ctx -> list SExpr -> SExpr -> Bool
@_ def getThm (env a h r: nat): wff =
$ DAxiom a h r IN env \/ DThm a h r IN env $;

-- Is this ID a valid sort?
-- isSort : Env -> SortID -> Bool
@_ def isSort (env s .sd: nat): wff = $ E. sd getSD env s sd $;

-- Looks this variable up in the context, and reports whether it represents a
-- bound variable.
-- isBound : Ctx -> VarID -> Bool
@_ def isBound (ctx x .s: nat): wff = $ E. s nth ctx x = suc (PBound s) $;

-- Checks if this a well formed dependent type in the context. A DepType is a
-- pair (SortID, set VarID) giving the sort and the variable dependencies.
-- DepType : Env -> Ctx -> DepType -> Bool
@_ def DepType (env ctx ty .x: nat): wff =
$ isSort env (fst ty) /\ A. x (x e. snd ty -> isBound ctx x) $;

@_ local def Ctx_aux (env ctx: nat): nat =
$ rlrec 1 (\\ ctx2, \\ bi, \ ih, ih * nat (bi e. Sum
    {s | E. sd (getSD env s sd /\ ~ sStrict sd)}
    {svs | DepType env ctx2 svs})) ctx $;
theorem Ctx_aux0 (env: nat): $ Ctx_aux env 0 = 1 $ = (named 'rlrec0);
theorem Ctx_auxS (env: nat): $ Ctx_aux env (ctx |> bi) = Ctx_aux env ctx *
  nat (bi e. Sum
    {s | E. sd (getSD env s sd /\ ~ sStrict sd)}
    {svs | DepType env ctx svs}) $ =
(named '(! eqtr _ $ _ @ (_ <> _ <> Ctx_aux env ctx) $ _ rlrecS @
  appslame @ appslamed @ applamed @ muleqd anr @
  nateqd @ eleqd anlr @ Sumeq2d @ abeqd @ DepTypeeq2d anll));

-- Checks if this a well formed context. A context can be extended with a bound
-- variable binder if the sort of the binder is not `strict`.
-- Note `Ctx = list Binder`.
-- Ctx : Env -> Ctx -> Bool
@_ def Ctx (env ctx: nat): wff = $ true (Ctx_aux env ctx) $;
pub theorem Ctx0 (env: nat): $ Ctx env 0 $ = '(mpbir (trueeq Ctx_aux0) true1);
pub theorem CtxBound (env ctx s: nat) {sd: nat}: $ Ctx env (ctx |> PBound s) <->
  Ctx env ctx /\ E. sd (getSD env s sd /\ ~ sStrict sd) $ =
(named '(bitr (trueeq Ctx_auxS) @ bitr truemul @ aneq2i @
  bitr truenat @ bitr Suml @ elabe @ exeqd @ aneq1d getSDeq2));
pub theorem CtxReg (env ctx s vs: nat): $ Ctx env (ctx |> PReg s vs) <->
  Ctx env ctx /\ DepType env ctx (s <> vs) $ =
(named '(bitr (trueeq Ctx_auxS) @ bitr truemul @ aneq2i @
  bitr truenat @ bitr Sumr @ elabe DepTypeeq3));

@_ local def ExprBi_aux (env ctx e ih: nat): set = $ Sum
  {s | E. v (e = SVar v /\ nth v ctx = suc (PBound s))}
  {svs | fst svs e. ih} $;

@_ local def Expr_aux (env ctx: nat): set =
$ SExprRec
  (\ v, lower {s | E. bi (nth v ctx = suc bi /\ binderSort bi = s)})
  (\\ f, \\ xs, \ ih, lower {s | E. args E. ret E. o
    (getTerm env f args ret o /\
     all2 x a (a e. ExprBi_aux env ctx (fst x) (snd x)) (zip xs ih) args /\
     s = fst ret)}) $;

theorem Expr_aux_Var: $ Expr_aux env ctx @ SVar v =
  lower {s | E. bi (nth v ctx = suc bi /\ binderSort bi = s)} $ =
(named '(eqtr SExprRec_Var @ applame @
  lowereqd @ abeqd @ exeqd @ aneq1d @ eqeq1d @ ntheq1));

theorem Expr_aux_App: $ Expr_aux env ctx @ SApp f es =
  lower {s | E. args E. ret E. o
    (getTerm env f args ret o /\
     all2 x a (a e. ExprBi_aux env ctx (fst x) (snd x)) (zip es (map (Expr_aux env ctx) es)) args /\
     s = fst ret)} $ =
(named '(eqtr SExprRec_App @
  ! appslame _ $_ <> map (Expr_aux _ _) _$ _ _ _ @ appslamed @ applamed @
  lowereqd @ abeqd @ exeqd @ exeqd @ exeqd @ aneq1d @ aneqd
    (getTermeq2d anll)
    (all2eq2d (zipeqd anlr anr))));

-- These mutually recursive functions check if an expression `e` is well-typed
-- with sort `s`, and that `e` is well-typed and valid for entry into a binder
-- `bi`. The main difference is that for an expression to be valid for a
-- BV binder, the expression must itself be a bound variable.
-- Expr : Env -> Ctx -> SExpr -> SortID -> Bool
@_ def Expr (env ctx e s: nat): wff = $ s e. Expr_aux env ctx @ e $;
-- ExprBi : Env -> Ctx -> SExpr -> Binder -> Bool
@_ def ExprBi (env ctx e bi: nat): wff =
$ bi e. ExprBi_aux env ctx e (Expr_aux env ctx @ e) $;

theorem ExprBi_aux_map:
  $ all2 p a (a e. ExprBi_aux env ctx (fst p) (snd p)) (zip es (map (Expr_aux env ctx) es)) args <->
    all2 x a (ExprBi env ctx x a) es args $ =
(named @ let ([h '(bieqd all2eq3 all2eq3)])
  '(eale ,h ,(mk-ind '(listind)
    '(aleqd @ bieqd (all2eq2d @ zipeqd id mapeq2) all2eq2)
    '(ax_gen @ bitr (all2eq2 zip01) @ bitr4 all201 all201)
    '(sylbi (cbval ,h) @ iald @
      bitr4g (bitr (all2eq2 @ eqtr (zipeq2 mapS) zipS) all2S1) all2S1 @
      exeqd @ syl exeq @ alimi @ bitr4g anass anass @ syl aneq2a @ exp @
      aneqd (a1i @ bitr4
        (sbe @ sbed @ eleqd anr @ anwl @
          ExprBi_auxeqd eqidd eqidd (syl6eq fstpr @ fsteq) (syl6eq sndpr @ sndeq))
        (sbe @ sbed @ ExprBieqd eqidd eqidd anl anr)) anl))));

pub theorem ExprVar (env ctx v s: nat) {bi: nat}: $ Expr env ctx (SVar v) s <->
  E. bi (nth v ctx = suc bi /\ binderSort bi = s) $ =
(named @ focus
  '(bitr (elneq2 Expr_aux_Var) @ bitr (ellower @ subsnfin @ subsnss _ subsnsn) @
     elabe @ exeqd @ aneq2d eqeq2)
  '(mpbi ssab @ ax_gen @ eex @ eqcomd @ eqtrd _ anr)
  '(binderSorteqd @ syl6eq sucsub1 @ subeq1d anl));

pub theorem ExprApp (env ctx f xs s: nat) {args ret o x a: nat}:
  $ Expr env ctx (SApp f xs) s <-> E. args E. ret E. o
    (getTerm env f args ret o /\
     all2 x a (ExprBi env ctx x a) xs args /\
     s = fst ret) $ =
(named @ focus
  '(bitr (elneq2 Expr_aux_App) @ bitr (ellower @ finss _ ltfin) @
    elabe @ exeqd @ exeqd @ exeqd @ aneqd (a1i @ aneq2i ExprBi_aux_map) eqeq1)
  '(mpbi ssab @ ax_gen @ eex @ eex @ eex @ mpbird (lteq1d anr) @ anwll @
    syl (lelttr fstleid) getTerm_retltid));

pub theorem ExprBiBound (env ctx e s: nat) {v: nat}:
  $ ExprBi env ctx e (PBound s) <->
    E. v (e = SVar v /\ nth v ctx = suc (PBound s)) $ =
(named '(bitr Suml @ elabe @ exeqd @ aneq2d @ eqeq2d @ suceqd @ PBoundeq));
pub theorem ExprBiReg (env ctx e s vs: nat):
  $ ExprBi env ctx e (PReg s vs) <-> Expr env ctx e s $ =
(named '(bitr Sumr @ elabe @ eleq1d @ syl6eq fstpr fsteq));

-- Is this a type correct expression of provable type? This is used to
-- typecheck expressions appearing in hypotheses and conclusions of
-- axiom/pub theorem.
-- ExprProv : Env -> Ctx -> SExpr -> Bool
@_ def ExprProv (env ctx e .s .sd: nat): wff =
$ E. s E. sd (Expr env ctx e s /\ getSD env s sd /\ sProvable sd) $;

-- A helper function to add dummy variables to the context.
-- appendDummies : Ctx -> list SortID -> Ctx
@_ def appendDummies (ctx ds .d: nat): nat = $ ctx ++ map (\ d, PBound d) ds $;

@_ local def HasVar_aux (ctx: nat): set =
$ SExprRec
  (\ u, lower {v | E. s nth u ctx = suc (PBound s) /\ u = v \/
     E. s E. vs (nth u ctx = suc (PReg s vs) /\ v e. vs)})
  (\\ f, \\ xs, \ ih, lower {v | E. s (s IN ih /\ v e. s)}) $;

-- Does this expression contain any occurrence of the variable `v`? This check
-- ignores bound variables, "metamath style". We use this stricter check for
-- verifying pub theorem applications.
-- HasVar : Ctx -> SExpr -> VarID -> Bool
@_ def HasVar (ctx e v: nat): wff = $ v e. HasVar_aux ctx @ e $;

theorem HasVar_Var: $ HasVar ctx (SVar u) v <->
  E. s nth u ctx = suc (PBound s) /\ u = v \/
    E. s E. vs (nth u ctx = suc (PReg s vs) /\ v e. vs) $ =
(named @ focus
  '(bitr (elneq2 @ eqtr SExprRec_Var @ applame @ lowereqd @ abeqd @
      oreqd (aneqd (exeqd @ eqeq1d ntheq1) eqeq1) (exeqd @ exeqd @ aneq1d @ eqeq1d ntheq1)) @
    bitr (ellower @ finss (mpbi ssab @ ax_gen _) ltfin) @
    elabe @ oreqd (aneq2d eqeq2) (exeqd @ exeqd @ aneq2d eleq1))
  '(eor
    (mpbid (lteq1d anr) @ anwl @ eex @ syl (mpi lenleid ltletr) @
      sylib nthne0 sucne0)
    (eex @ eex @ lttrd (anwr ellt) @
      anwl @ syl (lelttr @ leb1tr leprid2) @ syl lmemlt nthlmem)));

pub theorem HasVarBound (ctx u v s: nat):
  $ nth u ctx = suc (PBound s) -> (HasVar ctx (SVar u) v <-> u = v) $ =
(named '(syl5bb HasVar_Var @ bitrd
  (syl bior2 @ nexd @ nexd @ mpi b0neb1 @
    con3d @ exp @ sylib peano2 @ eqtr3d anl anrl)
  (syl bian1 @ iexe @ eqeq2d @ suceqd PBoundeq)));

pub theorem HasVarReg (ctx u v s vs: nat):
  $ nth u ctx = suc (PReg s vs) -> (HasVar ctx (SVar u) v <-> v e. vs) $ =
(named '(syl5bb HasVar_Var @ bitrd
  (syl bior1 @ syl (con3 anl) @ nexd @ mpi b0neb1 @ con3d @ exp @
    sylib peano2 @ eqtr3d anr anl)
  (syl6bb (exeqe biidd) @ exeqd @ syl6bb (exeqe @ aneq2d elneq2) @ exeqd @
    syl6bb anlass @ syl6bb anass @ aneq1d @
    syl6bb (bitr peano2 @ bitr b1can @ bitr eqcomb prth) eqeq1)));

pub theorem HasVarApp (ctx f es v: nat) {e: nat}:
  $ HasVar ctx (SApp f es) v <-> E. e (e IN es /\ HasVar ctx e v) $ =
(named @ focus
  '(bitr (elneq2 @ eqtr {SExprRec_App : $ _ = _ @ (_ <> _ <> map (HasVar_aux ctx) _) $} @
      appslame @ appslamed @ applamed @ lowereqd @ abeqd @
        exeqd @ aneq1d @ lmemeq2d anr) @
    bitr (ellower @ finss (mpbi ssab @ ax_gen _) ltfin) @
    bitr (elabe @ exeqd @ syl6bbr exan2 @ aneqd (a1i lmemmap) eleq1) @
    bitr excomb @ exeqi @ bitr (exeqi @ bitr (aneq1i ancomb) anass) @
    exeqe @ aneq2d elneq2)
  '(eex @ lttrd (anwr ellt) (anwl lmemlt)));

-- A helper function for `Free`. This constructs the set `_V \ deps(a)` if `a`
-- is a regular argument and `(/)` if `a` is a bound argument.
-- MaybeFreeArgs : list SExpr -> Binder -> VarID -> Bool
@_ def MaybeFreeArgs (es a v .s .vs .u: nat): wff =
$ E. s E. vs (a = PReg s vs /\ ~(E. u (u e. vs /\ nth u es = suc (SVar v)))) $;

@_ local def Free_aux (env ctx v: nat): set =
$ SExprRec
  (\ u, nat (HasVar ctx (SVar u) v))
  (\\ f, \\ es, \ ih, nat (E. args E. r E. rs E. o
    (getTerm env f args (r <> rs) o /\
      (ex2 ih1 a (true ih1 /\ MaybeFreeArgs es a v) ih args \/
        E. u (u e. rs /\ nth u es = suc (SVar v)))))) $;

-- Does this expression contain any _free_ occurrence of the variable `v`?
-- This is the more complex binder-respecting check. Intuitively, if
-- `term foo {x y: set} (ph: set x): set y;`, then `foo` binds occurrences of
-- `x` in `ph`, and adds a dependency on `y` regardless. We might write this
-- as `FV(foo x y ph) = (FV(ph) \ {x}) u {y}`, but the definition below is
-- for arbitrary binding structures.
-- Free : Env -> Ctx -> SExpr -> VarID -> Bool
@_ def Free (env ctx e v: nat): wff = $ true (Free_aux env ctx v @ e) $;
pub theorem FreeVar: $ Free env ctx (SVar u) v <-> HasVar ctx (SVar u) v $ =
(named '(bitr
  (trueeq @ eqtr SExprRec_Var @ applame @ nateqd @ HasVareq2d SVareq)
  truenat));

pub theorem FreeApp: $ Free env ctx (SApp f es) v <-> E. args E. r E. rs E. o
  (getTerm env f args (r <> rs) o /\
    (ex2 e a (Free env ctx e v /\ MaybeFreeArgs es a v) es args \/
      E. u (u e. rs /\ nth u es = suc (SVar v)))) $ =
(named @ focus
  '(bitr (trueeq _) truenat)
  '(eqtr {SExprRec_App : $ _ = _ @ (_ <> _ <> map (Free_aux env ctx v) _) $} _)
  '(appslame @ appslamed @ applamed @
    nateqd @ exeqd @ exeqd @ exeqd @ exeqd @ aneqd (getTermeq2d anll) @
    oreqd _ @ exeqd @ aneq2d @ eqeq1d @ ntheq2d anlr)
  '(syl6bb _ (ex2eqd (aneq2d @ MaybeFreeArgseq1d anlr) anr eqidd))
  '(aneq (eqeq1 maplen) @ exeqi @ bitr excomb @ bitr (exeqi _) excomb)
  '(bitr (exeqi @ bitr4 (aneq1i @ bitr4 (aneq1i mapnthb) exan2) exan2) @
    bitr excomb @ exeqi @
    bitr (exeqi @ bitr (aneq1i @ bitr (aneq1i ancomb) anass) anass) @
    exeqe @ aneq2d @ aneq1d trueeq));

-- Is this a valid term in the given environment? A term is valid if
-- the argument list is valid, the return type is valid, and the return sort
-- is not `pure` (because `pure` sorts are not allowed to have term
-- constructors).
-- TermOk : Env -> TermID -> Ctx -> DepType -> Bool
@_ def TermOk (env id args ret .a .r .v .sd: nat): wff =
$ ~E. a E. r E. v getTerm env id a r v /\
  Ctx env args /\ DepType env args ret /\
  E. sd (getSD env (fst ret) sd /\ ~ sPure sd) $;

-- Is this a valid definition in the given environment? A definition is valid
-- if it is a valid term, and the definition typechecks, and all free variables
-- are declared in the return type. (Note in particular that dummies cannot
-- appear in the return type dependencies, so this ensures that all dummies are
-- bound by the definition.)
-- DefOk : Env -> TermID -> Ctx -> DepType -> Bool
@_ def DefOk (env id args ret ds e .ctx .v .s .sd: nat): wff =
$ TermOk env id args ret /\ [ appendDummies args ds / ctx ]
  (Ctx env ctx /\ Expr env ctx e (fst ret) /\
    A. v (Free env ctx e v -> v e. snd ret \/
      E. sd E. s (nth v ctx = suc (PBound s) /\
        getSD env s sd /\ sFree sd))) $;

@_ local def DeclThm_aux (env: nat): set =
$ S\ args, S\ hs, {ret | Ctx env args /\ all {x | ExprProv env args x} (ret : hs)} $;

theorem DeclThm_aux_val (env args hs ret: nat) {x: nat}:
  $ args <> hs <> ret e. DeclThm_aux env <->
    Ctx env args /\ all {x | ExprProv env args x} (ret : hs) $ =
(named '(elsabe @ elsabed @ elabed @ aneqd (Ctxeq2d anll) @
  alleqd (abeqd @ ExprProveq2d anll) (conseqd anr anlr)));

-- Is this a valid declaration in the environment?
-- Decl : Env -> Decl -> Bool
@_ def Decl (env d: nat): wff =
$ d e. Sum
  (Sum
    (Sum
      _V
      (S\ id, S\ args, {ret | TermOk env id args ret}))
    (DeclThm_aux env))
  (Sum
    (S\ id, S\ args, S\ ret, {o | TermOk env id args ret /\
      A. ds A. e (o = suc (ds <> e) -> DefOk env id args ret ds e)})
    (DeclThm_aux env)) $;

pub theorem DeclSort (env id sd: nat): $ Decl env (DSort id sd) $ =
(named '(mpbir Suml @ mpbir Suml @ mpbir Suml elv));
pub theorem DeclTerm (env id args ret: nat):
  $ Decl env (DTerm id args ret) <-> TermOk env id args ret $ =
(named '(bitr Suml @ bitr Suml @ bitr Sumr @
  elsabe @ elsabed @ elabed @ TermOkeqd eqidd anll anlr anr));
pub theorem DeclAxiom (env args hs ret: nat) {x: nat}:
  $ Decl env (DAxiom args hs ret) <->
    Ctx env args /\ all {x | ExprProv env args x} (ret : hs) $ =
(named '(bitr Suml @ bitr Sumr DeclThm_aux_val));
pub theorem DeclDef (env id args ret: nat) {ds e o v: nat}:
  $ Decl env (DDef id args ret o) <-> TermOk env id args ret /\
    A. ds A. e (o = suc (ds <> e) -> DefOk env id args ret ds e) $ =
(named '(bitr Sumr @ bitr Suml @ elsabe @ elsabed @ elsabed @ elabed @
  aneqd (TermOkeqd eqidd an3l anllr anlr) @ aleqd @ aleqd @
  imeqd (eqeq1d anr) @ DefOkeqd eqidd an3l anllr anlr eqidd eqidd));
pub theorem DeclThm (env args hs ret: nat) {x: nat}:
  $ Decl env (DThm args hs ret) <->
    Ctx env args /\ all {x | ExprProv env args x} (ret : hs) $ =
(named '(bitr Sumr @ bitr Sumr DeclThm_aux_val));

@_ local def Env_aux (e: nat): nat =
$ rlrec 1 (\\ e1, \\ s, \ ih, ih * nat (Decl e1 s)) e $;

-- This defines a valid mm0 specification. These are well formed ASTs for which
-- we can assign a provability predicate.
-- Env : Env -> Bool
@_ def Env (e: nat): wff = $ true (Env_aux e) $;
pub theorem Env0: $ Env 0 $ = (named '(mpbir (trueeq rlrec0) true1));
pub theorem EnvS (e s: nat): $ Env (e |> s) <-> Env e /\ Decl e s $ =
(named '(bitr
  (trueeq @ eqtr {rlrecS : $_ = _ @ (_ <> _ <> Env_aux _)$} @
    appslame @ appslamed @ applamed @ muleqd anr @ nateqd @ Decleqd anll anlr)
  (bitr truemul @ aneq2i truenat)));

@_ local def EnvExtend_aux (e2_: nat): nat =
$ rlrec (sn 0)
    (\\ e2, \\ d, \ ih, case
      (case
        (case
          (\\ id, \ sd, lower {e1 | E. e (e1 = e |> DSort id sd /\ e e. ih)})
          (\\ id, \\ a, \ r, lower {e1 | E. e (e1 = e |> DTerm id a r /\ e e. ih)}))
        (\\ a, \\ h, \ r, lower {e1 | E. e (e1 = e |> DAxiom a h r /\ e e. ih)}))
      (case
        (\\ id, \\ a, \\ r, \ o, lower {e1 |
          E. e E. o2 ((o2 != 0 -> o2 = o) /\
            e1 = e |> DDef id a r o2 /\ e e. ih) \/
          e1 e. ih})
        (\\ a, \\ h, \ r, lower {e1 |
          E. e (e1 = e |> DThm a h r /\ e e. ih) \/
          e1 e. ih}))
      @ d)
    e2_ $;

-- `EnvExtend e1 e2` means that environment `e2` is an extension of `e1`,
-- meaning that all sorts, terms, and axioms are preserved, but abstract defs
-- may be provided definitions, and new defs and pub theorems can be added.
-- EnvExtend : Env -> Env -> Bool
@_ def EnvExtend (e1 e2: nat): wff = $ e1 e. EnvExtend_aux e2 $;
pub theorem EnvExtend0 (e: nat): $ EnvExtend e 0 <-> e = 0 $ =
(named '(bitr (elneq2 rlrec0) elsn));

theorem EnvExtend_lem {ih} (p: wff e1 e o2) (q: wff e o2) (A: nat o2)
  (h1: $ ih = EnvExtend_aux E2 -> case
    (case
      (case
        (\\ id, \ sd, lower {e1 | E. e (e1 = e |> DSort id sd /\ e e. ih)})
        (\\ id, \\ a, \ r, lower {e1 | E. e (e1 = e |> DTerm id a r /\ e e. ih)}))
      (\\ a, \\ h, \ r, lower {e1 | E. e (e1 = e |> DAxiom a h r /\ e e. ih)}))
    (case
      (\\ id, \\ a, \\ r, \ o, lower {e1 |
        E. e E. o2 ((o2 != 0 -> o2 = o) /\
          e1 = e |> DDef id a r o2 /\ e e. ih) \/
        e1 e. ih})
      (\\ a, \\ h, \ r, lower {e1 |
        E. e (e1 = e |> DThm a h r /\ e e. ih) \/
        e1 e. ih}))
    @ d
    = lower {e1 | p} $)
  (h2: $ e1 = E1 -> (p <-> q) $)
  (h3: $ p -> E. e E. x (x e. A /\ e1 = e |> x /\ EnvExtend e E2) \/ EnvExtend e1 E2 $):
  $ EnvExtend E1 (E2 |> d) <-> q $ =
(named @ focus
  '(bitr (elneq2 @ eqtr {rlrecS : $_ = _ @ (_ <> _ <> EnvExtend_aux _)$} @
      appslame @ appslamed @ applamed @ eqtrd (appeq2d anlr) (anwr h1)) @
    bitr (ellower _) (elabe h2))
  '(finss (mpbi ssab @ ax_gen _) @
    ! ltfin $ lower ((\ u, fst u |> snd u) |` Xp (EnvExtend_aux E2) A) + EnvExtend_aux E2 $)
  '(rsyl h3 @ eor
    (ltletrd (eex @ eex @ mpbird (lteq1d anlr) _) (a1i leaddid1))
    (ltletrd ellt (a1i leaddid2)))
  '(lelttrd (a1i leprid2) @ syl ellt @
    sylibr (ellower @ finlam @ xpfin finns finns) @
    sylibr prelres @ iand (a1i _) @ sylibr prelxp @ iand anr anll)
  '(mpbir ellam @ iexe (eqeq2d @ preqd id _) eqid)
  '(snoceqd (syl6eq fstpr fsteq) (syl6eq sndpr sndeq)));

theorem EnvExtend_lem2 (p: wff e x)
  (h: $ p -> E. e (e1 = e |> A /\ EnvExtend e E2) \/ EnvExtend e1 E2 $):
  $ p -> E. e E. x (x e. sn A /\ e1 = e |> x /\ EnvExtend e E2) \/ EnvExtend e1 E2 $ =
'(rsyl h @ orim1 @ eximi @ iexe @ aneq1d @
  bitrd (aneqd (a1i elsn) @ eqeq2d snoceq2) bian1);

pub theorem EnvExtendSort (e1 e2 id sd: nat) {e: nat}:
  $ EnvExtend e1 (e2 |> DSort id sd) <->
    E. e (e1 = e |> DSort id sd /\ EnvExtend e e2) $ =
(named '(EnvExtend_lem
  (syl5eq casel @ syl5eq casel @ syl5eq casel @ appslamed @ applamed @
    lowereqd @ abeqd @ exeqd @
    aneqd (eqeq2d @ snoceq2d @ DSorteqd anlr anr) (elneq2d anll))
  (exeqd @ aneq1d eqeq1)
  (EnvExtend_lem2 orl)));

pub theorem EnvExtendTerm (e1 e2 id a r: nat) {e: nat}:
  $ EnvExtend e1 (e2 |> DTerm id a r) <->
    E. e (e1 = e |> DTerm id a r /\ EnvExtend e e2) $ =
(named '(EnvExtend_lem
  (syl5eq casel @ syl5eq casel @ syl5eq caser @ appslamed @ appslamed @ applamed @
    lowereqd @ abeqd @ exeqd @
    aneqd (eqeq2d @ snoceq2d @ DTermeqd anllr anlr anr) (elneq2d an3l))
  (exeqd @ aneq1d eqeq1)
  (EnvExtend_lem2 orl)));

pub theorem EnvExtendAxiom (e1 e2 a h r: nat) {e: nat}:
  $ EnvExtend e1 (e2 |> DAxiom a h r) <->
    E. e (e1 = e |> DAxiom a h r /\ EnvExtend e e2) $ =
(named '(EnvExtend_lem
  (syl5eq casel @ syl5eq caser @ appslamed @ appslamed @ applamed @
    lowereqd @ abeqd @ exeqd @
    aneqd (eqeq2d @ snoceq2d @ DAxiomeqd anllr anlr anr) (elneq2d an3l))
  (exeqd @ aneq1d eqeq1)
  (EnvExtend_lem2 orl)));

pub theorem EnvExtendDef (e1 e2 id a r o: nat) {e o2: nat}:
  $ EnvExtend e1 (e2 |> DDef id a r o) <->
    E. e E. o2 ((o2 != 0 -> o2 = o) /\
      e1 = e |> DDef id a r o2 /\ EnvExtend e e2) \/
    EnvExtend e1 e2 $ =
(named @ focus
  '(EnvExtend_lem
    (syl5eq caser @ syl5eq casel @ appslamed @ appslamed @ appslamed @ applamed @
      lowereqd @ abeqd @ oreqd
        (exeqd @ exeqd @ aneqd
          (aneqd (anwr @ imeq2d eqeq2) @
            eqeq2d @ snoceq2d @ DDefeqd an3lr anllr anlr eqidd)
          (elneq2d an4l))
        (elneq2d an4l))
    (oreqd (exeqd @ exeqd @ aneq1d @ aneq2d eqeq1) eleq1)
    _)
  '(orim1 @ eximi @ eex @ iexde @ imp @ com12 @ anim1d @
    animd (syl5 _ (bi2d eleq1)) (bi2d @ eqeq2d snoceq2))
  '(sylibr elupto @ sylib leltsuc _)
  '(sylib b1le @ sylib b0le @ sylib lepr2 @ sylib lepr2 @ sylib lepr2 _)
  '(eor (mpbiri le01 leeq1) eqle));

pub theorem EnvExtendThm (e1 e2 id a h r: nat) {e o2: nat}:
  $ EnvExtend e1 (e2 |> DThm a h r) <->
    E. e (e1 = e |> DThm a h r /\ EnvExtend e e2) \/
    EnvExtend e1 e2 $ =
(named '(EnvExtend_lem
  (syl5eq caser @ syl5eq caser @ appslamed @ appslamed @ applamed @
    lowereqd @ abeqd @ oreqd
      (exeqd @ aneqd (eqeq2d @ snoceq2d @ DThmeqd anllr anlr anr) (elneq2d an3l))
      (elneq2d an3l))
    (oreqd (exeqd @ aneq1d eqeq1) eleq1)
  (EnvExtend_lem2 id)));

------------------
-- Verification --
------------------

@_ local def substExpr_aux (subst: nat): set =
$ SExprRec (\ v, nth v subst - 1) (\\ f, \\ xs, \ ih, SApp f ih) $;

-- This performs simultaneous substitution of the variables in `e` with the
-- expressions in `sub`.
-- substExpr : list SExpr -> SExpr => SExpr
@_ def substExpr (subst e: nat): nat = $ substExpr_aux subst @ e $;

theorem substExpr_aux_lam: $ substExpr_aux subst == \ e, substExpr subst e $ =
(named '(eqscom (lameqi applam)));

pub theorem substExprVar (subst v e: nat):
  $ substExpr subst (SVar v) = nth v subst - 1 $ =
(named '(eqtr SExprRec_Var @ applame @ subeq1d ntheq1));
pub theorem substExprApp (subst f es: nat) {e: nat}:
  $ substExpr subst (SApp f es) = SApp f (map (\ e, substExpr subst e) es) $ =
(named '(eqtr SExprRec_App @
  ! appslame _ $_ <> map (substExpr_aux _) _$ _ _ _ @ appslamed @ applamed @
  SAppeqd anll @ syl6eq (mapeq1 substExpr_aux_lam) anr));

-- A CExpr is a convertibility proof.
-- CRefl e : e = e
-- CRefl : SExpr -> CExpr
@_ def CRefl (e: nat): nat = $ b0 (b0 e) $;
-- If c : e = e' |- CSymm c : e' = e
-- CSymm : CExpr -> CExpr
@_ def CSymm (c: nat): nat = $ b0 (b1 c) $;
-- {c : e = e'} |- CCong f {c} : f {e} = f {e'}
-- CCong : TermID -> list CExpr -> CExpr
@_ def CCong (f cs: nat): nat = $ b1 (b0 (f <> cs)) $;
-- If f {x} := {y}. e', then
-- c : e'[{x}, {y} -> {e}, {z}] = e'' |- CCong f {z} c : f {e} = e''
-- CUnfold : TermID -> list VarID -> CExpr -> CExpr
@_ def CUnfold (f es zs c: nat): nat = $ b1 (b1 (f <> es <> zs <> c)) $;

theorem CSymm_ltid: $ c < CSymm c $ = '(ltb0tr b1ltid);

theorem CCong_ltid: $ c IN cs -> c < CCong f cs $ =
'(rsyl lmemlt @ mpi (ltb1tr @ leb0tr leprid2) lttr);

theorem CUnfold_ltid: $ c < CUnfold f es zs c $ =
'(ltb1tr @ leb1tr @ lepr2tr @ lepr2tr leprid2);

@_ local def CExprRec (R S C U: set): set =
$ \ e, srec (\ ih, case
  (case R (\ c, S @ (c <> ih @ c)))
  (case
    (\\ f, \ cs, C @ (f <> cs <> map ih cs))
    (\\ f, \\ es, \\ zs, \ c, U @ (f <> es <> zs <> c <> ih @ c))) @ size (Dom ih)) e $;

theorem CExprRec_val: $ CExprRec R S C U @ e = case
  (case R (\ c, S @ (c <> (CExprRec R S C U |` upto e) @ c)))
  (case
    (\\ f, \ cs, C @ (f <> cs <> map (CExprRec R S C U |` upto e) cs))
    (\\ f, \\ es, \\ zs, \ c, U @ (f <> es <> zs <> c <> (CExprRec R S C U |` upto e) @ c))) @ e $ =
(named '(eqtr (applame sreceq2) @
  ! eqtr _ $ _ @ (lower (CExprRec R S C U |` _)) $ _ srecval @
  applame @ appeqd
    (rsyl (bi2 @ eqlower2 @ finlam finns) @
      caseeqd (caseeq2d @ lameqd @ appeq2d @ preq2d appeq1) @
      caseeqd (slameqd @ lameqd @ appeq2d @ preq2d @ preq2d mapeq1) @
      slameqd @ slameqd @ slameqd @ lameqd @ appeq2d @ preq2d @ preq2d @ preq2d @ preq2d appeq1)
    sreclem));

theorem CExprRec_CRefl: $ CExprRec R S C U @ CRefl e = R @ e $ =
(named '(eqtr CExprRec_val @ eqtr casel casel));
theorem CExprRec_CSymm:
  $ CExprRec R S C U @ CSymm c = S @ (c <> CExprRec R S C U @ c) $ =
(named '(eqtr CExprRec_val @ eqtr casel @ eqtr caser @
  applame @ appeq2d @ preqd id @ syl6eq (resapp @ mpbir elupto CSymm_ltid) appeq2));
theorem CExprRec_CCong:
  $ CExprRec R S C U @ CCong f cs = C @ (f <> cs <> map (CExprRec R S C U) cs) $ =
(named '(eqtr CExprRec_val @ eqtr caser @ eqtr casel @
  appslame @ applamed @ appeq2d @ preqd anl @ preqd anr @ syl6eq
    (mapeqg @ mpbir allal @ !! ax_gen e @ syl resapp @ sylibr elupto CCong_ltid)
    (mapeq2d anr)));
theorem CExprRec_CUnfold:
  $ CExprRec R S C U @ CUnfold f es zs c = U @ (f <> es <> zs <> c <> CExprRec R S C U @ c) $ =
(named '(eqtr CExprRec_val @ eqtr caser @ eqtr caser @
  appslame @ appslamed @ appslamed @ applamed @ appeq2d @
  preqd an3l @ preqd anllr @ preqd anlr @ preqd anr @ syl6eq
    (resapp @ mpbir elupto CUnfold_ltid)
    (appeq2d anr)));

theorem indd_aux2 (G p: wff x) (e: $ x = c -> (p <-> q) $)
  (h: $ c < b $): $ G /\ A. z (z < a -> [z / x] p) /\ a = b -> q $ =
'(sylc (eale (imeqd lteq1 (syl6bb (sbe e) sbeq1))) anlr @ mpbiri h @ lteq2d anr);

theorem CExpr_indd {x f e c es zs cs} (n)
  (px: wff x) (pi: wff c) (pr: wff e) (ps: wff c) (pc: wff f cs) (pu: wff f es zs c)
  (hr: $ x = CRefl e -> (px <-> pr) $)
  (hs: $ x = CSymm c -> (px <-> ps) $)
  (hc: $ x = CCong f cs -> (px <-> pc) $)
  (hu: $ x = CUnfold f es zs c -> (px <-> pu) $)
  (hi: $ x = c -> (px <-> pi) $)
  (hn: $ x = n -> (px <-> pn) $)
  (h1: $ G -> pr $)
  (h2: $ G /\ pi -> ps $)
  (h3: $ G /\ all {x | px} cs -> pc $)
  (h4: $ G /\ pi -> pu $): $ G -> pn $ =
'(sylib (sbe hn) @ !! indstr z w sbeq1 sbeq1 ,(split-sop '{
  {($CRefl e$ => (indd_aux hr @ anwll h1)) +
   ($CSymm c$ => (indd_aux hs @ mpd (indd_aux2 hi CSymm_ltid) (anwll @ exp h2)))} +
  {($CCong f cs$ => (indd_aux hc @ sylan h3 anll @
    sylibr (alleq1 cbvabs) @ sylibr allal @
    sylc (alimd @ imim1d @ syl5 CCong_ltid @ bi2d lteq2) anr anlr)) +
   ($CUnfold f es zs c$ => (indd_aux hu @ mpd (indd_aux2 hi CUnfold_ltid) (anwll @ exp h4)))}
}));

-- A VExpr is a proof term.
-- A VHyp is a hypothesis step - a term is asserted from the local context.
-- Indexing is relative to the list of hypotheses to the pub theorem.
-- VHyp : HypID -> VExpr
@_ def VHyp (n: nat): nat = $ b0 (b0 n) $;
-- A VThm is a pub theorem application - a step follows from previous steps by
-- application of a pub theorem. The arguments give the pub theorem to apply, the list
-- of substitutions of expressions for the variables, and the list of subproofs
-- for the hypotheses to the pub theorem.
-- VThm : ThmID -> list SExpr -> list VExpr -> VExpr
@_ def VThm (a h r es ps: nat): nat = $ b0 (b1 (a <> h <> r <> es <> ps)) $;
-- c : A = B, p : A |- VConv c p : B
-- VConv : CExpr -> VExpr -> VExpr
@_ def VConv (c p: nat): nat = $ b1 (c <> p) $;

theorem VThm_ltid: $ p IN ps -> p < VThm a h r es ps $ =
'(rsyl lmemlt @ mpi (ltb0tr @ ltb1tr @ lepr2tr @ lepr2tr @ lepr2tr leprid2) lttr);

theorem VConv_ltid: $ p < VConv c p $ =
'(ltb1tr leprid2);

@_ local def VExprRec (H T C: set): set =
$ \ e, srec (\ ih, case
  (case H
    (\\ a, \\ h, \\ r, \\ es, \ ps, T @ (a <> h <> r <> es <> ps <> map ih ps)))
  (\\ c, \ p, C @ (c <> p <> ih @ p)) @ size (Dom ih)) e $;

theorem VExprRec_val: $ VExprRec H T C @ e = case
  (case H
    (\\ a, \\ h, \\ r, \\ es, \ ps, T @ (a <> h <> r <> es <> ps <> map (VExprRec H T C |` upto e) ps)))
  (\\ c, \ p, C @ (c <> p <> (VExprRec H T C |` upto e) @ p)) @ e $ =
(named '(eqtr (applame sreceq2) @
  ! eqtr _ $ _ @ (lower (VExprRec H T C |` _)) $ _ srecval @
  applame @ appeqd
    (rsyl (bi2 @ eqlower2 @ finlam finns) @
      caseeqd (caseeq2d @ slameqd @ slameqd @ slameqd @ slameqd @ lameqd @
        appeq2d @ preq2d @ preq2d @ preq2d @ preq2d @ preq2d mapeq1) @
      slameqd @ lameqd @ appeq2d @ preq2d @ preq2d appeq1)
    sreclem));

theorem VExprRec_VHyp: $ VExprRec H T C @ VHyp n = H @ n $ =
(named '(eqtr VExprRec_val @ eqtr casel casel));
theorem VExprRec_VThm:
  $ VExprRec H T C @ VThm a h r es ps = T @ (a <> h <> r <> es <> ps <> map (VExprRec H T C) ps) $ =
(named '(eqtr VExprRec_val @ eqtr casel @ eqtr caser @
  appslame @ appslamed @ appslamed @ appslamed @ applamed @
  appeq2d @ preqd an4l @ preqd an3lr @ preqd anllr @ preqd anlr @ preqd anr @ syl6eq
    (mapeqg @ mpbir allal @ !! ax_gen p @ syl resapp @ sylibr elupto VThm_ltid)
    (mapeq2d anr)));
theorem VExprRec_VConv:
  $ VExprRec H T C @ VConv c p = C @ (c <> p <> VExprRec H T C @ p) $ =
(named '(eqtr VExprRec_val @ eqtr caser @
  appslame @ applamed @ appeq2d @
  preqd anl @ preqd anr @ syl6eq
    (resapp @ mpbir elupto VConv_ltid)
    (appeq2d anr)));

theorem VExpr_indd {x n a h r es ps c p} (q)
  (px: wff x) (pi: wff p) (ph: wff n) (pt: wff a h r es ps) (pc: wff c p)
  (hr: $ x = VHyp n -> (px <-> ph) $)
  (hs: $ x = VThm a h r es ps -> (px <-> pt) $)
  (hc: $ x = VConv c p -> (px <-> pc) $)
  (hi: $ x = p -> (px <-> pi) $)
  (hn: $ x = q -> (px <-> pq) $)
  (h1: $ G -> ph $)
  (h2: $ G /\ all {x | px} ps -> pt $)
  (h3: $ G /\ pi -> pc $): $ G -> pq $ =
'(sylib (sbe hn) @ !! indstr z w sbeq1 sbeq1 ,(split-sop '{
  {($VHyp n$ => (indd_aux hr @ anwll h1)) +
   ($VThm a h r es ps$ => (indd_aux hs @ sylan h2 anll @
    sylibr (alleq1 cbvabs) @ sylibr allal @
    sylc (alimd @ imim1d @ syl5 VThm_ltid @ bi2d lteq2) anr anlr))} +
   ($VConv c p$ => (indd_aux hc @ mpd (indd_aux2 hi VConv_ltid) (anwll @ exp h3)))}));

@_ local def VerifyConv_aux (env ctx: nat): set =
$ CExprRec
    (\ e, lower (S\ e1, S\ e2, {s | Expr env ctx e s /\ e = e1 /\ e = e2}))
    (\\ c, \ ih, lower (S\ e1, S\ e2, {s | e2 <> e1 <> s e. ih}))
    (\\ f, \\ cs, \ ih, lower (S\ e1, S\ e2, {s |
      E. args E. ret E. o E. es1 E. es2 (
        e1 = SApp f es1 /\ e2 = SApp f es2 /\
        getTerm env f args ret o /\ (
          E. n (len cs = n /\ len es1 = n /\ len es2 = n /\ len args = n /\
          A. i A. c A. e1 A. e2 A. bi (nth i ih = suc c ->
            nth i es1 = suc e1 -> nth i es2 = suc e2 -> nth i args = suc bi ->
            ExprBi env ctx e1 bi /\ ExprBi env ctx e2 bi /\
            e1 <> e2 <> binderSort bi e. c))) /\
        s = fst ret)}))
    (\\ f, \\ es, \\ zs, \\ c, \ ih, lower (S\ e1, S\ e2, {s |
      E. args E. ret E. ys E. val (
        getTerm env f args ret (suc (ys <> val)) /\
        e1 = SApp f es /\ s = fst ret /\
        all2 e a (ExprBi env ctx e a) es args /\
        all2 y z (nth z ctx = suc (PBound y) /\
          A. e (e IN es -> ~HasVar ctx e z)) ys zs /\
        substExpr (es ++ map (\ i, SVar i) zs) val <> e2 <> s e. ih)})) $;

-- Checking a conversion proof c : (e1 : s) = (e2 : s).
-- VerifyConv : Env -> Ctx -> CExpr -> SExpr -> SExpr -> SortID -> Bool
@_ def VerifyConv (env ctx c e1 e2 s: nat): wff =
$ e1 <> e2 <> s e. VerifyConv_aux env ctx @ c $;

-- VerifyConvs : Env -> Ctx -> list CExpr -> list SExpr -> list SExpr -> list Binder -> Bool
@_ def VerifyConvs (env ctx cs es1 es2 bis .n .i .c .e1 .e2 .bi: nat): wff =
$ E. n (len cs = n /\ len es1 = n /\ len es2 = n /\ len bis = n /\
  A. i A. c A. e1 A. e2 A. bi (nth i cs = suc c ->
    nth i es1 = suc e1 -> nth i es2 = suc e2 -> nth i bis = suc bi ->
    ExprBi env ctx e1 bi /\ ExprBi env ctx e2 bi /\
    VerifyConv env ctx c e1 e2 (binderSort bi))) $;

theorem VerifyConvs_fin: $ E. n A. es1 A. es2 A. bis
  (VerifyConvs env ctx cs es1 es2 bis -> es1 < n /\ es2 < n) $ =
(focus
  (have 'h1
    $ len cs = m /\ len es1 = m /\ len es2 = m /\ len bis = m -> i < m ->
      E. c nth i cs = suc c /\ E. e1 nth i es1 = suc e1 /\
      E. e2 nth i es2 = suc e2 /\ E. bi nth i bis = suc bi $
    (def h '(syl6ib (bitr3 nthne0 exsuc) (com12 @ bi2d lteq2)))
    '(com12 @ animd (animd (animd ,h ,h) ,h) ,h))
  '(! iexe _ $ lower (Array (upto (map (VerifyConv_aux env ctx) cs)) (len cs)) $ _ _
    (aleqd @ aleqd @ aleqd @ imeq2d @ aneqd lteq2 lteq2) @
    ax_gen @ ax_gen @ ax_gen @ eex @ iand _ _)
  (def (lem hlen hlen2 hpr f) @ focus
    '(syl ellt @ sylibr (ellower @ Arrayfin finns) @
      sylibr elArray @ iand _ @ eqtr4d ,hlen an4l)
    '(sylibr elList @ sylibr allnth @ imp @ alimd @
      syl6ib (bitr3 alim1 @ aleqi @ bitr3 impexp @ imeq1i @ bian1a @ sylib nthne0 sucne0) @
      com23 @ syl6 _ @ mpbird (imeq1d @ lteq2d ,hlen2) h1)
    '(com12 @ impd @ impd @ impd @ sylibr eexb @ alimi @
      sylbi (bitr (!! aleqi e1 @ bitr (!! aleqi e2 alim1) alim1) alim1) @
      a2i @ syl5bi (aleqi @ bitr (aleqi alim1) @ bitr alim1 @ imeq2i @ aleqi alim1) _)
    (f '(alimd @ imim2d @ imp @ com23 @ syl6ibr eexb @ alimd @ imim2d @
      exp @ sylibr elupto @ syl (lelttr ,hpr) @
      lttrd (syl ellt anrr) @
      syl lmemlt @ syl lmemmapi @ anwl nthlmem)))
  (lem 'an3lr 'anllr 'leprid1 (fn (x)
    '(syl6 ax_1 @ com23 @ exp @ com23 @ exp @ alimd @ imim2d @
      anrasss @ imp @ com23 @ syl6ibr eexb ,x)))
  (lem 'anllr 'anlr '(lepr2tr leprid1) (fn (x)
    '(syl6ibr eexb @ alimd @ imim2d @ syl6 ax_1 @ com23 @ exp ,x))));

theorem VerifyConv_aux_Refl:
  $ VerifyConv_aux env ctx @ CRefl e = lower (S\ e1, S\ e2, {s |
    Expr env ctx e s /\ e = e1 /\ e = e2}) $ =
(named '(eqtr CExprRec_CRefl @ applame @ lowereqd @ sabeqd @ sabeqd @ abeqd @
  aneqd (aneqd Expreq3 eqeq1) eqeq1));

pub theorem VerifyConvRefl (env ctx e e1 e2 s: nat):
  $ VerifyConv env ctx (CRefl e) e1 e2 s <->
    Expr env ctx e s /\ e = e1 /\ e = e2 $ =
(named @ focus
  '(bitr (elneq2 VerifyConv_aux_Refl) @ bitr (ellower @ trud _) @
    elsabe @ elsabed @ elabed @
    aneqd (aneqd (Expreq4d anr) (eqeq2d anll)) (eqeq2d anlr))
  '(sabfin (eexsabd @ eelabd @ a1i @ sylibr elsn @ eqcomd anlr) (a1i finns) @
    sabfin (eelabd @ a1i @ sylibr elsn @ eqcomd anr) (a1i finns) @
    a1i @ finss (mpbi ssab1 @ ax_gen anll) finns));

theorem VerifyConv_aux_Symm:
  $ VerifyConv_aux env ctx @ CSymm c = lower (S\ e1, S\ e2, {s |
    VerifyConv env ctx c e2 e1 s}) $ =
(named '(eqtr {CExprRec_CSymm : $_ = _ @ (_ <> VerifyConv_aux _ _ @ c)$} @
  appslame @ applamed @ lowereqd @ sabeqd @ sabeqd @ abeqd @
  elneq2d anr));

pub theorem VerifyConvSymm (env ctx c e1 e2 s: nat):
  $ VerifyConv env ctx (CSymm c) e1 e2 s <-> VerifyConv env ctx c e2 e1 s $ =
(named @ focus
  '(bitr (elneq2 VerifyConv_aux_Symm) @ bitr (ellower @ trud _) @
    elsabe @ elsabed @ elabed @ VerifyConveqd eqidd eqidd eqidd anlr anll anr)
  '(sabfin (eexsabd @ eelabd @ a1i @ syl preldm prelrn) (a1i @ dmfin @ rnfin finns) @
    sabfin (eelabd @ a1i preldm) (a1i @ dmfin finns) @
    a1i @ finss (mpbi ssab1 @ ax_gen @ syl prelrn prelrn) (rnfin @ rnfin finns)));

theorem VerifyConv_aux_Cong:
  $ VerifyConv_aux env ctx @ CCong f cs = lower (S\ e1, S\ e2, {s |
    E. args E. ret E. o E. es1 E. es2 (
      e1 = SApp f es1 /\ e2 = SApp f es2 /\
      getTerm env f args ret o /\
      VerifyConvs env ctx cs es1 es2 args /\
      s = fst ret)}) $ =
(named @ focus
  '(eqtr {CExprRec_CCong : $_ = _ @ (_ <> _ <> map (VerifyConv_aux _ _) _)$} @
    appslame @ appslamed @ applamed @ lowereqd @ sabeqd @ sabeqd @ abeqd @
    exeqd @ exeqd @ exeqd @ exeqd @ exeqd @ aneq1d @
    aneqd (aneqd
      (aneqd (eqeq2d @ SAppeq1d anll) (eqeq2d @ SAppeq1d anll))
      (getTermeq2d anll)) _)
  '(exeqd @ aneqd (aneq1d @ aneq1d @ aneq1d @ eqeq1d @ leneqd anlr) @
    !! aleqd n @
    bitr4g alcomb alcomb @ !! aleqd e1 @
    bitr4g alcomb alcomb @ !! aleqd e2 @
    bitr4g alcomb alcomb @ !! aleqd bi @
    syl6bb _ @ aleqd @ imeq1d @ eqeq1d @ ntheq2d anr)
  '(bitr (aleqi @ bitr (imeq1i @ mapnthb) eexb) @
    bitr alcomb @ aleqi @
    bitr (!! aleqi _ @ bitr (imeq1i ancomb) impexp) @ aleqe @
    imeq2d @ imeq2d @ imeq2d @ imeq2d @ aneq2d elneq2));

pub theorem VerifyConvCong (env ctx f cs e1 e2 s: nat) {args ret o es1 es2: nat}:
  $ VerifyConv env ctx (CCong f cs) e1 e2 s <->
    E. args E. ret E. o E. es1 E. es2 (
      e1 = SApp f es1 /\ e2 = SApp f es2 /\
      getTerm env f args ret o /\
      VerifyConvs env ctx cs es1 es2 args /\
      s = fst ret) $ =
(named @ focus
  '(bitr (elneq2 VerifyConv_aux_Cong) @ bitr (ellower _) @
    elsabe @ elsabed @ elabed @ exeqd @ exeqd @ exeqd @ exeqd @ exeqd @
    aneqd (aneq1d @ aneq1d @ aneqd (eqeq1d anll) (eqeq1d anlr)) (eqeq1d anr))
  (suffices 'h $ _ -> _ -> e1_ < SApp env n /\ e2_ < SApp env n /\ s_ < env $ '_)
  (focus
    '(ax_mp (eex _) VerifyConvs_fin)
    '(sabfin (eexsabd @ eelabd @ syl6ibr elupto @ syl6 anll h) (a1i finns) @ anwl @
      sabfin (eelabd @ syl6ibr elupto @ syl6 anlr h) (a1i finns) @ anwl @
      syl (mpi ltfin finss) @ sylib ssab @ iald @ syl6 anr h))
  '(eexd @ eexd @ eexd @ sylibr eexb @ alimi @ sylibr eexb @ alimi @
    sylbir eexb @ com12 @ syld (rsyl anlr @ com12 @ imim1i @ iexe VerifyConvseq6) @
    syld _ (bi2d @ aneqd (aneqd (lteq1d an4l) (lteq1d an3lr)) (lteq1d anr)))
  '(rsyl anllr @ rsyl getTerm_ltid @ exp @ iand (iand _ _) _)
  (focus '(sylib b1lt @ lttrd (sylib ltpr1 an4l) (sylib ltpr2 anrl)))
  (focus '(sylib b1lt @ lttrd (sylib ltpr1 an4l) (sylib ltpr2 anrr)))
  (focus '(syl (lelttr fstleid) anllr)));

theorem VerifyConv_aux_Unfold:
  $ VerifyConv_aux env ctx @ CUnfold f es zs c = lower (S\ e1, S\ e2, {s |
    E. args E. ret E. ys E. val (
      getTerm env f args ret (suc (ys <> val)) /\
      e1 = SApp f es /\ s = fst ret /\
      all2 e a (ExprBi env ctx e a) es args /\
      all2 y z (nth z ctx = suc (PBound y) /\
        A. e (e IN es -> ~HasVar ctx e z)) ys zs /\
      VerifyConv env ctx c (substExpr (es ++ map (\ i, SVar i) zs) val) e2 s)}) $ =
(named '(eqtr {CExprRec_CUnfold : $_ = _ @ (_ <> _ <> _ <> _ <> VerifyConv_aux _ _ @ c)$} @
  appslame @ appslamed @ appslamed @ appslamed @ applamed @ lowereqd @ sabeqd @ sabeqd @ abeqd @
  exeqd @ exeqd @ exeqd @ exeqd @ aneqd
    (aneqd (aneqd (aneq1d @ aneqd (getTermeq2d an4l) (eqeq2d @ SAppeqd an4l an3lr))
      (all2eq2d an3lr))
      (all2eqd (aneq2d @ aleqd @ imeq1d @ lmemeq2d an3lr) eqidd anllr))
    (elneqd (preq1d @ substExpreq1d @ appendeqd an3lr @ mapeq2d anllr) anr)));

pub theorem VerifyConvUnfold (env ctx f zs c e1 e2 s: nat)
  {args ret ys val es a y z e i: nat}:
  $ VerifyConv env ctx (CUnfold f es zs c) e1 e2 s <->
    E. args E. ret E. ys E. val (
      getTerm env f args ret (suc (ys <> val)) /\
      e1 = SApp f es /\ s = fst ret /\
      all2 e a (ExprBi env ctx e a) es args /\
      all2 y z (nth z ctx = suc (PBound y) /\
        A. e (e IN es -> ~HasVar ctx e z)) ys zs /\
      VerifyConv env ctx c (substExpr (es ++ map (\ i, SVar i) zs) val) e2 s) $ =
(named @ focus
  '(bitr (elneq2 VerifyConv_aux_Unfold) @ bitr (ellower _) @
    elsabe @ elsabed @ elabed @ exeqd @ exeqd @ exeqd @ exeqd @
    aneqd (aneq1d @ aneq1d @ aneqd (aneq2d @ eqeq1d anll) (eqeq1d anr))
      (VerifyConveqd eqidd eqidd eqidd eqidd anlr anr))
  '(trud @ sabfin (eexsabd @ eelabd @ syl6ibr elsn @ a1i @
      eex @ eex @ eex @ eex an4lr) (a1i finns) @
    sabfin (eelabd @ a1i @ eex @ eex @ eex @ eex @ anwr @ syl preldm prelrn)
      (a1i @ dmfin @ rnfin finns) @
    a1i @ finss (mpbi ssab @ ax_gen @ eex @ eex @ eex @ eex @
      mpbird (lteq1d an3lr) @ syl (lelttr fstleid) @
      syl getTerm_retltid an5l) ltfin));

@_ local def VerifyProof_aux (env ctx hs: nat): set =
$ VExprRec
    (\ n, lower {ret | nth n hs = suc ret})
    (\\ args2, \\ hs2, \\ ret2, \\ es, \\ ps, \ ih, lower {ret |
      getThm env args2 hs2 ret2 /\
      all2 e a (ExprBi env ctx e a) es args2 /\
      A. u A. v (E. s nth u ctx = suc (PBound s) ->
        v < len ctx -> ~HasVar ctx (SVar v) u ->
        A. y A. e2 (nth u es = suc (SVar y) -> nth v es = suc e2 ->
          ~HasVar ctx e2 y)) /\
      all2 p h (substExpr es h e. p) ih hs2 /\
      substExpr es ret2 = ret})
    (\\ c, \\ p, \ ih, lower {ret |
      E. e1 E. s (VerifyConv env ctx c e1 ret s /\ e1 e. ih)}) $;

-- The main proof checking function. This typechecks a VExpr and determines the
-- SExpr that it represents. At a hypothesis step, this is just looking up the
-- nth element in the list, and at a theorem step, we get the theorem data,
-- check that all the substituting expressions match the binders they are going
-- in for, check that all the disjoint variable conditions of the theorem
-- are honored by the substitution, and then check recursively that the
-- subproofs are okay and the return is what it should be.
-- VerifyProof : Env -> Ctx -> list SExpr -> VExpr -> SExpr -> Bool
@_ def VerifyProof (env ctx hs pf ret: nat): wff =
$ ret e. VerifyProof_aux env ctx hs @ pf $;

theorem VerifyProof_aux_Hyp:
  $ VerifyProof_aux env ctx hs @ VHyp n = lower {ret | nth n hs = suc ret} $ =
(named '(eqtr VExprRec_VHyp @ applame @ lowereqd @ abeqd @ eqeq1d ntheq1));

pub theorem VerifyProofHyp (env ctx hs n ret: nat):
  $ VerifyProof env ctx hs (VHyp n) ret <-> nth n hs = suc ret $ =
(named @ focus
  '(bitr (elneq2 VerifyProof_aux_Hyp) @ bitr (ellower _) @ elabe @ eqeq2d suceq)
  '(finss (mpbi ssab1 @ ax_gen nthlmem) finns));

theorem VerifyProof_aux_Thm:
  $ VerifyProof_aux env ctx hs @ VThm args2 hs2 ret2 es ps = lower {ret |
      getThm env args2 hs2 ret2 /\
      all2 e a (ExprBi env ctx e a) es args2 /\
      A. u A. v (E. s nth u ctx = suc (PBound s) ->
        v < len ctx -> ~HasVar ctx (SVar v) u ->
        A. y A. e2 (nth u es = suc (SVar y) -> nth v es = suc e2 ->
          ~HasVar ctx e2 y)) /\
      all2 p h (VerifyProof env ctx hs p (substExpr es h)) ps hs2 /\
      substExpr es ret2 = ret} $ =
(named @ focus
  '(eqtr {VExprRec_VThm : $_ = _ @ (_ <> _ <> _ <> _ <> _ <> map (VerifyProof_aux _ _ _) _)$} @
    appslame @ appslamed @ appslamed @ appslamed @ appslamed @ applamed @ lowereqd @ abeqd @
    aneqd (aneqd (aneqd (aneqd
      (getThmeqd eqidd an5l an4lr an3lr)
      (all2eqd biidd anllr an5l))
      (aleqd @ aleqd @ imeq2d @ imeq2d @ imeq2d @ aleqd @ aleqd @
        imeqd (eqeq1d @ ntheq2d anllr) @ imeq1d (eqeq1d @ ntheq2d anllr)))
      (syl6bb _ @ all2eqd (eleq1d @ substExpreq1d anllr) anr an4lr))
      (eqeq1d @ substExpreqd anllr an3lr))
  '(aneq (eqeq1 maplen) @ aleqi @
    bitr (aleqi @ bitr alim1 @ bitr (imeq1i mapnthb) @ eexb) @
    bitr alcomb @ aleqi @ bitr (aleqi @ bitr (imeq1i ancomb) impexp) @ aleqe @
    syl6bbr alim1 @ imeq2d @ aleqd @ imeq2d elneq2));

pub theorem VerifyProofThm (env ctx hs args2 hs2 ret2 es ps ret: nat)
  {args e a u v s y e2 p h: nat}:
  $ VerifyProof env ctx hs (VThm args2 hs2 ret2 es ps) ret <->
    (getThm env args2 hs2 ret2 /\
      all2 e a (ExprBi env ctx e a) es args2 /\
      A. u A. v (E. s nth u ctx = suc (PBound s) ->
        v < len ctx -> ~HasVar ctx (SVar v) u ->
        A. y A. e2 (nth u es = suc (SVar y) -> nth v es = suc e2 ->
          ~HasVar ctx e2 y)) /\
      all2 p h (VerifyProof env ctx hs p (substExpr es h)) ps hs2 /\
      substExpr es ret2 = ret) $ =
(named @ focus
  '(bitr (elneq2 VerifyProof_aux_Thm) @ bitr (ellower _) @ elabe @ aneq2d eqeq2)
  '(finss (mpbi ssab1 @ ax_gen @ sylibr elsn @ eqcomd anr) finns));

theorem VerifyProof_aux_Conv:
  $ VerifyProof_aux env ctx hs @ VConv c p = lower {ret |
      E. e1 E. s (VerifyConv env ctx c e1 ret s /\ VerifyProof env ctx hs p e1)} $ =
(named '(eqtr {VExprRec_VConv : $_ = _ @ (_ <> _ <> VerifyProof_aux _ _ _ @ p)$} @
  appslame @ appslamed @ applamed @ lowereqd @ abeqd @
  exeqd @ exeqd @ aneqd (VerifyConveq3d anll) (elneq2d anr)));

pub theorem VerifyProofConv (env ctx hs c p ret: nat) {e1 s: nat}:
  $ VerifyProof env ctx hs (VConv c p) ret <->
    E. e1 E. s (
      VerifyConv env ctx c e1 ret s /\
      VerifyProof env ctx hs p e1) $ =
(named @ focus
  '(bitr (elneq2 VerifyProof_aux_Conv) @ bitr (ellower _) @
    elabe @ exeqd @ exeqd @ aneq1d VerifyConveq5)
  '(finss (mpbi ssab1 @ ax_gen @ eex @ eex @ syl preldm @ syl prelrn anl) (dmfin @ rnfin finns)));

@_ local def Proof_aux (bd env: nat): nat =
$ rlrec (sn 0) (\\ e, \\ d, \ ih, case (\ x, ih)
  (case
    (\\ id, \\ a, \\ r, \ o, lower {p | p e. ih /\ o != 0})
    (\\ a, \\ h, \ r, lower {p | p < bd /\
      E. p1 E. ds E. pf E. ctx (
        p = p1 <> ds <> pf /\ p1 e. ih /\
        ctx = appendDummies a ds /\ Ctx e ctx /\
        VerifyProof e ctx h pf r)})) @ d) env $;

theorem Proof_aux_0: $ Proof_aux bd 0 = sn 0 $ = (named 'rlrec0);
theorem Proof_aux_S: $ Proof_aux bd (env |> d) = case (\ x, Proof_aux bd env)
  (case
    (\\ id, \\ a, \\ r, \ o, lower {p | p e. Proof_aux bd env /\ o != 0})
    (\\ a, \\ h, \ r, lower {p | p < bd /\
      E. p1 E. ds E. pf E. ctx (
        p = p1 <> ds <> pf /\ p1 e. Proof_aux bd env /\
        ctx = appendDummies a ds /\ Ctx env ctx /\
        VerifyProof env ctx h pf r)})) @ d $ =
(named @ focus
  '(eqtr {rlrecS : $ _ = _ @ (_ <> _ <> Proof_aux bd env) $} @
    appslame @ appslamed @ applamed @ appeqd _ anlr)
  '(caseeqd (lameqd anr) @
    caseeqd (slameqd @ slameqd @ slameqd @ lameqd @
      lowereqd @ abeqd @ aneq1d @ elneq2d anr) @
    slameqd @ slameqd @ lameqd @ lowereqd @ abeqd @ aneq2d @
    exeqd @ exeqd @ exeqd @ exeqd @ aneqd
      (aneqd (aneq1d @ aneq2d @ elneq2d anr) (Ctxeq1d anll))
      (VerifyProofeq1d anll)));

theorem Proof_aux_b0: $ Proof_aux bd (env |> b0 x) = Proof_aux bd env $ =
(named '(eqtr Proof_aux_S @ eqtr casel @ applame eqidd));

theorem Proof_aux_Def:
  $ p e. Proof_aux bd (env |> DDef id a r o) <-> p e. Proof_aux bd env /\ o != 0 $ =
(named '(bitr (elneq2 @ eqtr Proof_aux_S @ eqtr caser @ eqtr casel @
    appslame @ appslamed @ appslamed @ applamed @ lowereqd @ abeqd @ aneq2d @ neeq1d anr) @
  bitr (ellower @ finss (mpbi ssab1 @ ax_gen anl) finns) @
  elabe @ aneq1d eleq1));

theorem Proof_aux_Thm:
  $ p e. Proof_aux bd (env |> DThm a h r) <-> p < bd /\
    E. p1 E. ds E. pf E. ctx (
      p = p1 <> ds <> pf /\ p1 e. Proof_aux bd env /\
      ctx = appendDummies a ds /\ Ctx env ctx /\
      VerifyProof env ctx h pf r) $ =
(named '(bitr (elneq2 @ eqtr Proof_aux_S @ eqtr caser @ eqtr caser @
    appslame @ appslamed @ applamed @ lowereqd @ abeqd @
    aneq2d @ exeqd @ exeqd @ exeqd @ exeqd @ aneqd
      (aneq1d @ aneq2d @ eqeq2d @ appendDummieseq1d anll)
      (VerifyProofeqd eqidd eqidd anlr eqidd anr)) @
  bitr (ellower @ finss (mpbi ssab1 @ ax_gen @ sylibr elupto anl) finns) @
  elabe @ aneqd lteq1 @ exeqd @ exeqd @ exeqd @ exeqd @
  aneq1d @ aneq1d @ aneq1d @ aneq1d eqeq1));

-- The main recursion for the proof judgment on an environment. Here `env` are
-- the declarations that have already been processed and `e` are the
-- declarations we are still stepping through. `p` is a proof object whose
-- existence entails provability of the environment.
-- Proof : Env -> Proof -> Bool
@_ def Proof (env p: nat): wff = $ p e. Proof_aux (suc p) env $;

theorem el_Proof_aux: $ p < bd -> (p e. Proof_aux bd env <-> Proof env p) $ =
(named @ focus
  '(mpi ltsucid @ syl (!! eale q @ imeqd lteq1 @ bieqd eleq1 eleq1) _)
  (def h '(bieqd (elneq2d Proof_auxeq2) (elneq2d Proof_auxeq2)))
  (def h2 '(aleqd @ imeq2d ,h))
  '(!! indstr x y ,h2 ,h2 @ cases _ _)
  (focus '(a1d @ iald @ a1d @ mpbiri (elneq2 @ eqtr4 Proof_aux_0 Proof_aux_0) ,h))
  (focus
    '(sylbi exsnoc @ com12 @ sylibr eexb @ imp @ alimd @ com23 @
      eexd @ expcom @ imld (mpbiri snoclt @ lteq2d anl) _)
    (def h0 '(Proof_auxeq2d @ eqtrd anll @ snoceq2d anr))
    (def h1 '(elneq2d @ syl6eq Proof_aux_b0 ,h0))
    (def h2 '(syl6bb Proof_aux_Def @ elneq2d ,h0))
    (def h3 '(rsyl anll @ syl6bb Proof_aux_Thm @ elneq2d ,h0))
    (split-sop '{
      (1 => (alimd @ imim2d @ bi2d @ bieqd ,h1 ,h1)) +
     {($DDef id a r o$ => (alimd @ imim2d @ syl5 (aneq1d id) @ bi2d @ bieqd ,h2 ,h2)) +
      ($DThm a h r$ => (syl5bi (cbval @ imeqd lteq1 @ bieqd eleq1 eleq1) @
        exp @ iald @ exp @ mpbird (bieqd ,h3 ,h3) @
        aneqd (sylc bith (lelttrd (sylibr leltsuc anr) an3lr) anr) @
        syl exeq @ anrasss @ imp @ alimd @ exp @
        exeqd @ exeqd @ exeqd @ aneq1d @ aneq1d @ aneq1d @ syl aneq2a @
        imp @ imim1d @ exp @ lelttrd (mpbiri leprid1 (leeq2d anr)) anlr))}})));

pub theorem Proof0 (p: nat): $ Proof 0 p <-> p = 0 $ = '(bitr (elneq2 Proof_aux_0) elsn);
pub theorem ProofSort (env id sd p: nat):
  $ Proof (env |> DSort id sd) p <-> Proof env p $ = '(elneq2 Proof_aux_b0);
pub theorem ProofTerm (env id a r p: nat):
  $ Proof (env |> DTerm id a r) p <-> Proof env p $ = '(elneq2 Proof_aux_b0);
pub theorem ProofAxiom (env a h r p: nat):
  $ Proof (env |> DAxiom a h r) p <-> Proof env p $ = '(elneq2 Proof_aux_b0);
pub theorem ProofDef (env id a r o p: nat):
  $ Proof (env |> DDef id a r o) p <-> Proof env p /\ o != 0 $ = 'Proof_aux_Def;
pub theorem ProofThm (env e p a h r: nat) {p1 ds pf ctx: nat}:
  $ Proof (env |> DThm a h r) p <-> E. p1 E. ds E. pf E. ctx (
    p = p1 <> ds <> pf /\ Proof env p1 /\
    ctx = appendDummies a ds /\ Ctx env ctx /\
    VerifyProof env ctx h pf r) $ =
'(bitr Proof_aux_Thm @ bitr (bian1 ltsucid) @
  exeqi @ exeqi @ exeqi @ exeqi @ aneq1i @ aneq1i @ aneq1i @
  aneq2a @ syl el_Proof_aux @ sylib leltsuc @ mpbiri leprid1 leeq2);

-- A specification is provable if some extension of the specification has a proof.
-- The extension provides definitions for the providing all the omitted definitions and proving all the pub theorems in the
-- file.
-- ValidEnv : Env -> Bool
@_ def ValidEnv (env .e .p: nat): wff = $ E. e (EnvExtend env e /\ E. p Proof e p) $;


-------------
-- Parsing --
-------------

-- Definition of ASCII, or at least the part of it we need
@_ def _nl:     char = $ ch x0 xa $; -- "\n" newline character
@_ def _cr:     char = $ ch x0 xd $; -- "\r" carriage return
@_ def __:      char = $ ch x2 x0 $; -- " " space
@_ def _dollar: char = $ ch x2 x4 $; -- "$" dollar sign
@_ def _lparen: char = $ ch x2 x8 $; -- "(" left parenthesis
@_ def _rparen: char = $ ch x2 x9 $; -- ")" right parenthesis
@_ def _ast:    char = $ ch x2 xa $; -- "*" asterisk / multiplication symbol
@_ def _hyphen: char = $ ch x2 xd $; -- "-" hyphen / minus sign
@_ def _dot:    char = $ ch x2 xe $; -- "." dot / period / full stop
@_ def _colon:  char = $ ch x3 xa $; -- ":" colon
@_ def _semi:   char = $ ch x3 xb $; -- ";" semicolon
@_ def _equal:  char = $ ch x3 xd $; -- "=" equal sign
@_ def _gt:     char = $ ch x3 xe $; -- ">" greater than, right arrow
@_ def _under:  char = $ ch x5 xf $; -- "_" underscore (note: __ is space)
@_ def _lbrace: char = $ ch x7 xb $; -- "{" left brace / curly bracket
@_ def _rbrace: char = $ ch x7 xd $; -- "}" right brace / curly bracket

-- ASCII numbers
@_ def _0: char = $ ch x3 x0 $;
@_ def _1: char = $ ch x3 x1 $;
@_ def _2: char = $ ch x3 x2 $;
@_ def _3: char = $ ch x3 x3 $;
@_ def _4: char = $ ch x3 x4 $;
@_ def _5: char = $ ch x3 x5 $;
@_ def _6: char = $ ch x3 x6 $;
@_ def _7: char = $ ch x3 x7 $;
@_ def _8: char = $ ch x3 x8 $;
@_ def _9: char = $ ch x3 x9 $;

-- Don't really need capitals except as a range
@_ def _A: char = $ ch x4 x1 $;
@_ def _Z: char = $ ch x5 xa $;

-- Most of the lowercase alphabet, used in keywords
@_ def _a: char = $ ch x6 x1 $;
@_ def _b: char = $ ch x6 x2 $;
@_ def _c: char = $ ch x6 x3 $;
@_ def _d: char = $ ch x6 x4 $;
@_ def _e: char = $ ch x6 x5 $;
@_ def _f: char = $ ch x6 x6 $;
@_ def _h: char = $ ch x6 x8 $;
@_ def _i: char = $ ch x6 x9 $;
@_ def _l: char = $ ch x6 xc $;
@_ def _m: char = $ ch x6 xd $;
@_ def _n: char = $ ch x6 xe $;
@_ def _o: char = $ ch x6 xf $;
@_ def _p: char = $ ch x7 x0 $;
@_ def _r: char = $ ch x7 x2 $;
@_ def _s: char = $ ch x7 x3 $;
@_ def _t: char = $ ch x7 x4 $;
@_ def _u: char = $ ch x7 x5 $;
@_ def _v: char = $ ch x7 x6 $;
@_ def _x: char = $ ch x7 x8 $;
@_ def _z: char = $ ch x7 xa $;

do (begin
  (def (mkth-pr m a b f)
    (def t '(,m (c2n (,a)) (c2n (,b))))
    (add-thm! (atom-app a "_" m b) () () t () @ fn ()
      (def g (ref! (goal t)))
      (set-goals g) (refine (f)) '(() ,g)))
  (def (mkth m a b)
    (mkth-pr m a b @ fn () '{,norm_num : (,m (c2n (ch _ _)) (c2n (ch _ _)))}))
  (let ([a (ref!)]) @
    scan '(_nl _dot _0 _9 _colon _gt _A _Z _under _a _z _lbrace _rbrace) @ fn (b)
      (if (def? a) (mkth 'lt a b))
      (set! a b))
  (mkth 'le '_0 '_1)
  (mkth 'lt '_dollar '_hyphen)
  (mkth 'lt '_dollar '_0)
  (scan '((_nl _cr __ _dollar _lparen _rparen _ast _hyphen _dot)
          (_colon _semi _equal _gt)) @ fn (s)
    @ match s @ (a . l) @ match (split-last s) @ (r . m)
    (scan l @ fn (b) (mkth 'le a b))
    (scan l @ fn (a) (mkth 'le a r)))
  (scan
    '((_dollar _0 _9) (_9 _colon _gt) (_9 _gt _A) (_0 _9 _A) (_dollar _9 _A)
      (_Z _under _a) (_Z _a _z) (_A _Z _under) (_A _Z _a)
      (_under _a _z) (_9 _A _Z) (_9 _Z _z) (_dollar _9 _z))
    @ match-fn @ (a b c)
    @ mkth-pr 'lt a c @ fn () '(lttr ,(atom-app a "_lt" b) ,(atom-app b "_lt" c))));

-- Now we define the lexer:

@_ def prefix (s t .x: nat): wff = $ E. x s ++ x = t $;

theorem takeprefix: $ prefix (take l n) l $ = '(!! iexe l2 (eqeq1d appendeq2) takedrop);

theorem prefix_eq_take: $ prefix l1 l2 <-> l1 = take l2 (len l1) $ =
(named @ focus
  '(ibii (!! eex r @ syl5eqr _ takeeq1) (mpbiri takeprefix prefixeq1))
  '(eqtrd takeappend1 takeall leid));

theorem prefix_len: $ prefix l1 l2 -> len l1 <= len l2 $ =
'(sylbi prefix_eq_take @ mpbiri minle1 @ leeq1d @ syl6eq takelen @ leneq);

theorem prefix_asymm: $ len l2 <= len l1 -> prefix l1 l2 -> l1 = l2 $ =
'(syl5bi prefix_eq_take @ bi1d @ eqeq2d takeall);

theorem prefix_0: $ prefix 0 l $ = '(!! iexe r (eqeq1d appendeq2) append0);
theorem prefix_id: $ prefix l l $ = '(!! iexe r (eqeq1d appendeq2) append02);
theorem prefix_tr: $ prefix l1 l2 -> prefix l2 l3 -> prefix l1 l3 $ =
'(!! eex r1 @ !! eexda r2 @ !! iexde r3 @ eqtrd (appendeq2d anr) @
  syl5eqr appendass @ eqtrd (appendeq1d anll) anlr);

theorem prefix_02: $ prefix l 0 <-> l = 0 $ =
(named '(bitr (exeqi @ bitr appendeq0 ancomb) @ exeqe biidd));

theorem prefix_S1: $ prefix (x : l1) l2 <-> E. l3 (prefix l1 l3 /\ l2 = x : l3) $ =
(named '(bitr4 (exeqi @
    bitr3 (exeqe @ syl6bb eqcomb @ eqeq2d @ syl6eqr appendS conseq2) @
    exeqi @ aneq1i eqcomb) @
  bitr3 (exeqi exan2) excomb));

theorem prefix_append1: $ prefix (l ++ l1) (l ++ l2) <-> prefix l1 l2 $ =
'(!! exeqi x @ bitr (eqeq1 appendass) appendcan1);

theorem prefix_S: $ prefix (x : l1) (y : l2) <-> x = y /\ prefix l1 l2 $ =
(named '(bitr4 prefix_S1 @ bitr3 (exeqe @ syl5bb ancomb @ aneq2d prefixeq2) @
  exeqi @ bitr anlass @ aneq2i @ bitr4 ancomb @ bitr eqcomb consinj));

theorem prefix_nth: $ prefix l1 l2 -> nth n l1 = suc x -> nth n l2 = suc x $ =
'(sylbi prefix_eq_take @ exp @
  eqtr3d (syl takenth @ anwr @ sylib nthne0 sucne0) @ eqtr3d (ntheq2d anl) anr);

@_ def maxPrefix (A: set) (s: nat): nat =
$ the {z | E. x E. t (x ++ t = s /\ x e. A /\
    A. y (prefix y s /\ y e. A -> prefix y x) /\
    z = suc (x <> t))} $;

pub theorem maxPrefix0 {x: nat} (A: set) (s: nat):
  $ ~ (E. x (prefix x s /\ x e. A)) -> maxPrefix A s = 0 $ =
(named '(eqthe0abd @ syl absurd @ con3 @ eximi @ eex @
  anwl @ anwl @ anim1 @ iexe @ eqeq1d appendeq2));

theorem maxPrefix_subsn: $ subsn {z |
  E. x E. t (x ++ t = s /\ x e. A /\
    A. y (prefix y s /\ y e. A -> prefix y x) /\
    z = suc (x <> t))} $ =
(named @ focus
  (def h '(elabe @ exeqd @ exeqd @ aneq2d eqeq1))
  '(ax_gen @ ax_gen @ sylbi ,h @ syl5bi (bitr ,h _) @ eex @ eex @ eexd @ eexd @ exp _)
  (focus '(cbvex @ cbvexd @
    aneqd (aneqd (aneqd (eqeq1d @ imp appendeq) @ eleq1d anl) @
    aleqd @ imeq2d @ prefixeq2d anl) @
    eqeq2d @ suceqd @ imp preq))
  (suffices 'h2 $ _ -> x = w $ _)
  '(eqtr4d anlr @ eqtr4d anrr @ suceqd @ preqd h2 @
    sylib appendcan1 @ eqtr4d an4l @ eqtrd (appendeq1d h2) (anwr an3l))
  (def (lem hl hr)
    '(sylc (eale @ imeqd (aneqd prefixeq1 eleq1) prefixeq1) (syl anlr ,hl) @
      iand (syl (anw3l @ iexe @ eqeq1d appendeq2) ,hr) (syl anllr ,hr)))
  '(sylc prefix_asymm (syl prefix_len _) _)
  (lem 'anl 'anr)
  (lem 'anr 'anl));

pub theorem maxPrefixS {x y t: nat} (A: set) (s: nat):
  $ E. x (prefix x s /\ x e. A) ->
    E. x E. t (x ++ t = s /\ x e. A /\
      A. y (prefix y s /\ y e. A -> prefix y x) /\
      maxPrefix A s = suc (x <> t)) $ =
(named @ focus
  '(! rsyl _ $ E. n (n <= len s /\ take s n e. A /\ A. y (prefix y s -> y e. A -> len y <= n)) $)
  (focus
    (def h2 '(elabe @ aleqd @ imeq2d leeq2))
    (def N $ least {i | A. m (take s m e. A -> min (len s) m <= i)} $)
    '(syl (! iexe _ ,N _ _ @
        aneqd (aneqd leeq1 @ eleq1d takeeq2) (aleqd @ imeq2d @ imeq2d leeq2)) _)
    (have 'h3 $ len s e. {i | A. m (take s m e. A -> min (len s) m <= i)} $
      '(mpbir ,h2 @ ax_gen @ a1i minle1))
    (have 'h4 $ _ -> y = take s (len y) $ '(sylib prefix_eq_take anlr))
    (def hal '(imeqd (eleq1d takeeq2) (leeq1d mineq2)))
    (have 'h5 $ A. m2 (take s m2 e. A -> min (len s) m2 <= ,N) $
      '(mpbi ,h2 @ mpbi (eleq2 @ cbvab @ syl5bb (cbval ,hal) @ aleqd @ imeq2d leeq2) @ leastel h3))
    (def h5 '(eale ,hal h5))
    '(eex @ iand (iand (a1i @ leastle h3) _) @ iald @ exp @ exp @
      mpbid (leeq1d @ syl5eqr takelen @ leneqd @ eqcomd h4) @
      syl ,h5 @ mpbid (eleq1d h4) anr)
    (have 'h6 $ _ -> x = take s (len x) $ '(sylib prefix_eq_take anll))
    (have 'h7 $ _ -> take s (len x) e. A $ '(mpbid (eleq1d h6) anlr))
    '(casesd
      (exp @ mpbird (eleq1d @ takeeq2d @ eqtr4d anr @ eqtrd (leneqd h6) @ syl5eq takelen @
        sylib le02 @ mpbid (leeq2d anr) @ syl ,h5 h7) h7)
      (syl5bi exsuc @ !! eexda j @ mpbird (eleq1d @ takeeq2d anr) @ mpi ltirr @ con1d @
        exp @ mpbid (leeq1d anlr) @ syl leastle @
        sylibr ,h2 @ sylibr (cbval ,hal) @ iald @ exp @ sylibr leltsuc @ sylibr ltlene @
        iand (mpbid (leeq2d anllr) @ anwr @ eal h5) @
        mpd anlr @ con3d @ syl5ibrcom (eleq1d @ syl6eq takemin @ takeeq2d eqcom) anr)))
  (def h '(elabe @ exeqd @ exeqd @ aneq2d eqeq1))
  '(eex @ sylib ,h @ syl (mpbird (eleq1d (subsnthe maxPrefix_subsn)) id) @ sylibr ,h @ iexde @ iexde @
    iand (iand (iand (syl6eq takedrop @ appendeqd anlr anr) @ mpbird (eleq1d anlr) an3lr) @
      sylc _ (iand an4l anlr) anllr) (eqcomd @ suceqd @ preqd anlr anr))
  '(alimd @ syl5bir impexp @ a2d @ exp @ exp @ sylibr prefix_eq_take @
    eqtrd (sylib prefix_eq_take @ anld anlr) @ syl5eqr (takeeq1 takedrop) @
    eqtr4d (syl takeappend1 @ mpbird (leeq2d @ syl5eq takelen @ syl eqmin2 an3l) anr) @
    takeeq1d anllr));

theorem maxPrefixSilem: $ maxPrefix A s = suc (x <> t) ->
  x ++ t = s /\ x e. A /\ A. y (prefix y s /\ y e. A -> prefix y x) $ =
(named '(mpd (syl maxPrefixS @ rsyl sucne0 @ con1 maxPrefix0) @
  eexd @ eexd @ impd @ com23 @ exp @ rsyl (sylib prth @ sylib peano2 @ eqtr3d anl anr) @
  bi2d @ aneqd (aneqd (eqeq1d @ imp appendeq) (eleq1d anl)) @
  anwl @ aleqd @ imeq2d prefixeq2));

theorem maxPrefixSi1: $ maxPrefix A s = suc (x <> t) -> x ++ t = s $ = (named '(anld @ anld maxPrefixSilem));
theorem maxPrefixSi2: $ maxPrefix A s = suc (x <> t) -> x e. A $ = (named '(anrd @ anld maxPrefixSilem));
theorem maxPrefixSi3 (h1: $ G -> maxPrefix A s = suc (x <> t) $)
  (h2: $ G -> prefix y s $) (h3: $ G -> y e. A $): $ G -> prefix y x $ =
(named '(sylc (eale @ imeqd (aneqd prefixeq1 eleq1) prefixeq1)
  (anrd @ syl maxPrefixSilem h1) @ iand h2 h3));

theorem maxPrefix_eqS (h1: $ G -> prefix a s $) (h2: $ G -> a e. A $):
  $ G -> E. x E. t maxPrefix A s = suc (x <> t) $ =
(named '(syl (eximi @ eximi anr) @ syl maxPrefixS @
  syl (iexe @ aneqd prefixeq1 eleq1) (iand h1 h2)));

theorem maxPrefix_prefix: $ maxPrefix A s = suc (x <> t) -> prefix x s $ =
(named '(syl (iexe @ eqeq1d appendeq2) maxPrefixSi1));

theorem maxPrefix_asymm {y} (h: $ x e. A /\ y e. A /\ prefix x y -> x = y $):
  $ maxPrefix A s = suc (x <> t) <-> x ++ t = s /\ x e. A $ =
(named @ focus
  '(ibii (iand maxPrefixSi1 maxPrefixSi2) @
    mpd (maxPrefix_eqS (iexde @ eqtrd (appendeq2d anr) anll) anr) @
    eexd @ eexd @ exp @ eqtr4d anr @ suceqd _)
  (suffices 'h2)
  '(preqd h2 @ sylib appendcan1 @ eqtr3d (appendeq1d h2) @ eqtr4d anll (anwr maxPrefixSi1))
  '(syl h @ iand (iand anlr @ anwr maxPrefixSi2) @
    maxPrefixSi3 anr (anwll @ iexe @ eqeq1d appendeq2) anlr));

@_ def regexStar (R: set) (.s .t .L .x .y: nat): set =
$ opab s t (E. L (all2 x y (x <> y e. R) L t /\ s = ljoin L)) $;
@_ def regexApp (R S: set) (.z .a .b .x .y: nat): set =
$ {z | E. x E. y E. a E. b (x <> a e. R /\ y <> b e. S /\
    z = (x ++ y) <> (a <> b))} $;
infixr regexApp: $<+>$ prec 75;
@_ def regexPlus (R: set) (.x: nat): set =
$ regexStar R i^i {x | snd x != 0} $;
@_ def regexOpt (R: set) (.s .t .y: nat): set =
$ sn 0 u. opab s t (E. y (s <> y e. R /\ t = suc y)) $;

-- The set of whitespace characters
-- white : set char
@_ def white: nat = $ __ ; sn _nl $;

theorem el_white: $ c e. white <-> c = __ \/ c = _nl $ = '(bitr elins @ oreq2i elsn);

theorem white_lt_dollar: $ c e. white -> c < _dollar $ =
(focus (def h '(mpbiri {_ : $ch < ch$} lteq1))
  '(sylbi el_white @ eor ,h ,h) norm_num norm_num);

theorem white_lt_hyphen: $ c e. white -> c < _hyphen $ =
'(rsyl white_lt_dollar @ mpi (ltle _dollar_lt_hyphen) ltletr);

@_ def regexLineComment (.x .y: nat): set =
$ (\ x, _hyphen : _hyphen : x ++ _nl : 0) '' {x | all {y | y != _nl} x} $;

theorem el_regexLineComment: $ s e. regexLineComment <->
  E. x (all {y | y != _nl} x /\ s = _hyphen : _hyphen : (x ++ _nl : 0)) $ =
'(bitr ellamimaab @ exeqi @ aneq2i @ eqeq2 @ eqtr appendS @ conseq2 appendS);

theorem regexLineComment_n0: $ s e. regexLineComment -> s != 0 $ =
(named '(sylbi el_regexLineComment @ eex @ anwr sucne0));

theorem regexLineComment_hd: $ (x : t) e. regexLineComment -> x = _hyphen /\ t != 0 $ =
(named '(sylbi el_regexLineComment @ eex @ anwr @ sylbi consinj @ anim2 sucne0));

theorem regex_asymm_lem
  (hA: $ A == (\ x, l ++ x ++ c : 0) '' {x | all {y | y != c} x} $)
  (hs: $ G -> s e. A $) (ht: $ G -> t e. A $) (h: $ G -> prefix s t $): $ G -> s = t $ =
(focus
  (def (f x) '(sylib ellamimaab @ sylib (eleq2 hA) ,x))
  '(mpd h @ syl prefix_asymm @ mpd ,(f 'hs) @ eexda @
    mpd (sylibr _ ,(f '(anwl ht))) @ eexda _)
  '(!! cbvex z _ (aneqd alleq2 @ eqeq2d @ appendeq1d appendeq2))
  (def (f x) '(syl6eq (addeq1 appendlen) @ syl6eq appendlen @ leneqd ,x))
  '(mpbird (leeqd ,(f 'anrr) ,(f '(anrd anlr))) @ sylib leadd1 @ sylib leadd2 @
    sylibr lenlt @ mpi eqid @ con2d @
    exp @ sylib (elabe neeq1) @ sylc elall (anld anlr) @
    syl nthlmem @ eqtr3d (syl appendnth1 anr) @
    syl (mpi (eqtr (appendnth2 leid) @ eqtr (ntheq1 subid) nthZ) prefix_nth) @ anwl _)
  (def (f x) '(syl6eq appendass ,x))
  '(sylib prefix_append1 @ mpbid (prefixeqd ,(f '(anrd anlr)) ,(f 'anrr)) (anwll h)));

theorem regexLineComment_asymm (hs: $ G -> s e. regexLineComment $) (ht: $ G -> t e. regexLineComment $)
  (h: $ G -> prefix s t $): $ G -> s = t $ =
(named @ focus
  '(regex_asymm_lem _ hs ht h)
  '(imaeq1 @ lameqi @ appendeq1 @ eqcomi @ eqtr appendS @ conseq2 append1));

@_ def whitespace (.c: nat): set =
$ ((\ c, c : 0) '' white) u. regexLineComment $;

theorem el_whitespace: $ s e. whitespace <->
  (E. c (c e. white /\ s = c : 0)) \/ s e. regexLineComment $ = '(bitr elun @ oreq1i ellamima);

theorem whitespace_n0: $ s e. whitespace -> s != 0 $ =
'(sylbi el_whitespace @ eor (!! eex x @ anwr sucne0) regexLineComment_n0);

theorem whitespace_hd: $ (x : t) e. whitespace -> x e. white \/ x = _hyphen $ =
(named '(sylbi el_whitespace @ orim
  (eex @ impcom @ bi2d @ sylbi consinj @ anwl eleq1)
  (anld regexLineComment_hd)));

theorem whitespace_lt_0: $ (x : t) e. whitespace -> x < _0 $ =
(focus
  '(rsyl whitespace_hd @ eor (sylbi el_white @ eor _ _) _)
  (def (p) @ focus '(mpbiri {_ : $ch < ch$} lteq1) norm_num)
  (p) (p) (p));

theorem whitespace_hd_RLC: $ (x : t) e. whitespace -> x = _hyphen -> (x : t) e. regexLineComment $ =
(named '(syl5 (con2 @ eex @ syl ltne @ syl white_lt_hyphen @
    impcom @ bi2d @ eleq1d @ sylbi consinj anl) @
  bi1 el_whitespace));

theorem whitespace_hd_white: $ (x : t) e. whitespace -> x != _hyphen -> x e. white /\ t = 0 $ =
'(sylbi el_whitespace @ eor
  (a1d @ !! eex y @ imp @ syl5bi consinj @ anim1d @ com12 @ bi2d eleq1)
  (syl absurdr @ anld regexLineComment_hd));

theorem whitespace_asymm (hs: $ G -> s e. whitespace $) (ht: $ G -> t e. whitespace $)
  (h: $ G -> prefix s t $): $ G -> s = t $ =
(named @ focus
  '(mpd (sylib excons @ syl whitespace_n0 hs) @ eexd @ eexda @ casesda _ _)
  (focus
    '(regexLineComment_asymm
      (mpbird (eleq1d anlr) @ sylc whitespace_hd_RLC (mpbid (eleq1d anlr) @ anwll hs) anr)
      (mpd (sylib prefix_S1 @ mpbid (prefixeq1d anlr) (anwll h)) @ eexda @ mpbird (eleq1d anrr) @
        sylc whitespace_hd_RLC (mpbid (eleq1d anrr) (anw3l ht)) anlr)
      (anwll h)))
  (focus
    '(eqtr4d (eqtrd anlr @ conseq2d @ anrd @
        sylc whitespace_hd_white (mpbid (eleq1d anlr) (anwll hs)) anr) @
      mpd (sylib prefix_S1 @ mpbid (prefixeq1d anlr) @ anwll h) @
      eexda @ eqtrd anrr @ conseq2d @ anrd @
      sylc whitespace_hd_white (mpbid (eleq1d anrr) (anw3l ht)) anlr)));

theorem whitespace_maxPrefix: $ s e. whitespace <-> maxPrefix whitespace (s ++ t) = suc (s <> t) $ =
(named '(bitr4 (bicom @ bian1 eqid) (maxPrefix_asymm @ whitespace_asymm anll anlr anr)));

@_ def regexMath (.x .y: nat): set =
$ (\ x, _dollar : x ++ _dollar : 0) '' {x | all {y | y != _dollar} x} $;

theorem el_regexMath: $ s e. regexMath <->
  E. x (all {y | y != _dollar} x /\ s = _dollar : x ++ _dollar : 0) $ = 'ellamimaab;

theorem regexMath_n0: $ s e. regexMath -> s != 0 $ =
(named '(sylbi el_regexMath @ eex @ anwr @ sylbi (eqeq2 appendS) sucne0));

theorem regexMath_asymm (hs: $ G -> s e. regexMath $) (ht: $ G -> t e. regexMath $)
  (h: $ G -> prefix s t $): $ G -> s = t $ =
(named @ focus '(regex_asymm_lem _ hs ht h) '(imaeq1 @ lameqi @ appendeq1 @ eqcomi append1));

theorem regexMath_hd: $ (x : t) e. regexMath -> x = _dollar $ =
(named '(sylbi el_regexMath @ eex @ anwr @ sylbi (eqeq2 appendS) @ sylbi consinj anl));

theorem regexMath_maxPrefix: $ s e. regexMath <-> maxPrefix regexMath (s ++ t) = suc (s <> t) $ =
(named '(bitr4 (bicom @ bian1 eqid) (maxPrefix_asymm @ regexMath_asymm anll anlr anr)));

@_ def IdentStart (.c: nat): set =
$ {c | (_a <= c /\ c <= _z) \/ (_A <= c /\ c <= _Z) \/ c = _under} $;

theorem el_IdentStart: $ c e. IdentStart <-> (_a <= c /\ c <= _z) \/ (_A <= c /\ c <= _Z) \/ c = _under $ =
(named '(elabe @ oreqd (oreqd (aneqd leeq2 leeq1) (aneqd leeq2 leeq1)) eqeq1));

theorem IdentStart_bound: $ c e. IdentStart -> _A <= c /\ c <= _z $ =
'(sylbi el_IdentStart @ eor
  (eor (anim1 @ letr @ ltle _A_lt_a) (anim2 @ mpi (ltle _Z_lt_z) letr))
  (mpbiri (ian (ltle _A_lt_under) (ltle _under_lt_z)) (aneqd leeq2 leeq1)));

@_ def digits (.c: nat): set = $ {c | _0 <= c /\ c <= _9} $;

theorem eldigits: $ c e. digits <-> _0 <= c /\ c <= _9 $ = (named '(elabe @ aneqd leeq2 leeq1));

theorem digits0: $ _0 e. digits $ = '(mpbir eldigits @ ian leid @ ltle _0_lt_9);
theorem digits9: $ _9 e. digits $ = '(mpbir eldigits @ ian (ltle _0_lt_9) leid);

@_ def IdentRest (.c: nat): set = $ IdentStart u. digits $;

theorem IdentRest_bound: $ c e. IdentRest -> _0 <= c /\ c <= _z $ =
'(sylbi elun @ eor
  (rsyl IdentStart_bound @ anim1 @ letr @ ltle _0_lt_A)
  (sylbi eldigits @ anim2 @ mpi (ltle _9_lt_z) letr));

@_ def regexIdent (.s .x .y .t: nat): set =
$ {s | E. x E. t (s = x : t /\ x e. IdentStart /\ all IdentRest t)} $;

theorem el_regexIdent: $ s e. regexIdent <->
  E. x E. t (s = x : t /\ x e. IdentStart /\ all IdentRest t) $ =
(named '(elabe @ exeqd @ exeqd @ aneq1d @ aneq1d eqeq1));

theorem regexIdent_n0: $ s e. regexIdent -> s != 0 $ =
(named '(sylbi el_regexIdent @ eex @ eex @ rsyl anll sucne0));

theorem regexIdent_cons: $ (x : t) e. regexIdent <-> x e. IdentStart /\ all IdentRest t $ =
(named '(bitr el_regexIdent @ bitr (exeqi @ bitr (exeqi @
    bitr anass @ bitr (aneq1i @ bitr eqcomb consinj) anass) exan1) @
  exeqe @ syl6bb (exeqe @ aneq2d alleq2) (exeqd @ aneq2d @ aneq1d eleq1)));

theorem regexIdent_bound: $ (x : t) e. regexIdent -> _A <= x /\ x <= _z $ =
'(sylbi regexIdent_cons @ anwl IdentStart_bound);

@_ def isNumber (.s .x .y .t: nat): set =
$ sn (_0 : 0) u. {s | E. x E. t (s = x : t /\
  _1 <= x /\ x <= _9 /\ all digits t)} $;

theorem el_isNumber: $ s e. isNumber <-> s = _0 : 0 \/
  E. x E. t (s = x : t /\ _1 <= x /\ x <= _9 /\ all digits t) $ =
(named '(bitr elun @ oreq elsn @ elabe @ exeqd @ exeqd @ aneq1d @ aneq1d @ aneq1d eqeq1));

theorem isNumber_n0: $ s e. isNumber -> s != 0 $ =
(named '(sylbi el_isNumber @ eor sucne0 @ eex @ eex @ rsyl an3l sucne0));

theorem isNumber_allDigits: $ l e. isNumber -> all digits l $ =
(named '(sylbi el_isNumber @ eor (mpbiri (mpbir all1 digits0) alleq2) @
  eex @ eex @ mpbird (alleq2d an3l) @ sylibr allS @
  anim1 @ sylibr eldigits @ anim1 @ anwr @ letr _0_le_1));

theorem isNumber_hd: $ (x : t) e. isNumber -> _0 <= x /\ x <= _9 $ =
'(rsyl isNumber_allDigits @ sylbi allS @ sylib eldigits anl);

@_ def symbols: nat =
$ _ast ; _dot ; _colon ; _semi ; _lparen ; _rparen ;
  _gt ; _lbrace ; _rbrace ; sn _equal $;

theorem symbols_bound: $ c e. symbols -> _dollar < c /\ c < _0 \/ _9 < c /\ c < _A \/ _z < c $ =
(focus
  (def (nn) (refine '{,norm_num : $ch _ _ < ch _ _$}))
  (def (d1 r) (r '(orld @ orld @ mpbiri (ian _ _) (aneqd lteq2 lteq1))) (nn) (nn))
  (def (d2 r) (r '(orld @ orrd @ mpbiri (ian _ _) (aneqd lteq2 lteq1))) (nn) (nn))
  (def (d3 r) (r '(orrd @ mpbiri _ lteq2)) (nn))
  (scan (list d1 d1 d2 d2 d1 d1 d2 d3 d3) @ fn (f)
    (f @ fn (x) @ refine '(sylbi elins @ eor ,x _)))
  (d2 @ fn (x) (refine '(sylbi elsn ,x))));

theorem symbols_bound2: $ c e. symbols -> _dollar < c /\ (c < _0 \/ _9 < c) /\ (c < _A \/ _z < c) $ =
'(rsyl symbols_bound @ iand (iand
  (eor (eor anl @ anwl @ lttr _dollar_lt_9) (lttr _dollar_lt_z))
  (eor (orim anr anl) (orrd @ lttr _9_lt_z)))
  (orim1 @ eor (anwr @ mpi _0_lt_A lttr) anr));

theorem symbols_ne_hyphen: $ c e. symbols -> c != _hyphen $ =
(focus
  (def (f) @ focus '(mpbiri {_ : $ch != ch$} neeq1) norm_num)
  (for 0 9 @ fn (_) (refine '(sylbi elins @ eor _ _)) (f))
  '(sylbi elsn _) (f));

@_ def TK (s: nat): nat = $ b0 s $;
@_ def MATH (s: nat): nat = $ b1 s $;

@_ local def Tokenize_aux (G s A F n): nat =
$ if (maxPrefix A s = 0) n
    (obind (G @ snd (maxPrefix A s - 1)) (\ t,
      suc (F @ (fst (maxPrefix A s - 1) <> t)))) $;

theorem Tokenize_aux_0: $ maxPrefix A s = 0 -> Tokenize_aux G s A F n = n $ = (named 'ifpos);

theorem Tokenize_aux_n0 (a: nat x) {y} (h: $ y e. A -> y != 0 $):
  $ f = lower ((\ x, a) |` upto s) ->
    Tokenize_aux f s A F n = Tokenize_aux (\ x, a) s A F n $ =
(named @ focus
  '(casesda (anwr @ eqtr4d Tokenize_aux_0 Tokenize_aux_0) @
    eqtr4d (syl ifneg anr) @ eqtr4d (syl ifneg anr) @
    obindeq1d @ eqtrd (appeq1d @ sylibr (eqlower2 @ finlam finns) anl) _)
  (have 'h2 $ _ -> maxPrefix A s = suc _ $ '(eqcomd @ anwr consfstsnd))
  '(syl resapp @ sylibr elupto @ mpbid (lteq2d @ syl maxPrefixSi1 h2) @
    sylib ltappendid2 @ syl (sbeth (imeqd eleq1 neeq1) h) @ syl maxPrefixSi2 h2));

@_ def Tokenize {.s1} (s: nat): nat =
$ srec (\ f, N[size (Dom f) / s1]
    if (s1 = 0) 1 (
    Tokenize_aux f s1 whitespace (\\ x, \ t, t) (
    Tokenize_aux f s1 regexIdent (\\ x, \ t, TK x : t) (
    Tokenize_aux f s1 isNumber (\\ x, \ t, TK x : t) (
    Tokenize_aux f s1 ((\ c, c : 0) '' symbols) (\\ x, \ t, TK x : t) (
    Tokenize_aux f s1 regexMath (\\ x, \ t, MATH x : t) (
    0))))))) s $;

theorem symbols_cons: $ (x : b) e. ((\ c, c : 0) '' A) <-> x e. A /\ b = 0 $ =
'(bitr ellamima @ bitr (exeqi @ bitr (aneq2i @
    bitr consinj @ aneq1i eqcomb) anlass) @ exeqe @ aneq1d eleq1);

theorem symbols_n0: $ x e. ((\ c, c : 0) '' A) -> x != 0 $ = '(sylbi ellamima @ eex @ anwr sucne0);

theorem symbols_asymm:
  $ x e. ((\ c, c : 0) '' A) /\ y e. ((\ c, c : 0) '' A) /\ prefix x y -> x = y $ =
(named '(imp @ imp @ sylbi ellamima @
  syl5bi (bitr ellamima @ cbvex @ aneqd eleq1 @ eqeq2d conseq1) @
  eex @ eexda @ mpbiri (sylbi prefix_S @ conseq1d anl) @
  imeqd (prefixeqd anlr anrr) (eqeqd anlr anrr)));

theorem symbols_maxPrefix: $ x e. A <-> maxPrefix ((\ c, c : 0) '' A) (x : t) = suc (x : 0 <> t) $ =
(named '(bitr2 (maxPrefix_asymm symbols_asymm) @
  bitr (bian1 append1) @ bitr symbols_cons @ bian2 eqid));

theorem Tokenize_val: $ Tokenize s = if (s = 0) 1 (
    Tokenize_aux (\ r, Tokenize r) s whitespace (\\ x, \ t, t) (
    Tokenize_aux (\ r, Tokenize r) s regexIdent (\\ x, \ t, TK x : t) (
    Tokenize_aux (\ r, Tokenize r) s isNumber (\\ x, \ t, TK x : t) (
    Tokenize_aux (\ r, Tokenize r) s ((\ c, c : 0) '' symbols) (\\ x, \ t, TK x : t) (
    Tokenize_aux (\ r, Tokenize r) s regexMath (\\ x, \ t, MATH x : t) (
    0)))))) $ =
(named @ focus
  '(! eqtr _ $ _ @ lower ((\ r, Tokenize r) |` _) $ _ srecval @ applame @ sbned _)
  (have 'h '(eqtrd anr (anwl sreclem)))
  '(ifeqd (eqeq1d h) eqidd ,(foldr
    '(whitespace_n0 regexIdent_n0 isNumber_n0 symbols_n0 regexMath_n0)
    'eqidd
    (fn (x acc) '(eqtrd (Tokenize_auxeq2d h) @
      eqtrd (anwl @ !! Tokenize_aux_n0 _ y ,x) @ Tokenize_auxeq5d ,acc)))));

theorem Tokenize_aux_S (v1 n: nat x1 t1 r1) (v: nat t) (h: $ x1 = x /\ t1 = t -> v1 = v $):
  $ maxPrefix A s = suc (x <> r) ->
    Tokenize_aux (\ r1, Tokenize r1) s A (\\ x1, \ t1, v1) n = obind (Tokenize r) (\ t, suc v) $ =
'(eqtrd (syl ifneg sucne0) @ obindeqd
  (applamed @ Tokenizeeqd @ eqtrd anr @ syl6eq sndpr @ sndeqd @ syl6eq sucsub1 @ subeq1d anl)
  (lameqd @ suceqd @ syl6eq (appslame @ applamed h) @
   appeq2d @ preq1d @ syl6eq fstpr @ fsteqd @ syl6eq sucsub1 subeq1));

pub theorem Tokenize0: $ Tokenize 0 = suc 0 $ = (named '(eqtr Tokenize_val @ ifpos eqid));

theorem Tokenize_n0_lem (h: $ x e. A -> x != 0 $): $ maxPrefix A s = suc (x <> r) -> s != 0 $ =
'(mtd (rsyl maxPrefixSi2 h) @ mpbii anl @ imeq1d @ syl5bbr appendeq0 @ eqeq1d maxPrefixSi1);

pub theorem TokenizeWS (s x: nat):
  $ s e. whitespace -> Tokenize (s ++ x) = Tokenize x $ =
(named '(sylbi whitespace_maxPrefix @ syl5eq Tokenize_val @
  eqtrd (syl ifneg @ Tokenize_n0_lem whitespace_n0) @
  syl6eq obindS2 @ Tokenize_aux_S anr));

theorem Tokenize_ne_lem {a b c y} (p: wff a b c)
  (hA: $ x e. A -> x != 0 $) (hB: $ y e. B -> y != 0 $)
  (h1: $ (a : b) e. A -> p $) (h2: $ (a : c) e. B -> ~p $):
  $ maxPrefix A s = suc (x <> r) -> maxPrefix B s = 0 $ =
(named @ focus
  '(mpd (sylib excons @ syl hA maxPrefixSi2) @ eexd @ eexda @ syl contra @
    syl5bi excons @ eexd @ eexda @
    mpd (anwr @ sylib excons @ syl hB maxPrefixSi2) @ eexd @ eexda @ sylc absurd
    (syl h2 @ mpbid (eleq1d _) @ syl maxPrefixSi2 anlr)
    (syl h1 @ mpbid (eleq1d anllr) @ syl maxPrefixSi2 an3l))
  '(eqtr4d anr @ conseq1d @ anld @ sylib consinj @
    syl5eqr appendS @ eqtr3d (appendeq1d anllr) @ eqtr4d (anw3l maxPrefixSi1) @
    syl5eqr appendS @ eqtr3d (appendeq1d anr) @ rsyl anlr maxPrefixSi1));

pub theorem TokenizeIdent {t: nat} (s x r: nat):
  $ maxPrefix regexIdent s = suc (x <> r) ->
    Tokenize s = obind (Tokenize r) (\ t, suc (TK x : t)) $ =
(named '(syl5eq Tokenize_val @
  eqtrd (syl ifneg @ Tokenize_n0_lem regexIdent_n0) @
  eqtrd (syl Tokenize_aux_0 @ Tokenize_ne_lem regexIdent_n0 whitespace_n0
    (anld regexIdent_bound) (sylib ltnle @ syl (mpi _0_lt_A lttr) whitespace_lt_0)) @
  Tokenize_aux_S @ conseqd (TKeqd anl) anr));

pub theorem TokenizeNumber {t: nat} (s x r: nat):
  $ maxPrefix isNumber s = suc (x <> r) ->
    Tokenize s = obind (Tokenize r) (\ t, suc (TK x : t)) $ =
(named '(syl5eq Tokenize_val @
  eqtrd (syl ifneg @ Tokenize_n0_lem isNumber_n0) @
  eqtrd (syl Tokenize_aux_0 @ Tokenize_ne_lem isNumber_n0 whitespace_n0
    (anld isNumber_hd) (sylib ltnle @ rsyl whitespace_hd @ eor
      (rsyl white_lt_dollar @ mpi _dollar_lt_0 lttr)
      (mpbiri (lelttr _hyphen_le_dot _dot_lt_0) lteq1))) @
  eqtrd (syl Tokenize_aux_0 @ Tokenize_ne_lem isNumber_n0 regexIdent_n0
    (anrd isNumber_hd) (sylib ltnle @ syl (ltletr _9_lt_A) @ anld regexIdent_bound)) @
  Tokenize_aux_S @ conseqd (TKeqd anl) anr));

pub theorem TokenizeSymbol {t: nat} (c x: nat):
  $ c e. symbols -> Tokenize (c : x) =
    obind (Tokenize x) (\ t, suc (TK (c : 0) : t)) $ =
(named @ focus
  (have 'n0 '(a1i consne0))
  (have 'bd '(sylbi symbols_cons anl))
  (have 'bd2 '(syl symbols_bound2 bd))
  '(syl5eq Tokenize_val @ syl5eq (ifneg consne0) @ sylbi symbols_maxPrefix @
    eqtrd (syl Tokenize_aux_0 @ Tokenize_ne_lem n0 whitespace_n0 bd @
      rsyl whitespace_hd @ eor
        (syl (con3 @ anld @ anld symbols_bound2) @ syl ltnlt @ white_lt_dollar)
        (con2 symbols_ne_hyphen)) @
    eqtrd (syl Tokenize_aux_0 @ Tokenize_ne_lem n0 regexIdent_n0 (anrd bd2) @
      sylibr notor @ sylib (aneq lenlt lenlt) regexIdent_bound) @
    eqtrd (syl Tokenize_aux_0 @ Tokenize_ne_lem n0 isNumber_n0 (anrd @ anld bd2) @
      sylibr notor @ sylib (aneq lenlt lenlt) isNumber_hd) @
    Tokenize_aux_S @ conseqd (TKeqd anl) anr));

pub theorem TokenizeMath {t: nat} (s x: nat):
  $ s e. regexMath -> Tokenize (s ++ x) =
    obind (Tokenize x) (\ t, suc (MATH s : t)) $ =
(named '(sylbi regexMath_maxPrefix @ syl5eq Tokenize_val @
  eqtrd (syl ifneg @ Tokenize_n0_lem regexMath_n0) @
  eqtrd (syl Tokenize_aux_0 @ Tokenize_ne_lem regexMath_n0 whitespace_n0 regexMath_hd @
    rsyl whitespace_hd @ eor (syl ltne white_lt_dollar) (mpbiri (ltner _dollar_lt_hyphen) neeq1)) @
  eqtrd (syl Tokenize_aux_0 @ Tokenize_ne_lem regexMath_n0 regexIdent_n0 regexMath_hd @
    rsyl regexIdent_bound @ anwl @ syl ltner @ ltletr _dollar_lt_A) @
  eqtrd (syl Tokenize_aux_0 @ Tokenize_ne_lem regexMath_n0 isNumber_n0 regexMath_hd @
    rsyl isNumber_hd @ anwl @ syl ltner @ ltletr _dollar_lt_0) @
  eqtrd (syl Tokenize_aux_0 @ Tokenize_ne_lem regexMath_n0 symbols_n0 regexMath_hd @
    sylbi symbols_cons @ anwl @ rsyl symbols_bound2 @ anwll ltner) @
  Tokenize_aux_S @ conseqd (MATHeqd anl) anr));

pub theorem TokenizeElse {x: nat} (s: nat):
  $ s != 0 ->
    ~(E. x (x e. whitespace /\ prefix x s)) ->
    maxPrefix regexIdent s = 0 ->
    maxPrefix isNumber s = 0 ->
    ~(E. x (x e. symbols /\ prefix (x : 0) s)) ->
    ~(E. x (x e. regexMath /\ prefix x s)) ->
    Tokenize s = 0 $ =
(named @ focus
  '(exp @ exp @ exp @ exp @ exp _)
  '(syl5eq Tokenize_val @ eqtrd (syl ifneg an5l) @
    eqtrd (syl Tokenize_aux_0 @ syl (sylbi (noteq @ exeqi ancomb) maxPrefix0) an4lr) @
    eqtrd (syl Tokenize_aux_0 an3lr) @
    eqtrd (syl Tokenize_aux_0 anllr) @
    eqtrd (syl Tokenize_aux_0 @ syl (syl maxPrefix0 @
      con3 @ eex @ imp @ syl5bi ellamima @ eximd @ anim2d @ com12 @ bi1d prefixeq1) anlr) @
    syl Tokenize_aux_0 @ syl (sylbi (noteq @ exeqi ancomb) maxPrefix0) anr));

-- Now the parser:

@_ def regexMap (F R: set): set = $ cnv F o. R $;
infixr regexMap: $<@>$ prec 100;

@_ def regexAppL (R S: set) (.x: nat): set = $ (\ x, fst x) <@> (R <+> S) $;
infixl regexAppL: $<+$ prec 77;

@_ def regexAppR (R S: set) (.x: nat): set = $ (\ x, snd x) <@> (R <+> S) $;
infixr regexAppR: $+>$ prec 76;

def parseTk (tk: string): set = $ sn (TK tk <> 0) $;
def parseOptTk (tk: string): set = $ regexOpt (parseTk tk) $;
def parseCh (c: char): set = $ parseTk (s1 c) $;

@_ def _pure: string = $ _p ': _u ': _r ': _e ': s0 $;
@_ def _strict: string = $ _s ': _t ': _r ': _i ': _c ': _t ': s0 $;
@_ def _provable: string = $ _p ': _r ': _o ': _v ': _a ': _b ': _l ': _e ': s0 $;
@_ def _free: string = $ _f ': _r ': _e ': _e ': s0 $;

@_ def parseSortData: set =
$ (parseOptTk _pure <+> parseOptTk _strict) <+>
  (parseOptTk _provable <+> parseOptTk _free) $;

@_ def parseIdent_ (.s: nat): set = $ (\ s, TK s <> s) '' regexIdent $;
@_ def parseIdent (.x: nat): set = $ parseIdent_ i^i {x | snd x != s1 _under} $;

@_ def ASTSort (x: nat): nat = $ b0 (b0 (b0 x)) $;
@_ def ASTTerm (x: nat): nat = $ b0 (b0 (b1 x)) $;
@_ def ASTAxiom (x: nat): nat = $ b0 (b1 (b0 x)) $;
@_ def ASTDef (x: nat): nat = $ b0 (b1 (b1 x)) $;
@_ def ASTThm (x: nat): nat = $ b1 (b0 (b0 x)) $;
@_ def ASTIO (out x: nat): nat = $ b1 (b0 (b1 (out <> x))) $;
@_ def ASTNota (x: nat): nat = $ b1 (b1 x) $;

@_ def _sort: string = $ _s ': _o ': _r ': _t ': s0 $;
@_ def parseSort (.x: nat): set = $ (\ x, ASTSort x) <@>
  (parseSortData <+> parseTk _sort +> parseIdent <+ parseCh _semi) $;

@_ def parseType (.x: nat): set = $ (\ x, b0 x) <@>
  (parseIdent <+> regexStar parseIdent) $;
@_ def parseFmla (.s: nat): set = $ Ran (\ s, MATH s <> b1 s) $;
@_ def parseTypeFmla: set = $ parseType u. parseFmla $;

@_ def parseDummyId (.x: nat): set =
$ (\ x, b0 x) <@> parseIdent_ u.
  (\ x, b1 x) <@> (parseCh _dot +> parseIdent) $;

-- This throws all binders into a common parsed representation.
-- {x: set}     goes to    (0, b0 "x", b0 ("set", []))
-- (x: set)     goes to    (1, b0 "x", b0 ("set", []))
-- (x: set y)   goes to    (1, b0 "x", b0 ("set", ["y"]))
-- (x: $foo$)   goes to    (1, b0 "x", b1 "foo")
-- (_: $foo$)   goes to    (1, b0 "_", b1 "foo")
-- (.x: set)    goes to    (1, b1 "x", b0 ("set", []))

@_ def parseCurlyBinder (.x .z: nat): set =
$ (\ z, map (\ x, 0 <> x <> snd z) (fst z)) <@>
  (parseCh _lbrace +> regexStar parseDummyId <+>
    parseCh _colon +> parseTypeFmla <+ parseCh _rbrace) $;
@_ def parseRegBinder (.x .z: nat): set =
$ (\ z, map (\ x, 1 <> x <> snd z) (fst z)) <@>
  (parseCh _lparen +> regexStar parseDummyId <+>
    parseCh _colon +> parseTypeFmla <+ parseCh _rparen) $;
@_ def parseBinder (.x .y: nat): set = $ parseCurlyBinder u. parseRegBinder $;

@_ def parseBinders (.x .z: nat): set =
$ (\ x, ljoin x) <@> regexStar parseBinder $;

@_ def parseArrows: set =
$ regexStar (parseTypeFmla <+ parseCh _gt) <+> parseTypeFmla $;

@_ def parseBindersAndArrows (.x .z: nat): set =
$ (\ x, (fst x ++ map (\ z, (1 <> b0 (s1 _under) <> z)) (pi21 x)) <> pi22 x) <@>
  (parseBinders <+> parseCh _colon +> parseArrows) $;

def parseSimple (tk: string): set =
$ parseTk tk +> parseIdent <+> parseBindersAndArrows <+ parseCh _semi $;

@_ def _term: string = $ _t ': _e ': _r ': _m ': s0 $;
@_ def parseTerm (.x: nat): set = $ (\ x, ASTTerm x) <@> parseSimple _term $;

@_ def _axiom: string = $ _a ': _x ': _i ': _o ': _m ': s0 $;
@_ def parseAxiom (.x: nat): set = $ (\ x, ASTAxiom x) <@> parseSimple _axiom $;

@_ def _theorem: string = $ _t ': _h ': _e ': _o ': _r ': _e ': _m ': s0 $;
@_ def parseThm (.x: nat): set = $ (\ x, ASTThm x) <@> parseSimple _theorem $;

@_ def _def: string = $ _d ': _e ': _f ': s0 $;
@_ def parseDef (.x: nat): set = $ (\ x, ASTDef x) <@>
  (parseTk _theorem +> parseIdent <+> parseBinders <+>
    parseCh _colon +> parseType <+>
    regexOpt (parseCh _equal +> parseFmla) <+ parseCh _semi) $;

@_ def NotaDelim (x: nat): nat = $ b0 (b0 x) $;
@_ def NotaInfix (x y: nat): nat = $ b0 (b1 (b0 (x <> y))) $;
@_ def NotaPfx (x: nat): nat = $ b0 (b1 (b1 x)) $;
@_ def NotaCoe (x: nat): nat = $ b1 (b0 x) $;
@_ def NotaGen (x: nat): nat = $ b1 (b1 x) $;

@_ def _delimiter: string =
$ _d ': _e ': _l ': _i ': _m ': _i ': _t ': _e ': _r ': s0 $;
@_ def parseDelim (.x: nat): set = $ (\ x, NotaDelim x) <@>
  (parseTk _delimiter +>
    (((\ x, x <> x) <@> parseFmla) u.
     (parseFmla <+> parseFmla)) <+ parseCh _semi) $;

@_ def stoi (x: nat): nat = $ rlrec 0 (\\ s, \\ i, \ ih, ih * 10 + (i - _0)) x $;
pub theorem stoi0: $ stoi 0 = 0 $ = (named 'rlrec0);
pub theorem stoiS (s x: nat): $ stoi (s |> x) = stoi s * 10 + (x - _0) $ =
(named '(eqtr {rlrecS : $ _ = _ @ (_ <> _ <> stoi _) $} @
  appslame @ appslamed @ applamed @ addeqd (muleq1d anr) (subeq1d anlr)));

@_ def parseNumber (.s: nat): set = $ (\ s, TK s <> stoi s) '' isNumber $;

@_ def _max: string = $ _m ': _a ': _x ': s0 $;
@_ def parsePrec (.x: nat): set = $ parseTk _max u. (\ x, suc x) <@> parseNumber $;

@_ def _prec: string = $ _p ': _r ': _e ': _c ': s0 $;
def parseSimpleNota (tk: string): set =
$ parseTk tk +> parseIdent <+> parseCh _colon +> parseFmla <+>
    parseTk _prec +> parsePrec <+ parseCh _semi $;

@_ def _infixl: string = $ _i ': _n ': _f ': _i ': _x ': _l ': s0 $;
@_ def _infixr: string = $ _i ': _n ': _f ': _i ': _x ': _r ': s0 $;
@_ def _prefix: string = $ _p ': _r ': _e ': _f ': _i ': _x ': s0 $;
@_ def parseInfixl (.x: nat): set = $ (\ x, NotaInfix 0 x) <@> parseSimpleNota _infixl $;
@_ def parseInfixr (.x: nat): set = $ (\ x, NotaInfix 1 x) <@> parseSimpleNota _infixr $;
@_ def parsePfx (.x: nat): set = $ (\ x, NotaPfx x) <@> parseSimpleNota _prefix $;

@_ def _coercion: string = $ _c ': _o ': _e ': _r ': _c ': _i ': _o ': _n ': s0 $;
@_ def parseCoe (.x: nat): set = $ (\ x, NotaCoe x) <@>
  (parseTk _coercion +> parseIdent <+>
   parseCh _colon +> parseIdent <+>
   parseCh _gt +> parseIdent <+> parseCh _semi) $;

@_ def parseLiteral (.x: nat): set =
$ ((\ x, b0 x) <@> (parseCh _lparen +> parseFmla <+>
    parseCh _colon +> parsePrec <+ parseCh _rparen)) u.
  ((\ x, b1 x) <@> parseIdent) $;

@_ def _notation: string = $ _n ': _o ': _t ': _a ': _t ': _i ': _o ': _n ': s0 $;
@_ def parseGenNota (.x: nat): set = $ (\ x, NotaCoe x) <@>
  (parseTk _notation +> parseIdent <+>
   parseBinders <+> parseCh _colon +> parseType <+>
   parseCh _equal +> regexPlus parseLiteral <+ parseCh _semi) $;

@_ def parseNota (.x: nat): set = $ (\ x, ASTNota x) <@>
  (parseDelim u. parseInfixl u. parseInfixr u. parsePfx u.
    parseCoe u. parseGenNota) $;

@_ def _input: string = $ _i ': _n ': _p ': _u ': _t ': s0 $;
@_ def _output: string = $ _o ': _u ': _t ': _p ': _u ': _t ': s0 $;

@_ def inputKinds: nat = $0$;
@_ def outputKinds: nat = $0$;

def parseIO1 (tk: string) (k .x .s: nat): set =
$ parseTk tk +> (parseIdent i^i {x | snd x e. k}) <+>
  parseCh _colon +>
    regexStar (((\ s, TK s) <@> parseIdent) u. Ran (\ s, MATH s <> MATH s))
    <+ parseCh _semi $;

@_ def parseIO (.x: nat): set =
$ ((\ x, ASTIO 0 x) <@> parseIO1 _input inputKinds) u.
  ((\ x, ASTIO 1 x) <@> parseIO1 _output outputKinds) $;

@_ def parseAST: set =
$ regexStar (parseSort u. parseTerm u. parseAxiom u.
    parseThm u. parseDef u. parseNota u. parseIO) $;

@_ def parse (s ast .tks: nat): wff =
$ E. tks (Tokenize s = suc tks /\ tks <> ast e. parseAST) $;

--------------------
-- AST Navigation --
--------------------

@_ def lookupVar (ctx x: nat): nat =
$ rlrec 0 (\\ bis, \\ p, \ ih, N[fst (snd p) / y] if (x = y) (suc (len bis)) ih) ctx $;

pub theorem lookupVar0 (x: nat): $ lookupVar 0 x = 0 $ = (named 'rlrec0);

theorem lookupVarS:
  $ lookupVar (bis |> (c <> x <> t)) y =
    if (y = x) (suc (len bis)) (lookupVar bis y) $ =
(named '(eqtr {rlrecS : $ _ = _ @ (_ <> _ <> lookupVar _ _) $} @
  appslame @ appslamed @ applamed @ sbned @
  ifeqd (eqeq2d @ eqtrd anr @ syl6eq fstpr @ fsteqd @ syl6eq sndpr @ sndeqd anllr)
    (suceqd @ leneqd an3l) anlr));

pub theorem lookupVarEq (bis c x t: nat):
  $ lookupVar (bis |> (c <> x <> t)) x = suc (len bis) $ = '(eqtr lookupVarS @ ifpos eqid);
pub theorem lookupVarNe (bis c x y t: nat): $ y != x ->
  lookupVar (bis |> (c <> x <> t)) y = lookupVar bis y $ = '(syl5eq lookupVarS ifneg);

------------------
-- Math Parsing --
------------------

@_ def nonemptyNonwhite (.s .c: nat): set =
$ {s | s != 0 /\ all {c | ~c e. white} s} $;

theorem el_nonemptyNonwhite: $ s e. nonemptyNonwhite <-> s != 0 /\ all {c | ~c e. white} s $ =
(named '(elabe @ aneqd neeq1 alleq2));

@_ def simpleTokenize {.s1} (s: nat): nat =
$ srec (\ f,
    lrec 0 (\\ c, \\ s1, \ _ih,
      if (c e. white) (f @ s1) (
        N[maxPrefix nonemptyNonwhite (c : s1) - 1 / p]
        (fst p : f @ snd p)))
    (size (Dom f))) s $;

theorem simpleTokenize_val: $ simpleTokenize s =
  lrec 0 (\\ c, \\ t, \ _ih,
      if (c e. white) (((\ r, simpleTokenize r) |` ns (upto s)) @ t) (
        N[maxPrefix nonemptyNonwhite (c : t) - 1 / p]
        (fst p : ((\ r, simpleTokenize r) |` ns (upto s)) @ snd p))) s $ =
(named @ focus
  '(eqtr {srecval : $ _ = _ @ lower ((\ r, simpleTokenize r) |` _) $} @
    applame @ lreceqd eqidd (slameqd @ slameqd @ lameqd _) sreclem)
  (have 'h '(bi2 @ eqlower2 @ finlam finns))
  '(ifeqd biidd (appeq1d h) @ sbneq2d @ conseq2d @ appeq1d h));

pub theorem simpleTokenize0: $ simpleTokenize 0 = 0 $ = (named '(eqtr simpleTokenize_val lrec0));

theorem simpleTokenize_S: $ s = c : t -> simpleTokenize s =
  if (c e. white) (simpleTokenize t) (
    N[maxPrefix nonemptyNonwhite s - 1 / p]
    (fst p : ((\ r, simpleTokenize r) |` ns (upto s)) @ snd p)) $ =
(named '(syl5eq simpleTokenize_val @ eqtrd lreceq3 @ syl5eq lrecS @
  sbeth (imeq2d @ eqeq1d @ appeq2d @ preq2d preq2) @
  appslamed @ appslamed @ applamed @ anwl @
  ifeqd (eleq1d anlr)
    (eqtrd (syl resapp @ sylibr elupto @ mpbiri ltconsid2 (lteqd anr anll)) @
      syl5eq (applame simpleTokenizeeq) (simpleTokenizeeqd anr))
    (sbneq1d @ subeq1d @ maxPrefixeq2d @ eqtr4d (conseqd anlr anr) anll)));

pub theorem simpleTokenizeWS (c s: nat):
  $ c e. white -> simpleTokenize (c : s) = simpleTokenize s $ =
(named '(syl5eq (simpleTokenize_S eqid) ifpos));

pub theorem simpleTokenizeTk (s x r: nat):
  $ maxPrefix nonemptyNonwhite s = suc (x <> r) ->
    simpleTokenize s = x : simpleTokenize r $ =
(named @ focus
  (have 'h '(sylib el_nonemptyNonwhite maxPrefixSi2))
  (have 'h2 '(anwl maxPrefixSi1))
  '(mpd (sylib excons @ anld h) @ eexd @ eexda @
    eqtrd (syl simpleTokenize_S @ eqtr3d h2 @ syl6eq appendS @ appendeq1d anr) @
    eqtrd (syl ifneg @ sylib (elabe @ noteqd eleq1) @
      syl (mpi lmemconsid elall) @ mpbid (alleq2d anr) (anrd @ anwl h)) @
    eqtrd (sbneq1d @ syl6eq sucsub1 @ subeq1d anl) @
    sbned @ conseqd (syl6eq fstpr @ fsteqd anr) @
    eqtrd (appeq2d @ syl6eq sndpr @ sndeqd anr) @ anwl @
    syl6eq (applame simpleTokenizeeq) @ syl resapp @
    sylibr elupto @ mpbid (lteq2d h2) @ sylib ltappendid2 @ anwl @ anld h));

theorem simpleTokenize_infix: $ all {x | x e. nonemptyNonwhite /\ E. a E. b s = a ++ x ++ b} (simpleTokenize s) $ =
(named @ focus
  (def h '(alleqd (abeqd @ aneq2d @ exeqd @ exeqd eqeq1) simpleTokenizeeq))
  '(!! indstr y z ,h ,h (anwr @ cases _ _) tru)
  '(a1d @ mpbiri all0 @ alleq2d @ syl6eq simpleTokenize0 simpleTokenizeeq)
  '(sylbi excons @ eex @ eex @ casesda _ _)
  '(ealde @ eimd (mpbiri ltconsid2 @ lteqd anr anll) @
    syld (syl ssall @ sylib ssab @ iald @ anim2d @
      syl5bi (cbvex @ exeqd @ eqeq2d @ appendeq1d appendeq1) @
      eexd @ iexdde @ eximd @ exp @ eqtr4d an4l @
      eqtr4d (syl6eq appendS @ appendeq1d @ syl6eq appendS @ appendeq1d anlr) @
      conseq2d @ eqtr3d anllr anr) @
    bi2d @ alleq2d @ mpbird (eqeqd (simpleTokenizeeqd anll) (simpleTokenizeeqd anr)) @
    syl simpleTokenizeWS anlr)
  (have 'h1 '(mpbiri (mpbir prefix_S @ ian eqid prefix_0) (prefixeq2d anl)))
  (have 'h2
    '(sylibr el_nonemptyNonwhite @ iand (a1i consne0) @
      sylibr all1 @ sylibr (elabe @ noteqd eleq1) anr))
  '(rsyl (maxPrefix_eqS h1 h2) @
    eex @ exp @ rsyl exanal @ eex @ imp @
    eimd (mpbid (lteq2d maxPrefixSi1) @
      sylib ltappendid2 @ anld @ sylib el_nonemptyNonwhite maxPrefixSi2) @
    syld (syl ssall @ sylib ssab @ iald @ anim2d @
      syl5bi (cbvex @ exeqd @ eqeq2d @ appendeq1d appendeq1) @
      eexd @ iexdde @ eximd @ exp @ eqtr3d (anwll maxPrefixSi1) @
      eqtr4d (appendeq2d anr) @ syl6eq appendass @ appendeq1d @
      syl6eq appendass @ appendeq1d anlr) @
    bi2d @ bitrd (alleq2d simpleTokenizeTk) @ syl5bb allS @ syl bian1 @
    sylibr (elabe @ aneqd eleq1 @ exeqd @ exeqd @ eqeq2d @ appendeq1d appendeq2) @
    iand maxPrefixSi2 @ iexde @ iexde @
    eqtr2d (appendeqd (syl6eq append0 @ appendeq1d anlr) anr) @ anwll maxPrefixSi1));

theorem simpleTokenize_nonemptyNonwhite: $ all nonemptyNonwhite (simpleTokenize s) $ =
(named '(ssall (mpbi ssab1 @ ax_gen anl) simpleTokenize_infix));

theorem simpleTokenize_le: $ c IN simpleTokenize s -> c <= s $ =
(named '(rsyl (elall simpleTokenize_infix) @
  sylbi (elabe @ aneqd eleq1 @ exeqd @ exeqd @ eqeq2d @ appendeq1d @ appendeq2) @
  anwr @ eex @ eex @ mpbiri (letr leappendid2 leappendid1) leeq2));

@_ def getDelimiters (ast: nat): nat =
$ rlrec 0 (\\ a, \\ t, \ ih,
  if (E. l E. r t = ASTNota (NotaDelim (b1 l <> b1 r))) (
    N[t // 2 // 2 // 2 // 2 / p] (
      lower (fst ih u. lmems (simpleTokenize (fst p // 2))) <>
      lower (snd ih u. lmems (simpleTokenize (snd p // 2)))))
    ih) ast $;

pub theorem getDelimiters0: $ getDelimiters 0 = 0 <> 0 $ = (named '(eqtr4 rlrec0 pr0));

theorem getDelimitersS (h1: $ t // 2 // 2 // 2 // 2 = p $)
  (h2: $ fst p // 2 = x $) (h3: $ snd p // 2 = y $):
  $ getDelimiters ast = a <> b -> getDelimiters (ast |> t) =
    if (E. l E. r t = ASTNota (NotaDelim (b1 l <> b1 r))) (
      lower (a u. lmems (simpleTokenize x)) <>
      lower (b u. lmems (simpleTokenize y)))
    (getDelimiters ast) $ =
(named @ focus
  '(syl5eq {rlrecS : $ _ = _ @ (_ <> _ <> getDelimiters _) $} @
    appslamed @ appslamed @ applamed @ ifeqd (exeqd @ exeqd @ eqeq1d anlr) _ anr)
  (def (f x y z) '(lowereqd @ uneqd (nseqd @ syl6eq ,x @ ,y @ eqtrd anlr an4l) @
    nseqd @ lmemseqd @ simpleTokenizeeqd @ syl6eq ,z @ diveq1d @ ,y anr))
  '(eqtrd (sbneq1d @ syl6eq h1 @ diveq1d @ diveq1d @ diveq1d @ diveq1d anlr) @
    sbned @ preqd ,(f 'fstpr 'fsteqd 'h2) ,(f 'sndpr 'sndeqd 'h3)));

pub theorem getDelimitersDelim (ast a b l r: nat):
  $ getDelimiters ast = a <> b ->
    getDelimiters (ast |> ASTNota (NotaDelim (b1 l <> b1 r))) =
      lower (a u. lmems (simpleTokenize l)) <>
      lower (b u. lmems (simpleTokenize r)) $ =
(named @ let ([(f x th) '(eqtr (diveq1 ,th) ,x)])
  '(syl6eq (ifpos @ iexde (iexde @
      eqcomd @ ASTNotaeqd @ NotaDelimeqd @ preqd (b1eqd anlr) (b1eqd anr)) eqid) @
    getDelimitersS
      ,(foldr '(b0div2 b0div2 b1div2) 'b1div2 f)
      ,(f 'b1div2 'fstpr) ,(f 'b1div2 'sndpr)));

pub theorem getDelimitersOther {l r: nat} (ast t: nat):
  $ ~(E. l E. r t = ASTNota (NotaDelim (b1 l <> b1 r))) ->
    getDelimiters (ast |> t) = getDelimiters ast $ =
'(syl5eq (getDelimitersS eqid eqid eqid @ eqcom fstsnd) ifneg);

theorem getDelimiters_nonemptyNonwhite {l r: nat} (ast t: nat):
  $ x e. fst (getDelimiters ast) \/ x e. snd (getDelimiters ast) ->
    x e. nonemptyNonwhite $ =
(named @ mk-ind '(rlistind) '(imeq1d @ oreqd
    (elneq2d @ fsteqd getDelimiterseq)
    (elneq2d @ sndeqd getDelimiterseq))
  '(sylbi (oreq
        (elneq2 @ eqtr (fsteq getDelimiters0) fstpr)
        (elneq2 @ eqtr (sndeq getDelimiters0) sndpr))
      (sylbi oridm @ absurd nel0))
  (def h '(bitr (ellower @ unfin finns finns) elun))
  (def h2 '(elall simpleTokenize_nonemptyNonwhite))
  '(casesd
    (eexd @ eexd @ syl5ibrcom
      (imeq1d @
        rsyl (syl6eq (getDelimitersDelim @ eqcom fstsnd) @ getDelimiterseqd snoceq2) @
        oreqd (elneq2d @ syl6eq fstpr fsteq) (elneq2d @ syl6eq sndpr sndeq)) @
      syl5bi (oreq ,h ,h) @ syl5bi or4 @ eord id @ a1i @ eor ,h2 ,h2)
    (com12 @ bi2d @ imeq1d @ rsyl getDelimitersOther @
      oreqd (elneq2d fsteq) (elneq2d sndeq))));

@_ def delimitersOk (A: set) (.x .y: nat): wff =
$ A. x (x e. A -> len x = 1) $;

@_ local def delimiterFree (ast: nat): set =
$ {s | ~(E. l E. x E. r (x e. getDelimiters ast /\ s = l ++ x ++ r))} $;

@_ def tokenizeFmla (ast f: nat): nat =
$ lrec 0 (\\ x, \\ xs, \ ih,
    if (x e. white) ih (
      if (x : 0 e. fst (getDelimiters ast) \/
          A. y A. r (xs = y : r -> y e. white \/ y : 0 e. snd (getDelimiters ast)))
        ((x : 0) : ih)
        ((x : fst (ih - 1)) : snd (ih - 1))))
  f $;

pub theorem tokenizeFmla0 (ast: nat): $ tokenizeFmla ast 0 = 0 $ = (named 'lrec0);

theorem tokenizeFmlaS: $ tokenizeFmla ast xs = ih ->
  tokenizeFmla ast (x : xs) = if (x e. white) ih (
    if (x : 0 e. fst (getDelimiters ast) \/
        A. y A. r (xs = y : r -> y e. white \/ y : 0 e. snd (getDelimiters ast)))
      ((x : 0) : ih)
      ((x : fst (ih - 1)) : snd (ih - 1))) $ =
(named @ focus
  '(syl5eq lrecS @ syl6eq _ @ appeq2d @ preq2d preq2)
  '(appslame @ appslamed @ applamed @ ifeqd (eleq1d anll) anr @
    ifeqd (oreqd (eleq1d @ conseq1d anll) (aleqd @ aleqd @ imeq1d @ eqeq1d anlr))
      (conseqd (conseq1d anll) anr)
      (conseqd (conseqd anll @ fsteqd @ subeq1d anr) (sndeqd @ subeq1d anr))));

theorem tokenizeFmlaS_n0: $ ~x e. white -> tokenizeFmla ast (x : xs) != 0 $ =
(named @ focus
  (def (f x) '(mpbiri consne0 @ neeq1d ,x))
  '(mpbiri (cases ,(f 'ifpos) ,(f 'ifneg)) @ neeq1d @ syl5eq (tokenizeFmlaS eqid) ifneg));

pub theorem tokenizeFmlaWhite: $ x e. white -> tokenizeFmla ast (x : xs) = tokenizeFmla ast xs $ =
(named '(syl5eq (tokenizeFmlaS eqid) ifpos));

pub theorem tokenizeFmla1: $ ~x e. white -> tokenizeFmla ast (x : 0) = (x : 0) : 0 $ =
(named '(syl5eq (tokenizeFmlaS tokenizeFmla0) @
  syl6eq (ifpos @ orr @ ax_gen @ ax_gen @ absurd @ necom consne0) ifneg));

theorem tokenizeFmlaSS: $ tokenizeFmla ast (y : xs) = ih -> ~x e. white ->
  tokenizeFmla ast (x : y : xs) =
  if (x : 0 e. fst (getDelimiters ast) \/ y e. white \/ y : 0 e. snd (getDelimiters ast))
    ((x : 0) : ih)
    ((x : fst (ih - 1)) : snd (ih - 1)) $ =
(named @ focus
  '(exp @ eqtrd (anwl tokenizeFmlaS) @ syl6eqr _ @ anwr ifneg)
  '(ifeq1 @ bitr4 orass @ oreq2 @ bitr3 _ @ aleqe @ oreqd eleq1 (eleq1d conseq1))
  '(aleqi @ bitr3 (aleqe biidd) @ aleqi @ bitr3 impexp @ imeq1i @ bitr ancomb @ bitr3 consinj eqcomb));

theorem tokenizeFmla_nonemptyNonwhite_lem: $ all nonemptyNonwhite l /\ ~x e. white ->
   all nonemptyNonwhite ((x : 0) : 0) /\ all nonemptyNonwhite ((x : fst (l - 1)) : snd (l - 1)) $ =
(named @ focus
  (def h '(elabe @ noteqd eleq1))
  (def (f x y z) '(sylibr allS @ iand (sylibr el_nonemptyNonwhite @
    iand (a1i consne0) @ sylibr allS @ iand (sylibr ,h ,x) ,y) ,z))
  '(mpd ,(f 'anr '(a1i all0) '(a1i all0)) @ exp @ iand anr @
    casesd (exp @ mpbird (alleq2d @ conseqd
      (conseq2d @ syl6eq fst0 @ fsteqd @ syl6eq sub01 @ subeq1d anr) @
      syl6eq snd0 @ sndeqd @ syl6eq sub01 @ subeq1d anr) anlr) @
    syl5bi excons @ eexd @ eexda _)
  (have 'h2 '(sylib allS @ mpbid (alleq2d anr) an3l))
    ,(f 'anllr
      '(mpbird (alleq2d @ syl6eq fstpr @ fsteqd @ syl6eq sucsub1 @ subeq1d anr) @ anrd @
        sylib el_nonemptyNonwhite @ anld h2)
      '(mpbird (alleq2d @ syl6eq sndpr @ sndeqd @ syl6eq sucsub1 @ subeq1d anr) @ anrd h2)));

theorem tokenizeFmla_nonemptyNonwhite: $ all nonemptyNonwhite (tokenizeFmla ast xs) $ =
(named @ focus
  (mk-ind '(listind) '(alleq2d tokenizeFmlaeq2) '(mpbir (alleq2 tokenizeFmla0) all0) _)
  (def h '(mpbir (elabe neeq1) consne0))
  (def h2 '(bitr el_nonemptyNonwhite @
    bitr (bian1 consne0) @ bitr all1 @ elabe @ noteqd eleq1))
  '(casesd (com12 @ bi2d @ alleq2d @ syl5eq (tokenizeFmlaS eqid) ifpos) @ exp _)
  (have 'h '(tokenizeFmla_nonemptyNonwhite_lem))
  '(casesd
    (exp @ mpbird (alleq2d @ eqtrd (tokenizeFmlaeq2d @ conseq2d anr) (syl tokenizeFmla1 anlr)) @
      anwl @ anld h)
    (syl5bi excons @ eexd @ eexda @
      mpbird (alleq2d @ eqtrd (tokenizeFmlaeq2d @ conseq2d anr) (rsyl anlr @ tokenizeFmlaSS eqid)) @
      casesda
        (mpbird (alleq2d @ anwr ifpos) @ anwl @ sylibr allS @ iand (sylib all1 @ anwl @ anld h) @
          mpbid (alleq2d @ tokenizeFmlaeq2d anr) anll)
        (mpbird (alleq2d @ anwr ifneg) @ syl (anrd tokenizeFmla_nonemptyNonwhite_lem) @
          iand (mpbid (alleq2d @ tokenizeFmlaeq2d anlr) an3l) anllr))));

theorem tokenizeFmla_hd:
  $ tokenizeFmla ast (x : xs) = l : r2 -> (~x e. white <-> E. r l = x : r) $ =
(named @ focus
  (have 'h '(sylib el_nonemptyNonwhite @ syl (elall tokenizeFmla_nonemptyNonwhite) @
    mpbiri lmemconsid @ lmemeq2))
  '(ibid _ _)
  (focus
    '(exp @ mpd (sylib excons @ anld @ anwl h) @ eexd @ eximd @ exp @ eqtrd anr @ conseq1d @
      syl _ @ eqtr3d (syl5eq (tokenizeFmlaS eqid) (rsyl anlr ifneg)) @
        eqtrd anll @ conseq1d anr)
    (def (h x) '(anld @ sylib consinj @ anld @ sylib consinj @ eqtr3d anl @ anwr ,x))
    '(casesda ,(h 'ifpos) ,(h 'ifneg)))
  (focus
    '(eexda @ sylib (elabe @ noteqd eleq1) @ syl (mpi lmemconsid elall) @
      mpbid (alleq2d anr) @ anrd @ anwl h)));

theorem tokenizeFmla_hd2:
  $ ~x e. white -> E. l E. r2 tokenizeFmla ast (x : xs) = (x : l) : r2 $ =
(named '(mpd (sylib excons tokenizeFmlaS_n0) @ syl6 excom @ eexd @ eximd @ exp @
  mpd (mpbid (anwr tokenizeFmla_hd) anl) @ eximd @ exp @ eqtrd anlr @ conseq1d anr));

pub theorem tokenizeFmlaSLDelim (ast x xs: nat):
  $ x : 0 e. fst (getDelimiters ast) ->
    tokenizeFmla ast (x : xs) = (x : 0) : tokenizeFmla ast xs $ =
(named '(syl5eq (tokenizeFmlaS eqid) @
  eqtrd (syl ifneg @ rsyl orl @ rsyl getDelimiters_nonemptyNonwhite @
    sylbi el_nonemptyNonwhite @ anwr @ sylib (elabe @ noteqd eleq1) @ mpi lmemconsid elall) @
  syl ifpos orl));

theorem tokenizeFmlaS_RDelim_lem
  (h1: $ G -> ~x e. white $) (h2: $ G -> y e. white \/ y : 0 e. snd (getDelimiters ast) $):
  $ G -> tokenizeFmla ast (x : y : xs) = (x : 0) : tokenizeFmla ast (y : xs) $ =
(named '(syl5eq (tokenizeFmlaS eqid) @ eqtrd (syl ifneg h1) @ syl ifpos @ orrd @
  iald @ iald @ syl5bi consinj @ exp @
  mpbid (rsyl anrl @ oreqd eleq1 (eleq1d conseq1)) @ anwl h2));

pub theorem tokenizeFmlaSRDelim (ast x y xs: nat):
  $ ~x e. white /\ y : 0 e. snd (getDelimiters ast) ->
    tokenizeFmla ast (x : y : xs) = (x : 0) : tokenizeFmla ast (y : xs) $ =
'(tokenizeFmlaS_RDelim_lem anl @ orrd anr);

theorem tokenizeFmlaS_Else
  (h1: $ G -> ~x e. white $)
  (h2: $ G -> tokenizeFmla ast (y : xs) = (y : r) : r2 $)
  (h3: $ G -> ~x : 0 e. fst (getDelimiters ast) $)
  (h4: $ G -> ~y : 0 e. snd (getDelimiters ast) $):
  $ G -> tokenizeFmla ast (x : y : xs) = (x : y : r) : r2 $ =
(named '(eqtrd (sylc tokenizeFmlaSS h2 h1) @
  syl6eq (conseq (conseq2 @ eqtr (fsteq sucsub1) fstpr) (eqtr (sndeq sucsub1) sndpr)) @
  syl ifneg @ sylibr notor @ iand (sylibr notor @ iand h3 @
    mpbiri (iexe (eqeq2d conseq2) eqid) (syl tokenizeFmla_hd h2)) h4));

theorem tokenizeFmlaWS (ast s c t: nat): $ c e. white ->
  tokenizeFmla ast (s ++ c : t) = tokenizeFmla ast s ++ tokenizeFmla ast t $ =
(named @ focus
  (mk-ind '(listindd) '(eqeqd (tokenizeFmlaeq2d appendeq1) (appendeq1d tokenizeFmlaeq2))
    '(sylibr (eqeq (tokenizeFmlaeq2 append0)
      (eqtr (appendeq1 tokenizeFmla0) append0)) tokenizeFmlaWhite) _)
  '(syl5eq (tokenizeFmlaeq2 appendS) @
    casesda (eqtr4d (anwr tokenizeFmlaWhite) @
      eqtr4d (anwr @ appendeq1d tokenizeFmlaWhite) anlr) @
    casesda (eqtr4d (anwr tokenizeFmlaSLDelim) @
      eqtr4d (anwr @ appendeq1d tokenizeFmlaSLDelim) @ syl6eqr appendS @ conseq2d anllr) @
    casesda (eqtr4d (tokenizeFmlaeq2d @ conseq2d @ syl6eq append0 @ appendeq1d anr) @
      eqtr4d (appendeq1d @ eqtrd (tokenizeFmlaeq2d @ conseq2d anr) @ syl tokenizeFmla1 anllr) @
      syl6eqr append1 @ eqtrd (tokenizeFmlaS_RDelim_lem anllr @ orld an4l) @
      conseq2d @ syl tokenizeFmlaWhite an4l) _)
  '(imp @ syl5bi excons @ eexd @ eexda @
    eqtr4d (tokenizeFmlaeq2d @ conseq2d @ syl6eq appendS @ appendeq1d anr) @
    eqtr4d (appendeq1d @ tokenizeFmlaeq2d @ conseq2d anr) @
    casesda (eqtr4d (tokenizeFmlaS_RDelim_lem an3lr anr) @
      eqtr4d (appendeq1d @ tokenizeFmlaS_RDelim_lem an3lr anr) @
      syl6eqr appendS @ conseq2d @
      eqtr3d (tokenizeFmlaeq2d @ syl6eq appendS @ appendeq1d anlr) @
      eqtrd an4lr @ appendeq1d @ tokenizeFmlaeq2d anlr) @
    mpd (syl tokenizeFmla_hd2 an3lr) @ eexd @ eexda @
    mpd (syl tokenizeFmla_hd2 @ rsyl anlr @ con3 orl) @ eexd @ eexda @
    eqtr4d (tokenizeFmlaS_Else an5lr _ an4lr @ rsyl anllr @ con3 orr) @
    syl6eq appendS @ appendeq1d @ tokenizeFmlaS_Else an5lr anr an4lr @ rsyl anllr @ con3 orr)
  '(eqtr3d (tokenizeFmlaeq2d @ syl6eq appendS @ appendeq1d an3lr) @
    eqtrd an6lr @ syl6eq appendS @ appendeq1d @
    eqtrd (tokenizeFmlaeq2d an3lr) anr));

-- pub theorem tokenizeFmlaLDelim (ast x s t: nat):
--   $ x e. fst (getDelimiters ast) ->
--     tokenizeFmla ast (s ++ x ++ t) =
--     tokenizeFmla ast (s ++ x) ++ tokenizeFmla ast t $;
-- pub theorem tokenizeFmlaRDelim (ast x s t: nat):
--   $ x e. snd (getDelimiters ast) ->
--     tokenizeFmla ast (s ++ x ++ t) =
--     tokenizeFmla ast s ++ tokenizeFmla ast (x ++ t) $;

-- pub theorem tokenizeFmlaJoin (ast x s t: nat):
--   $ s e. nonemptyNonwhite -> ljoin (tokenizeFmla ast s) = s $;

-- pub theorem tokenizeFmlaMinimal {l r: nat} (ast s a x y b: nat):
--   $ tokenizeFmla ast s = a ++ x : y : b ->
--     E. l E. r (r e. fst (getDelimiters ast) /\ x = l ++ r) \/
--     E. l E. r (l e. snd (getDelimiters ast) /\ y = l ++ r) $;

@_ def getPfx (ast: nat): nat =
$ lower (S\ x, S\ c, {p | E. fmla (
    ASTNota (NotaPfx (x <> b1 fmla <> p)) IN ast /\
    simpleTokenize fmla = c : 0)}) $;
pub theorem getPfxEl {fmla: nat} (ast x c p: nat):
  $ x <> c <> p e. getPfx ast <-> E. fmla (
    ASTNota (NotaPfx (x <> b1 fmla <> p)) IN ast /\
    simpleTokenize fmla = c : 0) $ =
(named @ focus
  '(bitr (ellower @ trud _) @ elsabe @ elsabed @ elabed @
    exeqd @ aneqd
      (lmemeq1d @ ASTNotaeqd @ NotaPfxeqd @ preqd anll @ preq2d anr)
      (eqeq2d @ conseq1d anlr))
  (have 'h $ ASTNota (NotaPfx _) IN ast /\ _ -> _ $
    '(rsyl (syl lmemlt anl) @ lelttr @ leb1tr @ leb1tr @ leb0tr @ leb1tr b1leid))
  '(sabfin (eexsabd @ eelabd @ a1i @ eex @ sylibr elupto @ rsyl h @ lelttr leprid1) (a1i finns) @
    sabfin (eelabd @ a1i @ sylibr ellamima @ eximi @ iand
      (sylibr elupto @ rsyl h @ lelttr @ lepr2tr @ lepr1tr b1leid)
      (eqcomd @ syl6eq fstpr @ fsteqd @ syl6eq sucsub1 @ subeq1d anr)) (a1i @ finlamima finns) @
    a1i @ finss (mpbi ssab1 @ ax_gen @ eex @ sylibr elupto @ rsyl h @ lelttr @ lepr2tr leprid2) @
    finns));

@_ def getInfix (ast r: nat): nat =
$ lower (S\ x, S\ c, {p | E. fmla (
    ASTNota (NotaInfix r (x <> b1 fmla <> p)) IN ast /\
    simpleTokenize fmla = c : 0)}) $;
pub theorem getInfixEl {fmla: nat} (ast r x c p: nat):
  $ x <> c <> p e. getInfix ast r <-> E. fmla
    (ASTNota (NotaInfix r (x <> b1 fmla <> p)) IN ast /\
     simpleTokenize fmla = c : 0) $ =
(named @ focus
  '(bitr (ellower @ trud _) @ elsabe @ elsabed @ elabed @
    exeqd @ aneqd
      (lmemeq1d @ ASTNotaeqd @ NotaInfixeq2d @ preqd anll @ preq2d anr)
      (eqeq2d @ conseq1d anlr))
  (have 'h $ ASTNota (NotaInfix _) IN ast /\ _ -> _ $
    '(rsyl (syl lmemlt anl) @ lelttr @ leb1tr @ leb1tr @ leb0tr @ leb1tr b0leid))
  '(sabfin (eexsabd @ eelabd @ a1i @ eex @ sylibr elupto @ rsyl h @ lelttr @ lepr2tr leprid1) (a1i finns) @
    sabfin (eelabd @ a1i @ sylibr ellamima @ eximi @ iand
      (sylibr elupto @ rsyl h @ lelttr @ lepr2tr @ lepr2tr @ lepr1tr b1leid)
      (eqcomd @ syl6eq fstpr @ fsteqd @ syl6eq sucsub1 @ subeq1d anr)) (a1i @ finlamima finns) @
    a1i @ finss (mpbi ssab1 @ ax_gen @ eex @ sylibr elupto @ rsyl h @ lelttr @ lepr2tr @ lepr2tr leprid2) @
    finns));

@_ def getNota (ast: nat): nat = $ lower {z | ASTNota (NotaGen z) IN ast} $;
pub theorem getNotaEl (ast x y: nat):
  $ x <> y e. getNota ast <-> ASTNota (NotaGen (x <> y)) IN ast $ =
(named @ focus
  '(bitr (ellower @ finss _ finns) @ elabe @ lmemeq1d @ ASTNotaeqd NotaGeneq)
  '(mpbi ssab1 @ ax_gen @ sylibr elupto @ rsyl lmemlt @ lelttr @
    leb1tr @ leb1tr @ leb1tr b1leid));

@_ def getCoe (ast: nat): nat = $ lower {z | ASTNota (NotaCoe z) IN ast} $;
pub theorem getCoeEl (ast x y: nat):
  $ x <> y e. getCoe ast <-> ASTNota (NotaCoe (x <> y)) IN ast $ =
(named @ focus
  '(bitr (ellower @ finss _ finns) @ elabe @ lmemeq1d @ ASTNotaeqd NotaCoeeq)
  '(mpbi ssab1 @ ax_gen @ sylibr elupto @ rsyl lmemlt @ lelttr @
    leb1tr @ leb1tr @ leb1tr b0leid));

@_ def precle (m n: nat): wff = $ n = 0 \/ (m != 0 /\ m - 1 <= n - 1) $;
infixl precle: $<=p$ prec 50;
pub theorem precle02 (n: nat): $ n <=p 0 $ = '(orl eqid);
pub theorem precle01 (m: nat): $ ~ 0 <=p suc m $ =
'(mpbir notor @ ian peano1 @ con2 anl eqid);
pub theorem precleS (m n: nat): $ suc m <=p suc n <-> m <= n $ =
'(bitr (bior1 peano1) @ bitr (bian1 peano1) @ leeq sucsub1 sucsub1);

@_ def precSuc (n: nat): nat = $ if (n = 0) 0 (suc n) $;
pub theorem precSuc0: $ precSuc 0 = 0 $ = '(ifpos eqid);
pub theorem precSucS (n: nat): $ precSuc (suc n) = suc (suc n) $ = '(ifneg peano1);

@_ def litsPrec (lits q: nat): nat =
$ if (lits = 0) q (case (\\ c, \ p, precSuc p) (\ v, 0) @ (fst (lits - 1))) $;
pub theorem litsPrec0 (q: nat): $ litsPrec 0 q = q $ = (named '(ifpos eqid));
theorem litsPrecS:
  $ litsPrec (z : lits) q = case (\\ c, \ p, precSuc p) (\ v, 0) @ z $ =
(named '(eqtr (ifneg peano1) @ appeq2 @ eqtr (fsteq sucsub1) fstpr));
pub theorem litsPrecC (c p lits q: nat):
  $ litsPrec (b0 (c <> p) : lits) q = precSuc p $ =
(named '(eqtr litsPrecS @ eqtr casel @ appslame @ applamed @ precSuceqd anr));
pub theorem litsPrecV (v lits q: nat):
  $ litsPrec (b1 v : lits) q = 0 $ =
(named '(eqtr litsPrecS @ eqtr caser @ applame eqidd));

-- This is a more precise version of SExpr that allows reconstructing an
-- exact token string from a parse proof
@_ def PTParens (x: nat): nat = $ b0 (b0 (b0 x)) $;
@_ def PTVar (v: nat): nat = $ b0 (b0 (b1 v)) $;
@_ def PTFunc (f x: nat): nat = $ b0 (b1 (f <> x)) $;
@_ def PTPfx (f c x: nat): nat = $ b1 (b0 (b0 (f <> c <> x))) $;
@_ def PTNota (f x: nat): nat = $ b1 (b0 (b1 (f <> x))) $;
@_ def PTInfix (r f c x y: nat): nat =
  $ b1 (b1 (b0 (r <> f <> c <> (x : y : 0)))) $;
@_ def PTCoe (f x: nat): nat = $ b1 (b1 (b1 (f <> x))) $;

@_ def ptToStr (pt: nat): nat;
pub theorem ptToStrParens {s: nat} (e: nat):
  $ ptToStr (PTParens e) = s1 _lparen : ptToStr e ++ s1 _rparen : 0 $;
pub theorem ptToStrVar (v: nat): $ ptToStr (PTVar v) = v : 0 $;
pub theorem ptToStrFunc {s: nat} (f x: nat): $ ptToStr (PTFunc f x) =
  f : ljoin (map (\ s, ptToStr s) x) $;
pub theorem ptToStrPfx {s: nat} (f c x: nat): $ ptToStr (PTPfx f c x) =
  c : ljoin (map (\ s, ptToStr s) x) $;
pub theorem ptToStrInfix (r f c x y: nat):
  $ ptToStr (PTInfix r f c x y) = ptToStr x ++ c : ptToStr y $;
pub theorem ptToStrNota {y: nat} (f x: nat):
  $ ptToStr (PTNota f x) =
    ljoin (map (case (\ y, y : 0) (\ y, ptToStr y)) x) $;
pub theorem ptToStrCoe {y: nat} (f x: nat):
  $ ptToStr (PTCoe f x) = ptToStr x $;

@_ def ptCheck (eac p pt e: nat): wff;
@_ def ptCheckNotaLs (eac bis pts xs es p: nat): wff;

pub theorem ptCheckParens (eac p pt e: nat):
  $ ptCheck eac p (PTParens pt) e <->
    ptCheck eac (suc 0) pt e $;
pub theorem ptCheckVar {n: nat} (eac p v e: nat): $ ptCheck eac p (PTVar v) e <->
  E. n (lookupVar (pi22 eac) v = suc n /\ e = SVar n) $;
pub theorem ptCheckFunc (env ast ctx p f xs e: nat) {f2 args r v e2 x y: nat}:
  $ ptCheck (env <> ast <> ctx) p (PTFunc f xs) e <->
    suc (2 ^ 10) <=p p /\ E. f2 E. args E. r E. v E. e2
    (getTerm env f args r v /\ len xs = len args /\
      all2 x y (ptCheck (env <> ast <> ctx) 0 x y) xs e2 /\
      e = SApp f2 e2) $;
pub theorem ptCheckPfx (eac p f c xs e: nat) {l z f2 q es2 e2 x y: nat} :
  $ ptCheck eac p (PTPfx f c xs) e <->
    E. l E. z E. q E. es2 E. e2 (xs = l |> z /\
      f <> c <> q e. getPfx (pi21 eac) /\ q <=p p /\
      all2 x y (ptCheck eac 0 x y) l es2 /\ ptCheck eac q z e2 /\
      e = SApp f (es2 |> e2)) $;
pub theorem ptCheckInfix {q e1 e2: nat} (eac p r f c x y e: nat):
  $ ptCheck eac p (PTInfix r f c x y) e <->
    E. q E. e1 E. e2 (
      f <> c <> q e. getInfix (pi21 eac) r /\ q <=p p /\
      ptCheck eac (if (r = 0) q (precSuc q)) x e1 /\
      ptCheck eac (if (r = 0) (precSuc q) q) y e2 /\
      e = SApp f (e1 : e2 : 0)) $;
pub theorem ptCheckNota {bis ty c q lits es: nat} (eac p f xs e: nat):
  $ ptCheck eac p (PTNota f xs) e <->
    E. bis E. ty E. c E. q E. lits E. es (
      f <> bis <> ty <> (b0 (c <> q) : lits) e. getNota (pi21 eac) /\
      len xs = len es /\ ptCheckNotaLs eac bis lits xs es q /\
      e = SApp f es) $;
pub theorem ptCheckCoe {y e2: nat} (eac p f x e: nat):
  $ ptCheck eac p (PTCoe f x) e <->
    E. y E. e2 (
      f <> y e. getCoe (pi21 eac) /\ ptCheck eac p x e2 /\
      e = SApp f e2) $;

pub theorem ptCheckNotaLs0 (eac bis xs es q: nat):
  $ ptCheckNotaLs eac bis 0 xs es q $;
pub theorem ptCheckNotaLsC (eac bis c p lits xs es q: nat):
  $ ptCheckNotaLs eac bis (b1 (c <> p) : lits) xs es q <->
    ptCheckNotaLs eac bis lits xs es q $;
pub theorem ptCheckNotaLsV {n x e: nat} (eac bis v lits xs es q: nat):
  $ ptCheckNotaLs eac bis (b0 v : lits) xs es q <->
    E. n E. x E. e (lookupVar bis v = suc n /\
      nth n xs = suc x /\ nth n es = suc e /\
      ptCheck eac (litsPrec lits q) x e /\
      ptCheckNotaLs eac bis lits xs es q) $;

@_ def parseExpr (eac args f s .e .pt: nat): set =
$ {e | E. pt (ptToStr pt = f /\
  ptCheck eac 0 pt e /\ Expr (fst eac) args e s)} $;

@_ def parseExprProv (eac args f .e .pt: nat): set =
$ {e | E. pt (ptToStr pt = f /\
  ptCheck eac 0 pt e /\ ExprProv (fst eac) args e)} $;

-----------------
-- Elaboration --
-----------------

-- Here we have to convert a parsed AST into an Env, and also
-- parse the math strings.

@_ def splitDummies (bis: nat): nat;
pub theorem splitDummies0: $ splitDummies 0 = 0 $;
pub theorem splitDummiesL (bis bis1 bis2 c x t: nat): $
  splitDummies bis = bis1 <> bis2 ->
  splitDummies (bis |> (c <> b0 x <> t)) =
    (bis1 |> (c <> x <> t)) <> bis2 $;
pub theorem splitDummiesR (bis bis1 bis2 c x t: nat): $
  splitDummies bis = bis1 <> bis2 ->
  splitDummies (bis |> (c <> b1 x <> t)) = bis1 <> (bis2 |> (x <> t)) $;

@_ def checkDummies (ds bis: nat): wff;
pub theorem checkDummies0 (bis: nat): $ checkDummies 0 bis <-> bis = 0 $;
pub theorem checkDummiesS {t2 bis2: nat} (bis x t ds: nat):
  $ checkDummies ((x <> t) : ds) bis <-> E. t2 E. bis2 (
      t = b0 (t2 <> 0) /\ checkDummies ds bis2 /\
      bis = (0 <> x <> t) : bis2) $;

@_ def lookupVars (ctx .s .t: nat): set = $ opab s t (lookupVar ctx s = suc t) $;

@_ def elabType (ast ctx s out .t .vs .vs2: nat): wff =
$ E. t E. vs E. vs2 (s = b0 (t <> vs) /\ out = t <> vs2 /\
    vs2 == lookupVars ctx '' vs) $;

@_ def elabTermBinder (ast ctx bi s: nat): wff;
pub theorem elabTermBinderFmla (ast ctx c x f s: nat):
  $ ~ elabTermBinder ast ctx (c <> x <> b1 f) s $;
pub theorem elabTermBinderBound {t2: nat} (ast ctx bi x t s: nat):
  $ elabTermBinder ast ctx (0 <> x <> b0 t) s <->
    E. t2 (elabType ast ctx t (t2 <> 0) /\ s = PBound t2) $;
pub theorem elabTermBinderReg {t2 vs2: nat} (ast ctx bi x t s: nat):
  $ elabTermBinder ast ctx (1 <> x <> b0 t) s <->
    E. t2 E. vs2 (elabType ast ctx t (t2 <> vs2) /\ s = PReg t2 vs2) $;

@_ def elabTermBinders (ast ctx ctx2: nat): wff;
pub theorem elabTermBinders0 (ast ctx2: nat):
  $ elabTermBinders ast 0 ctx2 <-> ctx2 = 0 $;
pub theorem elabTermBindersS {ctx2 bi2: nat} (ast ctx bi ctx3: nat):
  $ elabTermBinders ast (ctx |> bi) ctx3 <->
    E. ctx2 (elabTermBinders ast ctx ctx2 /\
      elabTermBinder ast ctx bi bi2 /\ ctx3 = ctx2 |> bi2) $;

@_ def elabFmla (env ast ctx args f e s .f2: nat): wff =
$ E. f2 (f = b1 f2 /\ parseExpr (env <> ast <> ctx) args f2 s == sn e) $;

@_ def elabFmlaProv (env ast ctx args f e .f2: nat): wff =
$ E. f2 (f = b1 f2 /\ parseExprProv (env <> ast <> ctx) args f2 == sn e) $;

@_ def elabHyps (env ast ctx args hyps hyps2 .hyp .hyp2 .x .f: nat): wff =
$ all2 hyp hyp2 (E. x E. f (hyp = 1 <> b0 x <> f /\
    elabFmlaProv env ast ctx args f hyp2)) hyps hyps2 $;

@_ def elabDefO (env ast ctx s ds o o2: nat): wff;
pub theorem elabDefO0 (env ast ctx s ds o2: nat):
  $ elabDefO env ast ctx s ds 0 o2 <-> ds = 0 /\ o2 = 0 $;
pub theorem elabDefOS {args2 e: nat} (env ast ctx s ds f o2: nat):
  $ elabDefO env ast ctx s ds (suc f) o2 <-> E. args2 E. e (
      elabTermBinders ast (ctx ++ ds) args2 /\
      elabFmla env ast (ctx ++ ds) args2 f e s /\
      o2 = suc (ds <> e)) $;

@_ def Elaborate (ast: nat): set;
pub theorem Elaborate0: $ Elaborate 0 == sn 0 $;
pub theorem ElaborateSort {e: nat} (ast sd x: nat):
  $ Elaborate (ast |> ASTSort (sd <> x)) ==
    (\ e, e |> DSort x sd) '' Elaborate ast $;
pub theorem ElaborateTerm {e ctx args ret2: nat} (ast x bis ret e2: nat):
  $ e2 e. Elaborate (ast |> ASTTerm (x <> bis <> ret)) <->
    E. e E. ctx E. args E. ret2 (e e. Elaborate ast /\
      splitDummies bis = ctx <> 0 /\
      elabTermBinders ast ctx args /\
      elabType ast ctx ret ret2 /\
      e2 = e |> DTerm x args ret2) $;
pub theorem ElaborateAxiom
  {e ctx hyps hyps2 args ret2: nat} (ast x bis ret e2: nat):
  $ e2 e. Elaborate (ast |> ASTAxiom (x <> bis <> ret)) <->
    E. e E. ctx E. hyps E. hyps2 E. args E. ret2 (e e. Elaborate ast /\
      splitDummies bis = (ctx ++ hyps) <> 0 /\
      elabTermBinders ast ctx args /\
      elabHyps e ast ctx args hyps hyps2 /\
      elabFmlaProv e ast ctx args ret ret2 /\
      e2 = e |> DAxiom args hyps2 ret2) $;
pub theorem ElaborateDef {e ctx ds ret2 ctx2 args o2: nat} (ast x bis ret o e2: nat):
  $ e2 e. Elaborate (ast |> ASTDef (x <> bis <> ret <> o)) <->
    E. e E. ctx E. ds E. ret2 E. ctx2 E. args E. o2 (
      e e. Elaborate ast /\
      splitDummies bis = ctx <> ds /\
      elabType ast ctx ret ret2 /\
      checkDummies ds ctx2 /\
      elabTermBinders ast ctx args /\
      elabDefO e ast ctx (fst ret2) ctx2 o o2 /\
      e2 = e |> DDef x args ret2 o2) $;
pub theorem ElaborateThm
  {e ctx hyps hyps2 args ret2: nat} (ast x bis ret e2: nat):
  $ e2 e. Elaborate (ast |> ASTThm (x <> bis <> ret)) <->
    E. e E. ctx E. hyps E. hyps2 E. args E. ret2 (e e. Elaborate ast /\
      splitDummies bis = (ctx ++ hyps) <> 0 /\
      elabTermBinders ast ctx args /\
      elabHyps e ast ctx args hyps hyps2 /\
      elabFmlaProv e ast ctx args ret ret2 /\
      e2 = e |> DThm args hyps2 ret2) $;
pub theorem ElaborateNota (ast n: nat):
  $ Elaborate (ast |> ASTNota n) == Elaborate ast $;
pub theorem ElaborateIO (ast out n: nat):
  $ Elaborate (ast |> ASTIO out n) == Elaborate ast $;

@_ def Valid (s .ast .e: nat): wff =
$ E. ast E. e (parse s ast /\ e e. Elaborate ast /\ ValidEnv e) $;
