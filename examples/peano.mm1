delimiter $ ( [ { ~ $
          $ } ] ) , $;
strict provable sort wff;
term im (ph ps: wff): wff; infixr im: $->$ prec 25;
term not (ph: wff): wff; prefix not: $~$ prec 41;

axiom ax_1 (ph ps: wff): $ ph -> ps -> ph $;
axiom ax_2 (ph ps ch: wff): $ (ph -> ps -> ch) -> (ph -> ps) -> ph -> ch $;
axiom ax_3 (ph ps: wff): $ (~ph -> ~ps) -> ps -> ph $;
axiom ax_mp (ph ps: wff): $ ph -> ps $ > $ ph $ > $ ps $;

-- global definitions
do {
  (def (id x) x)
  (def (dbg x) (print x) x)
  (def (foldl l z s) (if (null? l) z (foldl (tl l) (s z (hd l)) s)))
  (def (foldr l z s) (if (null? l) z (s (hd l) (foldr (tl l) z s))))
  (def (range a b) (if {a = b} () (cons a (range {a + 1} b))))
  (def (for a b f) (if {a = b} #undef (begin (f a) (for {a + 1} b f))))
  (def last (match-fn [(a) a] [(_ . l) (last l)]))
  (def split-last @ match-fn
    [(and (_) l) l]
    [(a . l) @ match (split-last l) @ (r . l2) '(,r ,a . ,l2)]
    [() ()])
  (def (append . ls) @ foldr ls () @ fn (l l2) @ foldr l l2 cons)
  (def (rev l) @ foldl l () (fn (l a) (cons a l)))
  (def (len l) @ foldl l 0 (fn (n _) {n + 1}))
  (def (filter l p) @ foldl l () @ fn (x l2) @ if (p x) (cons x l2) l2)
  (def (repeat a n) (if {n = 0} () (cons a (repeat a {n - 1}))))
  (def (iterate n f a) (if {n = 0} a (f (iterate {n - 1} f a))))
  (def (verb e) (copy-span e (list ':verb e)))
  (def (exact e) (refine (verb e)))
  (def (result) (hd (get-goals)))
  (def (inspect-result f) (def g (result)) (refine (f)) (display @ pp g))
  (def (later) @ match (get-goals)
    [(g . gs) (apply set-goals @ append gs @ list g)])
  (def mvar-sort @ match-fn @ (mvar s _) s)
  (def (report a) (def g (result)) (refine a) (print g))
  (def (atom-map . xs) (get! @ apply atom-map! xs))
  (def (lookup-fn xs) @ let ([m (apply atom-map xs)]) (fn k (apply lookup m k)))
  (def (atom-app . xs) (string->atom (apply string-append (map ->string xs))))
  (def transpose @ match-fn*
    [(xs) (apply map list xs)]
    [(n xs) (if (null? xs) (repeat () n) (apply map list xs))])
  (def (join xs) (apply append xs))
  (def (rmap . args) (apply map (split-last args)))
  (def (scan . args) (apply rmap args) #undef)
  (def (undef? x) (not (def? x)))
  (def (error-at sp msg) (report-at 'error sp msg))
  (def (info-at sp msg) (report-at 'info sp msg))
  (def goal! @ match-fn*
    [(ty) (ref! (goal ty))]
    [(pos ty) (ref! (copy-span pos (goal ty)))])
  (def (swap) (match (get-goals) ((x y) (set-goals y x))))
  (def suffices @ match-fn*
    [(h) (have h _) (swap)]
    [xs (apply have xs) (swap)])
  (def (get-proof x) @ match (get-decl x)
    [('theorem _ _ _ _ _ pf) (hd @ tl @ pf)]
    [_ (error "not a theorem")])
  (def (pp-proof x) (display @ pp @ get-proof x))
  (def named
    (def (assign-mvar m x) (set! m (dummy! x (mvar-sort m))))
    @ match-fn*
      [((? atom? d) es) (refine es) (scan (get-mvars) (list d) assign-mvar)]
      [(ds es) (refine es) (scan (get-mvars) ds assign-mvar)]
      [(es) (refine es)
        (def n (ref! 1))
        (scan (get-mvars) @ fn (v)
          (assign-mvar v (atom-app "x" n)) (set! n {n + 1}))])

  (def eq-for @ lookup-fn '([wff iff] [nat eq] [set eqs]))
  (def nf-for @ lookup-fn '([wff nf] [nat nfn] [set nfs]))
  (def eqid-for @ lookup-fn '([wff biid] [nat eqid] [set eqsid]))
  (def eqidd-for @ lookup-fn '([wff biidd] [nat eqidd] [set eqsidd]))
  (def eqd-map (atom-map!))
  (def (eqd-for . e) (apply lookup eqd-map e))
  (def (register-eqd df) (fn (tgt) (insert! eqd-map df tgt)))
  (def (get-tgt-args args df . s) @ match args
    [() (apply atom-app df s)]
    [((? atom? t)) (apply atom-app t s)]
    [('quote (? atom? t)) t])

  -- This metaprogram proves a statement of the form
  -- $ G -> a1 = a2 $ > $ G -> b1 = b2 $ > $ G -> foo a1 b1 = foo a2 b2 $
  -- for any definition foo.
  (def (add-eqd-thm df . args)
    (def tgt (get-tgt-args args df "eqd"))
    @ match (get-decl df)
      [#undef (error (string-append "declaration '" (->string df) "' not found"))]
      [(_ _ () ...)]
      [(_ _ bis (ret _) . rest)
        (def G @ if (apply or (map (match-fn [('G ...) #t] [_ #f]) bis)) '_G '_G)
        @ if (def? (get-decl tgt)) (insert! eqd-map df tgt) @ begin
        (def ctx (atom-map!))
        @ match (map join @ transpose 4 @ rmap bis @ match-fn
          [(and (x s) e) (insert! ctx x (list s)) '((,e) () (,x) (,x))]
          [(v s vs) @ let ([v1 (atom-app v 1)] [v2 (atom-app v 2)] [hv (atom-app 'h v)])
            (insert! ctx v (list v1 v2 s hv))
            '(() ((,v ,s ,(atom-app v 1) ,(atom-app v 2) ,(atom-app 'h v)))
              (,v1) (,v2))]) @ (xs vs es1 es2)
        (def xs1 (map hd xs))
        (def bis '((,G wff ()) . ,(append xs @ join @ rmap vs
          @ match-fn [(v s v1 v2 hv) '((,v1 ,s ,xs1) (,v2 ,s ,xs1))])))
        (def hs @ rmap vs @ match-fn [(v s v1 v2 hv) '(,hv (im ,G (,(eq-for s) ,v1 ,v2)))])
        (def rete '(im ,G (,(eq-for ret) (,df . ,es1) (,df . ,es2))))
        (match rest
          [() (add-thm! tgt bis hs rete)]
          [(_ ds v) @ add-thm! tgt bis hs rete () @ fn () @ list ds
            (def ds (rmap ds @ match-fn @ (x s) (insert! ctx x (list s)) x))
            @ letrec (
              [preproof (match-fn
                [(? atom? v) (lookup ctx v)]
                [((? atom? t) . es)
                  @ match (get-decl t) @ (_ _ bis (ret _) ...)
                  @ if (null? es) (list ret) @ begin
                  (def isrefl (ref! #t))
                  @ match (transpose 5 @ rmap bis es @ match-fn*
                    [((_ _) x) '((,x) () () ,x ,x)]
                    [((_ _ _) e)
                      @ match (preproof e)
                        [(s) '(() (,e ,e) ((,(eqidd-for s) ,G ,e)) ,e ,e)]
                        [(e1 e2 s p) (set! isrefl #f)
                          '(() (,e1 ,e2) (,p) ,e1 ,e2)]]) @ (xs ts ps es1 es2)
                  @ if isrefl (list ret) @ begin
                  @ match (eqd-for t)
                    [#undef (error @ string-append "equality theorem not found for " (->string t))]
                    [eqd '((,t . ,es1) (,t . ,es2) ,ret
                      (,eqd ,G . ,(append (join xs) (join ts) (join ps))))]])]
              [(mk-proof e) (match (preproof e)
                [(s) '(,e ,e (,(eqidd-for s) ,G ,e))]
                [(e1 e2 s p) (list e1 e2 p)])])
            @ match (mk-proof v) @ (t1 t2 p)
            '(:conv ,rete (im ,G (,(eq-for ret)
              (:unfold ,df ,es1 ,ds ,t1)
              (:unfold ,df ,es2 ,ds ,t2))) ,p)])
        (insert! eqd-map df tgt)])

  (def (ded-to-thm t)
    @ match (get-decl t) @ (_ _ ((G 'wff ()) . bis) hs ('im _ ret) ...)
    @ if (apply and @ rmap bis @ match-fn [(_ _ ()) #t] [_ #f]) @ begin
    (def rete @ foldr hs ret @ match-fn* [((_ ('im _ h)) r) '(im ,h ,r)])
    @ list bis rete @ fn () @ list ()
    @ letrec (
      [(exps l r) @ match r
        [('im e1 e2) (list 'exp l e1 e2 (exps (list 'an l e1) e2))]
        [_ (cons t l @ append (map hd bis) @
          map (match-fn [(_ h) h]) @ rev @ conjuncts l)]]
      [conjuncts @ match-fn
        [('an e1 e2)
          @ match (conjuncts e1)
            [(_) '((,e2 (anr ,e1 ,e2)) (,e1 (anl ,e1 ,e2)))]
            [hs (cons '(,e2 (anr ,e1 ,e2)) @
              rmap hs @ match-fn [(e h) '(,e (anwl ,e1 ,e2 ,e ,h))])]]
        [e '((,e (id ,e)))]])
    @ match rete [('im l r) (exps l r)])

  -- Using the *eqd proof above, this metaprogram proves the corresponding *eq
  -- theorem of the form
  -- $ a1 = a2 -> b1 = b2 -> foo a1 b1 = foo a2 b2 $
  -- for any definition foo.
  (def (add-eq-thm t . args)
    (def tgt (get-tgt-args args t "eq"))
    @ if (undef? (get-decl tgt)) @ begin
    @ match (eqd-for t) [#undef] @ eqd
    @ match (ded-to-thm eqd) [#undef] @ (bis ret val)
    (add-thm! tgt bis () ret () val))

  (def (make-eqNd-thms df)
    @ match (get-decl df) @ (_ _ bis (ret _) . rest)
    (def G @ if (apply or (map (match-fn [('G ...) #t] [_ #f]) bis)) '_G 'G)
    @ letrec (
      [mk-bis @ match-fn
        [() '(() () () () ())]
        [((and (x _) e) . bis)
          @ match (mk-bis bis) @ (pes vs es pp data)
          '((,x . ,pes) ,vs ,es ,pp
            ,(rmap data @ match-fn [(b t1 t2 h es ps)
              '(,b (,x . ,t1) (,x . ,t2) ,h ,es ,ps)]))]
        [((v s _) . bis)
          @ match (mk-bis bis) @ (pes vs es pp data)
          @ let ([v1 (atom-app v 1)] [v2 (atom-app v 2)])
          '((,v . ,pes)
            ((,v ,s) . ,vs)
            (,v ,v . ,es)
            ((,(eqidd-for s) ,G ,v) . ,pp)
            ((((,v1 ,s) (,v2 ,s) . ,vs)
              (,v1 . ,pes)
              (,v2 . ,pes)
              (im ,G (,(eq-for s) ,v1 ,v2))
              (,v1 ,v2 . ,es)
              (h . ,pp)) .
             ,(rmap data @ match-fn @ (b t1 t2 h es ps)
              '(((,v ,s) . ,b) (,v . ,t1) (,v . ,t2) ,h (,v ,v . ,es) ((,(eqidd-for s) ,G ,v) . ,ps)))))]])
    (def xs @ join @ rmap bis @ match-fn [(and (_ _) e) (list e)] [_ ()])
    @ rmap (match (mk-bis bis) [(_ _ _ _ data) data]) @ match-fn @ (vs t1 t2 h es ps)
      (def xs1 (map hd xs))
      (def vs+ (rmap vs @ match-fn @ (v s) '(,v ,s ,xs1)))
      @ list
        '((,G wff ()) . ,(append xs vs+))
        '((h ,h))
        '(im ,G (,(eq-for ret) (,df . ,t1) (,df . ,t2)))
        (match (eqd-for df)
          [#undef (error @ string-append "equality theorem not found for " (->string df))]
          [eqd '(,eqd ,G . ,(append xs1 es ps))]))

  -- This program adds *eqNd and *eqN theorems corresponding to the definition
  -- foo, of the form
  -- fooeq1: $ a1 = a2 -> foo a1 b = foo a2 b $
  -- fooeq2: $ b1 = b2 -> foo a b1 = foo a b2 $
  -- fooeq1d: $ G -> a1 = a2 $ > $ G -> foo a1 b = foo a2 b $
  -- fooeq2: $ G -> b1 = b2 $ > $ G -> foo a b1 = foo a b2 $
  -- for any definition foo.
  (def (add-eqN-thms t . args)
    (def idx (ref! 0))
    (def base (get-tgt-args args t "eq"))
    @ match (make-eqNd-thms t)
      [(and (__ 2) thms)
        @ scan thms @ match-fn @ (bis hs ret val)
          (set! idx {idx + 1})
          (def tgt (atom-app base idx "d"))
          @ if (undef? (get-decl tgt)) @ begin
          (add-thm! tgt bis hs ret () '(() ,val))
          (def tgt2 (atom-app base idx))
          @ if (undef? (get-decl tgt2)) @ begin
          @ match (ded-to-thm tgt) [#undef] @ (bis2 ret2 val2)
          (add-thm! tgt2 bis2 () ret2 () val2)]
      [_])

  (def derive-eq @ match-fn*
    [(t1 t2 t3) @ fn (s)
      (add-eqd-thm s '',t1)
      (add-eq-thm s '',t2)
      (add-eqN-thms s '',t3)]
    [args @ fn (s)
      (apply add-eqd-thm s args)
      (apply add-eq-thm s args)
      (apply add-eqN-thms s args)])
};

-- configuration
do {
  (set-timeout 500)
  (def (refine-extra-args refine tgt e . ps)
    @ refine tgt (foldl ps (verb e) @ fn (acc p2) @ copy-span e '(ax_mp ,acc ,p2)))
  (def default-annotate (derive-eq))
  (def (annotate e s) @ match e ['_ (default-annotate s)] [_ (e s)])
};

theorem a1i (h: $ b $): $ a -> b $ = '(ax_1 h);
theorem a2i (h: $ a -> b -> c $): $ (a -> b) -> (a -> c) $ = '(ax_2 h);
theorem mpd (h1: $ a -> b $) (h2: $ a -> b -> c $): $ a -> c $ = '(ax_2 h2 h1);
theorem mpi (h1: $ b $) (h2: $ a -> b -> c $): $ a -> c $ = '(mpd (a1i h1) h2);
theorem id: $ a -> a $ = '(mpd (! ax_1 _ a) ax_1);
theorem idd: $ a -> b -> b $ = '(a1i id);
theorem syl (h1: $ b -> c $) (h2: $ a -> b $): $ a -> c $ = '(mpd h2 (a1i h1));
theorem rsyl (h1: $ a -> b $) (h2: $ b -> c $): $ a -> c $ = '(syl h2 h1);
theorem a1d (h: $ a -> b $): $ a -> c -> b $ = '(syl ax_1 h);
theorem a2d (h: $ a -> b -> c -> d $): $ a -> (b -> c) -> (b -> d) $ = '(syl ax_2 h);
theorem a3d (h: $ a -> ~b -> ~c $): $ a -> c -> b $ = '(syl ax_3 h);
theorem sylc (h: $ b -> c -> d $) (h1: $ a -> b $) (h2: $ a -> c $): $ a -> d $ = '(mpd h2 @ syl h h1);
theorem syld (h1: $ a -> b -> c $) (h2: $ a -> c -> d $): $ a -> b -> d $ = '(mpd h1 @ a2d @ a1d h2);
theorem syl5 (h1: $ b -> c $) (h2: $ a -> c -> d $): $ a -> b -> d $ = '(syld (a1i h1) h2);
theorem syl6 (h1: $ c -> d $) (h2: $ a -> b -> c $): $ a -> b -> d $ = '(syld h2 (a1i h1));
theorem imim2: $ (b -> c) -> (a -> b) -> (a -> c) $ = '(a2d ax_1);
theorem imim2i (h: $ b -> c $): $ (a -> b) -> (a -> c) $ = '(imim2 h);
theorem imim2d (h: $ a -> c -> d $): $ a -> (b -> c) -> (b -> d) $ = '(syl imim2 h);
theorem absurd: $ ~a -> a -> b $ = '(a3d ax_1);
theorem com12 (h: $ a -> b -> c $): $ b -> a -> c $ = '(syl (a2i h) ax_1);
theorem com23 (h: $ a -> b -> c -> d $): $ a -> c -> b -> d $ = '(syl (com12 @ imim2d @ com12 id) h);
theorem imld (h: $ a -> b $) (h2: $ a -> c -> d $): $ a -> (b -> c) -> d $ = '(mpd h @ com23 @ imim2d h2);
theorem absurdr: $ a -> ~a -> b $ = '(com12 absurd);
theorem imim1: $ (a -> b) -> (b -> c) -> (a -> c) $ = '(com12 imim2);
theorem imim1i (h: $ a -> b $): $ (b -> c) -> (a -> c) $ = '(imim1 h);
theorem imim1d (h: $ a -> b -> c $): $ a -> (c -> d) -> (b -> d) $ = '(syl imim1 h);
theorem imimd (h1: $ a -> b -> c $) (h2: $ a -> d -> e $):
  $ a -> (c -> d) -> (b -> e) $ = '(syld (imim1d h1) (imim2d h2));
theorem imim: $ (a -> b) -> (c -> d) -> (b -> c) -> (a -> d) $ = '(syl5 imim2 (imim2d imim1));
theorem imidm: $ (a -> a -> b) -> a -> b $ = '(a2i (com12 id));
theorem contra: $ (~a -> a) -> a $ = '(imidm (a3d (a2i absurd)));
theorem dne: $ ~~a -> a $ = '(syl contra absurd);
theorem inot: $ (a -> ~a) -> ~a $ = '(syl contra (imim1 dne));
theorem con2: $ (a -> ~b) -> (b -> ~a) $ = '(a3d (syl5 dne id));
theorem notnot1: $ a -> ~~a $ = '(con2 id);
theorem con3: $ (a -> b) -> (~b -> ~a) $ = '(syl con2 (imim2i notnot1));
theorem con1: $ (~a -> b) -> (~b -> a) $ = '(a3d (imim2i notnot1));
theorem cases (h1: $ a -> b $) (h2: $ ~a -> b $): $ b $ = '(contra @ syl h1 @ con1 h2);
theorem casesd (h1: $ a -> b -> c $) (h2: $ a -> ~b -> c $): $ a -> c $ =
'(cases (com12 h1) (com12 h2));
theorem con1d (h: $ a -> ~b -> c $): $ a -> ~c -> b $ = '(syl con1 h);
theorem con2d (h: $ a -> b -> ~c $): $ a -> c -> ~b $ = '(syl con2 h);
theorem con3d (h: $ a -> b -> c $): $ a -> ~c -> ~b $ = '(syl con3 h);
theorem con4d (h: $ a -> ~b -> ~c $): $ a -> c -> b $ = '(syl ax_3 h);
theorem mt (h1: $ b -> a $) (h2: $ ~a $): $ ~b $ = '(con3 h1 h2);
theorem mt2 (h1: $ b -> ~a $) (h2: $ a $): $ ~b $ = '(con2 h1 h2);
theorem mtd (h1: $ a -> ~b $) (h2: $ a -> c -> b $): $ a -> ~c $ = '(mpd h1 (con3d h2));
theorem mt2d (h1: $ a -> c $) (h2: $ a -> b -> ~c $): $ a -> ~b $ = '(sylc con2 h2 h1);
theorem eimd (h1: $ a -> b $) (h2: $ a -> c -> d $): $ a -> (b -> c) -> d $ =
'(syld (rsyl h1 @ com12 id) h2);

def an (a b: wff): wff = $ ~(a -> ~b) $;
infixl an: $/\$ prec 34;

theorem anl: $ a /\ b -> a $ = '(con1 absurd);
theorem anr: $ a /\ b -> b $ = '(con1 ax_1);
theorem ian: $ a -> b -> a /\ b $ = '(con2d (com12 id));
theorem iand (h1: $ a -> b $) (h2: $ a -> c $): $ a -> b /\ c $ = '(sylc ian h1 h2);
theorem anld (h: $ a -> b /\ c $): $ a -> b $ = '(syl anl h);
theorem anrd (h: $ a -> b /\ c $): $ a -> c $ = '(syl anr h);
theorem iani (h1: $ a $) (h2: $ b $): $ a /\ b $ = '(ian h1 h2);
theorem anwl (h: $ a -> c $): $ a /\ b -> c $ = '(syl h anl);
theorem anwr (h: $ b -> c $): $ a /\ b -> c $ = '(syl h anr);
theorem anll: $ a /\ b /\ c -> a $ = '(anwl anl);
theorem anlr: $ a /\ b /\ c -> b $ = '(anwl anr);
theorem anrl: $ a /\ (b /\ c) -> b $ = '(anwr anl);
theorem anrr: $ a /\ (b /\ c) -> c $ = '(anwr anr);
theorem anwll (h: $ a -> d $): $ a /\ b /\ c -> d $ = '(anwl (anwl h));
theorem anw3l (h: $ a -> e $): $ a /\ b /\ c /\ d -> e $ = '(anwll (anwl h));
theorem anw4l (h: $ a -> f $): $ a /\ b /\ c /\ d /\ e -> f $ = '(anw3l (anwl h));
theorem anllr: $ a /\ b /\ c /\ d -> b $ = '(anwll anr);
theorem an3l: $ a /\ b /\ c /\ d -> a $ = '(anwll anl);
theorem an3lr: $ a /\ b /\ c /\ d /\ e -> b $ = '(anwl anllr);
theorem an4l: $ a /\ b /\ c /\ d /\ e -> a $ = '(anwl an3l); -- TODO: automate these
theorem an4lr: $ a /\ b /\ c /\ d /\ e /\ f -> b $ = '(anwl an3lr);
theorem an5l: $ a /\ b /\ c /\ d /\ e /\ f -> a $ = '(anwl an4l);
theorem an5lr: $ a /\ b /\ c /\ d /\ e /\ f /\ g -> b $ = '(anwl an4lr);
theorem an6lr: $ a /\ b /\ c /\ d /\ e /\ f /\ g /\ h -> b $ = '(anwl an5lr);
theorem imp (h: $ a -> b -> c $): $ a /\ b -> c $ = '(sylc h anl anr);
theorem exp (h: $ a /\ b -> c $): $ a -> b -> c $ = '(syl6 h ian);
theorem impcom (h: $ a -> b -> c $): $ b /\ a -> c $ = '(imp (com12 h));
theorem expcom (h: $ a /\ b -> c $): $ b -> a -> c $ = '(com12 (exp h));
theorem syla (h1: $ (b -> c) -> d $) (h2: $ a /\ b -> c $): $ a -> d $ = '(syl h1 @ exp h2);
theorem sylan (h: $ b /\ c -> d $) (h1: $ a -> b $) (h2: $ a -> c $):
  $ a -> d $ = '(syl h @ iand h1 h2);
theorem animd (h1: $ a -> b -> c $) (h2: $ a -> d -> e $): $ a -> b /\ d -> c /\ e $ =
'(exp (iand (imp (syl5 anl h1)) (imp (syl5 anr h2))));
theorem anim1d (h: $ a -> b -> c $): $ a -> b /\ d -> c /\ d $ = '(animd h idd);
theorem anim2d (h: $ a -> c -> d $): $ a -> b /\ c -> b /\ d $ = '(animd idd h);
theorem anim1: $ (a -> b) -> a /\ c -> b /\ c $ = '(anim1d id);
theorem anim2: $ (b -> c) -> a /\ b -> a /\ c $ = '(anim2d id);
theorem anim: $ (a -> b) -> (c -> d) -> a /\ c -> b /\ d $ =
'(exp @ syld (anim1d anl) (anim2d anr));
theorem anim2a: $ (a -> b -> c) -> (a /\ b -> a /\ c) $ =
'(exp @ iand anrl @ mpd anrr @ mpd anrl anl);
theorem ancom: $ a /\ b -> b /\ a $ = '(iand anr anl);
theorem anrasss (h: $ a /\ b /\ c -> d $): $ a /\ c /\ b -> d $ =
'(sylan h (iand anll anr) anlr);
theorem casesda (h1: $ a /\ b -> c $) (h2: $ a /\ ~b -> c $): $ a -> c $ =
'(casesd (exp h1) (exp h2));
theorem inotda (h: $ a /\ b -> ~b $): $ a -> ~b $ = '(syla inot h);
theorem mpand (h1: $ a -> b $) (h2: $ a /\ b -> c $): $ a -> c $ = '(mpd h1 (exp h2));
theorem mtand (h1: $ a -> ~b $) (h2: $ a /\ c -> b $): $ a -> ~c $ = '(mtd h1 (exp h2));
theorem mtani (h1: $ ~b $) (h2: $ a /\ c -> b $): $ a -> ~c $ = '(mtand (a1i h1) h2);

def iff (a b: wff): wff = $ (a -> b) /\ (b -> a) $;
infixl iff: $<->$ prec 20;

theorem bi1: $ (a <-> b) -> a -> b $ = 'anl;
theorem bi1i (h: $ a <-> b $): $ a -> b $ = '(bi1 h);
theorem bi1d (h: $ a -> (b <-> c) $): $ a -> b -> c $ = '(syl bi1 h);
theorem bi1a (h: $ a -> (b <-> c) $): $ a /\ b -> c $ = '(imp @ bi1d h);
theorem bi2: $ (a <-> b) -> b -> a $ = 'anr;
theorem bi2i (h: $ a <-> b $): $ b -> a $ = '(bi2 h);
theorem bi2d (h: $ a -> (b <-> c) $): $ a -> c -> b $ = '(syl bi2 h);
theorem bi2a (h: $ a -> (b <-> c) $): $ a /\ c -> b $ = '(imp @ bi2d h);
theorem ibii (h1: $ a -> b $) (h2: $ b -> a $): $ a <-> b $ = '(iani h1 h2);
theorem ibid (h1: $ a -> b -> c $) (h2: $ a -> c -> b $): $ a -> (b <-> c) $ = '(iand h1 h2);
theorem ibida (h1: $ a /\ b -> c $) (h2: $ a /\ c -> b $): $ a -> (b <-> c) $ = '(ibid (exp h1) (exp h2));
theorem biid: $ a <-> a $ = '(ibii id id);
theorem biidd: $ a -> (b <-> b) $ = '(a1i biid);
theorem mpbi (h1: $ a <-> b $) (h2: $ a $): $ b $ = '(bi1i h1 h2);
theorem mpbir (h1: $ b <-> a $) (h2: $ a $): $ b $ = '(bi2i h1 h2);
theorem mpbid (h1: $ a -> (b <-> c) $) (h2: $ a -> b $): $ a -> c $ = '(mpd h2 (bi1d h1));
theorem mpbird (h1: $ a -> (c <-> b) $) (h2: $ a -> b $): $ a -> c $ = '(mpd h2 (bi2d h1));
theorem mpbii (h1: $ b $) (h2: $ a -> (b <-> c) $): $ a -> c $ = '(mpbid h2 (a1i h1));
theorem mpbiri (h1: $ b $) (h2: $ a -> (c <-> b) $): $ a -> c $ = '(mpbird h2 (a1i h1));
theorem mtbi (h1: $ a <-> b $) (h2: $ ~a $): $ ~b $ = '(mt (bi2 h1) h2);
theorem mtbir (h1: $ b <-> a $) (h2: $ ~a $): $ ~b $ = '(mt (bi1 h1) h2);
theorem mtbid (h1: $ a -> (b <-> c) $) (h2: $ a -> ~b $): $ a -> ~c $ = '(mtd h2 (bi2d h1));
theorem mtbird (h1: $ a -> (c <-> b) $) (h2: $ a -> ~b $): $ a -> ~c $ = '(mtd h2 (bi1d h1));
theorem con1b: $ (~a <-> b) -> (~b <-> a) $ = '(ibid (con1d bi1) (con2d bi2));
theorem con2b: $ (a <-> ~b) -> (b <-> ~a) $ = '(ibid (con2d bi1) (con1d bi2));
theorem con3b: $ (a <-> b) -> (~a <-> ~b) $ = '(ibid (con3d bi2) (con3d bi1));
theorem con4b: $ (~a <-> ~b) -> (a <-> b) $ = '(ibid (con4d bi2) (con4d bi1));
theorem con1bb: $ (~a <-> b) <-> (~b <-> a) $ = '(ibii con1b con1b);
theorem con2bb: $ (a <-> ~b) <-> (b <-> ~a) $ = '(ibii con2b con2b);
theorem con3bb: $ (a <-> b) <-> (~a <-> ~b) $ = '(ibii con3b con4b);
theorem con1bi: $ (~a -> b) <-> (~b -> a) $ = '(ibii con1 con1);
theorem con2bi: $ (a -> ~b) <-> (b -> ~a) $ = '(ibii con2 con2);
theorem con3bi: $ (a -> b) <-> (~b -> ~a) $ = '(ibii con3 ax_3);
theorem notnot: $ a <-> ~~a $ = '(ibii notnot1 dne);
theorem bithd (h1: $ a -> b $) (h2: $ a -> c $): $ a -> (b <-> c) $ = '(ibid (a1d h2) (a1d h1));
theorem binthd (h1: $ a -> ~b $) (h2: $ a -> ~c $): $ a -> (b <-> c) $ = '(syl con4b @ bithd h1 h2);
theorem bith: $ a -> b -> (a <-> b) $ = '(exp @ bithd anl anr);
theorem binth: $ ~a -> ~b -> (a <-> b) $ = '(exp @ binthd anl anr);
theorem bicom: $ (a <-> b) -> (b <-> a) $ = '(ibid bi2 bi1);
theorem bicomb: $ (a <-> b) <-> (b <-> a) $ = '(ibii bicom bicom);
theorem bicomd (h: $ a -> (b <-> c) $): $ a -> (c <-> b) $ = '(syl bicom h);
theorem bitrd (h1: $ a -> (b <-> c) $) (h2: $ a -> (c <-> d) $): $ a -> (b <-> d) $ =
'(ibid (syld (bi1d h1) (bi1d h2)) (syld (bi2d h2) (bi2d h1)));
theorem bitr2d (h1: $ a -> (b <-> c) $) (h2: $ a -> (c <-> d) $): $ a -> (d <-> b) $ = '(bicomd (bitrd h1 h2));
theorem bitr3d (h1: $ a -> (c <-> b) $) (h2: $ a -> (c <-> d) $): $ a -> (b <-> d) $ = '(bitrd (bicomd h1) h2);
theorem bitr4d (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> c) $): $ a -> (b <-> d) $ = '(bitrd h1 (bicomd h2));
theorem bitr: $ (a <-> b) -> (b <-> c) -> (a <-> c) $ = '(exp (bitrd anl anr));
theorem bitr2: $ (a <-> b) -> (b <-> c) -> (c <-> a) $ = '(exp (bitr2d anl anr));
theorem bitr3: $ (b <-> a) -> (b <-> c) -> (a <-> c) $ = '(exp (bitr3d anl anr));
theorem bitr4: $ (a <-> b) -> (c <-> b) -> (a <-> c) $ = '(exp (bitr4d anl anr));
theorem sylib (h1: $ b <-> c $) (h2: $ a -> b $): $ a -> c $ = '(syl (bi1i h1) h2);
theorem sylibr (h1: $ c <-> b $) (h2: $ a -> b $): $ a -> c $ = '(syl (bi2i h1) h2);
theorem sylbi (h1: $ a <-> b $) (h2: $ b -> c $): $ a -> c $ = '(syl h2 (bi1i h1));
theorem sylbir (h1: $ b <-> a $) (h2: $ b -> c $): $ a -> c $ = '(syl h2 (bi2i h1));
theorem syl5bb (h1: $ b <-> c $) (h2: $ a -> (c <-> d) $): $ a -> (b <-> d) $ = '(bitrd (a1i h1) h2);
theorem syl5bbr (h1: $ c <-> b $) (h2: $ a -> (c <-> d) $): $ a -> (b <-> d) $ = '(syl5bb (bicom h1) h2);
theorem syl6bb (h1: $ c <-> d $) (h2: $ a -> (b <-> c) $): $ a -> (b <-> d) $ = '(bitrd h2 (a1i h1));
theorem syl6bbr (h1: $ d <-> c $) (h2: $ a -> (b <-> c) $): $ a -> (b <-> d) $ = '(syl6bb (bicom h1) h2);
theorem syl5bi (h1: $ b <-> c $) (h2: $ a -> c -> d $): $ a -> b -> d $ = '(syl5 (bi1 h1) h2);
theorem syl5bir (h1: $ c <-> b $) (h2: $ a -> c -> d $): $ a -> b -> d $ = '(syl5bi (bicom h1) h2);
theorem syl6ib (h1: $ c <-> d $) (h2: $ a -> b -> c $): $ a -> b -> d $ = '(syl6 (bi1 h1) h2);
theorem syl6ibr (h1: $ d <-> c $) (h2: $ a -> b -> c $): $ a -> b -> d $ = '(syl6 (bi2 h1) h2);
theorem syl5ibrcom (h1: $ c -> (b <-> d) $) (h2: $ a -> d $): $ a -> c -> b $ = '(com12 @ syl5 h2 (bi2d h1));
theorem bitr3g (h1: $ b <-> d $) (h2: $ c <-> e $) (h: $ a -> (b <-> c) $):
  $ a -> (d <-> e) $ = '(syl5bb (bicom h1) @ syl6bb h2 h);
theorem bitr4g (h1: $ d <-> b $) (h2: $ e <-> c $) (h: $ a -> (b <-> c) $):
  $ a -> (d <-> e) $ = '(syl5bb h1 @ syl6bb (bicom h2) h);
theorem bitr3gi (h1: $ a <-> c $) (h2: $ b <-> d $) (h: $ a <-> b $): $ c <-> d $ = '(bitr3 h1 @ bitr h h2);
theorem bitr4gi (h1: $ c <-> a $) (h2: $ d <-> b $) (h: $ a <-> b $): $ c <-> d $ = '(bitr h1 @ bitr4 h h2);
theorem impbi (h: $ a -> (b <-> c) $): $ a /\ b -> c $ = '(imp @ bi1d h);
theorem impbir (h: $ a -> (c <-> b) $): $ a /\ b -> c $ = '(imp @ bi2d h);
theorem ancomb: $ a /\ b <-> b /\ a $ = '(ibii ancom ancom);
theorem anass: $ a /\ b /\ c <-> a /\ (b /\ c) $ =
'(ibii (iand anll (anim1 anr)) (iand (anim2 anl) anrr));
theorem bian2a: $ (a -> b) -> (a /\ b <-> a) $ = '(ibid (a1i anl) (a2i ian));
theorem bian1a: $ (b -> a) -> (a /\ b <-> b) $ = '(syl5bb ancomb bian2a);
theorem bian1: $ a -> (a /\ b <-> b) $ = '(syl bian1a ax_1);
theorem bian2: $ b -> (a /\ b <-> a) $ = '(syl bian2a ax_1);
theorem bibi1: $ a -> ((a <-> b) <-> b) $ = '(ibid (com12 bi1) bith);
theorem bibi2: $ b -> ((a <-> b) <-> a) $ = '(syl5bb bicomb bibi1);
theorem noteq: $ (a <-> b) -> (~a <-> ~b) $ = 'con3b;
theorem noteqi (h: $ a <-> b $): $ ~a <-> ~b $ = '(noteq h);
@(register-eqd 'not) theorem noteqd (h: $ a -> (b <-> c) $): $ a -> (~b <-> ~c) $ = '(syl noteq h);
@(register-eqd 'im) theorem imeqd
  (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> e) $): $ a -> (b -> d <-> c -> e) $ =
'(ibid (imimd (bi2d h1) (bi1d h2)) (imimd (bi1d h1) (bi2d h2)));
theorem bibin1: $ ~a -> ((a <-> b) <-> ~b) $ = '(ibid (com12 @ bi1d noteq) binth);
theorem bibin2: $ ~b -> ((a <-> b) <-> ~a) $ = '(syl5bb bicomb bibin1);
theorem imeq1d (h: $ a -> (b <-> c) $): $ a -> (b -> d <-> c -> d) $ = '(imeqd h biidd);
theorem imeq2d (h: $ a -> (c <-> d) $): $ a -> (b -> c <-> b -> d) $ = '(imeqd biidd h);
theorem imeq1i (h: $ a <-> b $): $ a -> c <-> b -> c $ = '(imeq1d id h);
theorem imeq2i (h: $ b <-> c $): $ a -> b <-> a -> c $ = '(imeq2d id h);
theorem imeqi (h1: $ a <-> b $) (h2: $ c <-> d $): $ a -> c <-> b -> d $ = '(bitr (imeq1i h1) (imeq2i h2));
@(register-eqd 'an) theorem aneqd
  (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> e) $): $ a -> (b /\ d <-> c /\ e) $ =
'(ibid (animd (bi1d h1) (bi1d h2)) (animd (bi2d h1) (bi2d h2)));
theorem imeq2a: $ (a -> (b <-> c)) -> (a -> b <-> a -> c) $ = '(ibid (a2d @ imim2i bi1) (a2d @ imim2i bi2));
theorem aneq1d (h: $ a -> (b <-> c) $): $ a -> (b /\ d <-> c /\ d) $ = '(aneqd h biidd);
theorem aneq2d (h: $ a -> (c <-> d) $): $ a -> (b /\ c <-> b /\ d) $ = '(aneqd biidd h);
theorem aneq: $ (a <-> b) -> (c <-> d) -> (a /\ c <-> b /\ d) $ = '(exp @ aneqd anl anr);
theorem aneq1i (h: $ a <-> b $): $ a /\ c <-> b /\ c $ = '(aneq1d id h);
theorem aneq2i (h: $ b <-> c $): $ a /\ b <-> a /\ c $ = '(aneq2d id h);
theorem aneq2a: $ (a -> (b <-> c)) -> (a /\ b <-> a /\ c) $ =
'(ibid (syl anim2a @ imim2i bi1) (syl anim2a @ imim2i bi2));
theorem aneq1a: $ (c -> (a <-> b)) -> (a /\ c <-> b /\ c) $ = '(syl5bb ancomb @ syl6bb ancomb aneq2a);
theorem anlass: $ a /\ (b /\ c) <-> b /\ (a /\ c) $ =
'(bitr3 anass @ bitr (aneq1i ancomb) anass);
theorem anrass: $ a /\ b /\ c <-> a /\ c /\ b $ =
'(bitr anass @ bitr4 (aneq2i ancomb) anass);
theorem anidm: $ a /\ a <-> a $ = '(ibii anl (iand id id));
theorem rbida (h1: $ a /\ c -> b $) (h2: $ a /\ d -> b $)
  (h: $ a /\ b -> (c <-> d) $): $ a -> (c <-> d) $ =
'(bitr3d (syla bian2a h1) @ bitrd (syla aneq1a h) (syla bian2a h2));
theorem rbid (h1: $ b -> a $) (h2: $ c -> a $) (h: $ a -> (b <-> c) $): $ b <-> c $ =
'(bitr3 (bian2a h1) @ bitr (aneq1a h) (bian2a h2));
@(register-eqd 'iff) theorem bieqd
  (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> e) $): $ a -> ((b <-> d) <-> (c <-> e)) $ =
'(aneqd (imeqd h1 h2) (imeqd h2 h1));
theorem bieq1d (h: $ a -> (b <-> c) $): $ a -> ((b <-> d) <-> (c <-> d)) $ = '(bieqd h biidd);
theorem bieq2d (h: $ a -> (c <-> d) $): $ a -> ((b <-> c) <-> (b <-> d)) $ = '(bieqd biidd h);
theorem bieq: $ (a <-> b) -> (c <-> d) -> ((a <-> c) <-> (b <-> d)) $ = '(exp (bieqd anl anr));
theorem bieq1: $ (a <-> b) -> ((a <-> c) <-> (b <-> c)) $ = '(bieq1d id);
theorem bieq2: $ (b <-> c) -> ((a <-> b) <-> (a <-> c)) $ = '(bieq2d id);
theorem impexp: $ (a /\ b -> c) <-> (a -> b -> c) $ =
'(ibii (exp @ exp @ mpd (anim1 anr) anll) (exp @ mpd anrr @ mpd anrl anl));
theorem impd (h: $ a -> b -> c -> d $): $ a -> b /\ c -> d $ = '(sylibr impexp h);
theorem expd (h: $ a -> b /\ c -> d $): $ a -> b -> c -> d $ = '(sylib impexp h);

@_ def or (a b: wff): wff = $ ~a -> b $;
infixl or: $\/$ prec 30;

theorem orl: $ a -> a \/ b $ = 'absurdr;
theorem orr: $ b -> a \/ b $ = 'ax_1;
theorem eori (h1: $ a -> c $) (h2: $ b -> c $): $ a \/ b -> c $ =
'(casesd (a1i h1) (imim2i h2));
theorem eord (h1: $ a -> b -> d $) (h2: $ a -> c -> d $):
  $ a -> b \/ c -> d $ = '(com12 (eori (com12 h1) (com12 h2)));
theorem eorda (h1: $ a /\ b -> d $) (h2: $ a /\ c -> d $):
  $ a -> b \/ c -> d $ = '(eord (exp h1) (exp h2));
theorem orld (h: $ a -> b $): $ a -> b \/ c $ = '(syl orl h);
theorem orrd (h: $ a -> c $): $ a -> b \/ c $ = '(syl orr h);
theorem eor: $ (a -> c) -> (b -> c) -> a \/ b -> c $ = '(exp (eord anl anr));
theorem orimd (h1: $ a -> b -> c $) (h2: $ a -> d -> e $): $ a -> b \/ d -> c \/ e $ =
'(eord (syl6 orl h1) (syl6 orr h2));
theorem orim1d (h: $ a -> b -> c $): $ a -> b \/ d -> c \/ d $ = '(orimd h idd);
theorem orim2d (h: $ a -> c -> d $): $ a -> b \/ c -> b \/ d $ = '(orimd idd h);
theorem orim1: $ (a -> b) -> a \/ c -> b \/ c $ = '(orim1d id);
theorem orim2: $ (b -> c) -> a \/ b -> a \/ c $ = '(orim2d id);
theorem oreq1i (h: $ a <-> b $): $ a \/ c <-> b \/ c $ = '(oreq1d id h);
theorem oreq2i (h: $ b <-> c $): $ a \/ b <-> a \/ c $ = '(oreq2d id h);
theorem orim: $ (a -> b) -> (c -> d) -> a \/ c -> b \/ d $ = '(exp @ syld (anwl orim1) (anwr orim2));
theorem oreqi (h1: $ a <-> b $) (h2: $ c <-> d $): $ a \/ c <-> b \/ d $ = '(bitr (oreq1i h1) (oreq2i h2));
theorem orcom: $ a \/ b -> b \/ a $ = 'con1;
theorem orcomb: $ a \/ b <-> b \/ a $ = '(ibii orcom orcom);
theorem or12: $ a \/ (b \/ c) <-> b \/ (a \/ c) $ = '(bitr3 impexp @ bitr (imeq1i ancomb) impexp);
theorem orass: $ a \/ b \/ c <-> a \/ (b \/ c) $ = '(bitr orcomb @ bitr or12 (oreq2 orcomb));
theorem or4: $ (a \/ b) \/ (c \/ d) <-> (a \/ c) \/ (b \/ d) $ = '(bitr4 orass @ bitr4 orass @ oreq2 or12);
theorem oridm: $ a \/ a <-> a $ = '(ibii (eor id id) orl);
theorem notan2: $ ~(a /\ b) <-> a -> ~b $ = '(bicom notnot);
theorem notan: $ ~(a /\ b) <-> (~a \/ ~b) $ = '(bitr notan2 (imeq1i notnot));
theorem notor: $ ~(a \/ b) <-> (~a /\ ~b) $ = '(con1b (bitr4 notan (oreqi notnot notnot)));
theorem iman: $ a -> b <-> ~(a /\ ~b) $ = '(bitr4 (imeq2i notnot) notan2);
theorem imor: $ ((a \/ b) -> c) <-> ((a -> c) /\ (b -> c)) $ =
'(ibii (iand (imim1i orl) (imim1i orr)) (imp eor));
theorem andi: $ a /\ (b \/ c) <-> a /\ b \/ a /\ c $ =
'(ibii (imp @ orimd ian ian) @ eor (anim2 orl) (anim2 orr));
theorem andir: $ (a \/ b) /\ c <-> a /\ c \/ b /\ c $ =
'(bitr ancomb @ bitr andi @ oreqi ancomb ancomb);
theorem ordi: $ a \/ (b /\ c) <-> (a \/ b) /\ (a \/ c) $ =
'(ibii (iand (orim2 anl) (orim2 anr)) @ com12 @ animd (com12 id) (com12 id));
theorem ordir: $ (a /\ b) \/ c <-> (a \/ c) /\ (b \/ c) $ =
'(bitr orcomb @ bitr ordi @ aneq orcomb orcomb);
theorem oreq2a: $ (~a -> (b <-> c)) -> (a \/ b <-> a \/ c) $ = 'imeq2a;
theorem oreq1a: $ (~c -> (a <-> b)) -> (a \/ c <-> b \/ c) $ = '(syl5bb orcomb @ syl6bb orcomb oreq2a);
theorem biim1a: $ (~a -> b) -> (a -> b <-> b) $ = '(ibid (exp @ casesd anr anl) (a1i ax_1));
theorem biim2a: $ (b -> ~a) -> (a -> b <-> ~a) $ = '(ibid (exp @ syl inot @ imp imim2) (a1i absurd));
theorem bior1a: $ (a -> b) -> (a \/ b <-> b) $ = '(sylbi (imeq1i notnot) biim1a);
theorem bior2a: $ (b -> a) -> (a \/ b <-> a) $ = '(syl5bb orcomb bior1a);
theorem biim1: $ a -> (a -> b <-> b) $ = '(syl biim1a absurdr);
theorem biim2: $ ~b -> (a -> b <-> ~a) $ = '(syl biim2a absurd);
theorem bior1: $ ~a -> (a \/ b <-> b) $ = '(syl bior1a absurd);
theorem bior2: $ ~b -> (a \/ b <-> a) $ = '(syl bior2a absurd);
theorem em: $ p \/ ~p $ = 'id;

@_ abstract def ifp (p a b: wff): wff = $ p /\ a \/ ~p /\ b $;

pub theorem ifppos (p a b: wff): $ p -> (ifp p a b <-> a) $ =
'(bitrd (syl bior2 @ con2 anl) bian1);
pub theorem ifpneg (p a b: wff): $ ~p -> (ifp p a b <-> b) $ =
'(bitrd (syl bior1 @ con3 anl) bian1);

term wtru: wff; prefix wtru: $T.$ prec max;
axiom tru: $ T. $;
def fal: wff = $ ~T. $; prefix fal: $F.$ prec max;

theorem trud (h: $ T. -> a $): $ a $ = '(h tru);
theorem notfal: $ ~F. $ = '(notnot1 tru);
theorem efal: $ F. -> a $ = '(absurd notfal);

sort nat;
term al {x: nat} (ph: wff x): wff; prefix al: $A.$ prec 41;

def ex {x: nat} (ph: wff x): wff = $ ~(A. x ~ph) $;
prefix ex: $E.$ prec 41;

term eq (a b: nat): wff; infixl eq: $=$ prec 50;

axiom ax_gen {x: nat} (ph: wff x): $ ph $ > $ A. x ph $;
axiom ax_4 {x: nat} (ph ps: wff x): $ A. x (ph -> ps) -> A. x ph -> A. x ps $;
axiom ax_5 {x: nat} (ph: wff): $ ph -> A. x ph $;
axiom ax_6 (a: nat) {x: nat}: $ E. x x = a $;
axiom ax_7 (a b c: nat): $ a = b -> a = c -> b = c $;
axiom ax_10 {x: nat} (ph: wff x): $ ~(A. x ph) -> A. x ~ (A. x ph) $;
axiom ax_11 {x y: nat} (ph: wff x y): $ A. x A. y ph -> A. y A. x ph $;
axiom ax_12 {x: nat} (a: nat) (ph: wff x): $ x = a -> ph -> A. x (x = a -> ph) $;

theorem alimi (a b: wff x) (h: $ a -> b $): $ A. x a -> A. x b $ = '(ax_4 (ax_gen h));
theorem iald (a: wff) (b: wff x) (h: $ a -> b $): $ a -> A. x b $ = '(syl (alimi h) ax_5);
theorem eex (a: wff x) (b: wff) (h: $ a -> b $): $ E. x a -> b $ = '(con1 @ iald @ con3 h);

theorem eqtr3: $ b = a -> b = c -> a = c $ = 'ax_7;
theorem eqid: $ a = a $ = '(!! eex x (imidm ax_7) ax_6);
theorem eqcom: $ a = b -> b = a $ = '(mpi eqid ax_7);
theorem eqtr: $ a = b -> b = c -> a = c $ = '(syl ax_7 eqcom);
theorem eqtr2: $ a = b -> b = c -> c = a $ = '(syl6 eqcom eqtr);
theorem eqtr4: $ a = b -> c = b -> a = c $ = '(syl5 eqcom eqtr);
theorem eqcomb: $ a = b <-> b = a $ = '(ibii eqcom eqcom);
theorem eqeq1: $ a = b -> (a = c <-> b = c) $ = '(ibid eqtr3 eqtr);
theorem eqeq2: $ b = c -> (a = b <-> a = c) $ = '(ibid (com12 eqtr) (com12 eqtr4));
theorem eqeq1d (h: $ G -> a = b $): $ G -> (a = c <-> b = c) $ = '(syl eqeq1 h);
theorem eqeq2d (h: $ G -> b = c $): $ G -> (a = b <-> a = c) $ = '(syl eqeq2 h);
@(register-eqd 'eq) theorem eqeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> (a = c <-> b = d) $ = '(bitrd (eqeq1d h1) (eqeq2d h2));
theorem eqeq: $ a = b -> c = d -> (a = c <-> b = d) $ = '(exp (eqeqd anl anr));
theorem eqtr2d (h1: $ G -> a = b $) (h2: $ G -> b = c $): $ G -> c = a $ = '(sylc eqtr2 h1 h2);
theorem eqtr3d (h1: $ G -> b = a $) (h2: $ G -> b = c $): $ G -> a = c $ = '(sylc eqtr3 h1 h2);
theorem eqidd: $ G -> a = a $ = '(a1i eqid);
theorem eqcomi (h: $ a = b $): $ b = a $ = '(eqcom h);
theorem eqcomd (h: $ G -> a = b $): $ G -> b = a $ = '(syl eqcom h);
theorem eqtrd (h1: $ G -> a = b $) (h2: $ G -> b = c $): $ G -> a = c $ = '(sylc eqtr h1 h2);
theorem eqtr4i (h1: $ a = b $) (h2: $ c = b $): $ a = c $ = '(eqtr4 h1 h2);
theorem eqtr4d (h1: $ G -> a = b $) (h2: $ G -> c = b $): $ G -> a = c $ = '(sylc eqtr4 h1 h2);
theorem syl5eq (h1: $ a = b $) (h2: $ G -> b = c $): $ G -> a = c $ = '(eqtrd (a1i h1) h2);
theorem syl5eqr (h1: $ b = a $) (h2: $ G -> b = c $): $ G -> a = c $ = '(eqtr3d (a1i h1) h2);
theorem syl6eq (h1: $ b = c $) (h2: $ G -> a = b $): $ G -> a = c $ = '(eqtrd h2 (a1i h1));
theorem syl6eqr (h1: $ c = b $) (h2: $ G -> a = b $): $ G -> a = c $ = '(eqtr4d h2 (a1i h1));
theorem eqtr3g (h1: $ a = c $) (h2: $ b = d $) (h: $ G -> a = b $):
  $ G -> c = d $ = '(syl5eqr h1 @ syl6eq h2 h);
theorem eqtr4g (h1: $ c = a $) (h2: $ d = b $) (h: $ G -> a = b $):
  $ G -> c = d $ = '(syl5eq h1 @ syl6eqr h2 h);

theorem aleq (a b: wff x): $ A. x (a <-> b) -> (A. x a <-> A. x b) $ =
'(ibid (syl ax_4 @ alimi bi1) (syl ax_4 @ alimi bi2));
theorem aleqi (a b: wff x) (h: $ a <-> b $): $ A. x a <-> A. x b $ = '(aleq @ ax_gen h);
theorem alimd (G) (a b: wff x) (h: $ G -> a -> b $):
  $ G -> A. x a -> A. x b $ = '(syl ax_4 @ syl (alimi h) ax_5);
theorem al2imi (a b c: wff x) (h: $ a -> b -> c $): $ A. x a -> A. x b -> A. x c $ =
'(syl ax_4 @ alimi h);
@(register-eqd 'al) theorem aleqd (G) {x} (a b: wff x) (h: $ G -> (a <-> b) $):
  $ G -> (A. x a <-> A. x b) $ = '(syl aleq @ iald h);
theorem alcomb (a: wff x y): $ A. x A. y a <-> A. y A. x a $ = '(ibii ax_11 ax_11);
theorem alan (a b: wff x): $ A. x (a /\ b) <-> A. x a /\ A. x b $ =
'(ibii (iand (alimi anl) (alimi anr)) (imp @ syl ax_4 @ alimi ian));
theorem exim (a b: wff x): $ A. x (a -> b) -> E. x a -> E. x b $ =
'(syl con3 @ syl ax_4 @ alimi con3);
theorem eximi (a b: wff x) (h: $ a -> b $): $ E. x a -> E. x b $ = '(exim @ ax_gen h);
theorem exeq (a b: wff x): $ A. x (a <-> b) -> (E. x a <-> E. x b) $ =
'(noteqd @ syl aleq @ alimi noteq);
@(register-eqd 'ex) theorem exeqd (G) {x} (a b: wff x) (h: $ G -> (a <-> b) $):
  $ G -> (E. x a <-> E. x b) $ = '(syl exeq @ iald h);
theorem exeqi (a b: wff x) (h: $ a <-> b $):
  $ E. x a <-> E. x b $ = '(exeq @ ax_gen h);
theorem iex (a: wff x): $ a -> E. x a $ =
'(!! eex y (rsyl eqcom @ syl6 (mpi ax_6 exim) ax_12) ax_6);
theorem alanex (a b: wff x): $ A. x a /\ E. x b -> E. x (a /\ b) $ = '(imp @ syl exim @ alimi ian);
theorem exanal (a b: wff x): $ E. x a /\ A. x b -> E. x (a /\ b) $ = '(impcom @ syl exim @ alimi @ com12 ian);
theorem alnex (a: wff x): $ A. x ~a <-> ~(E. x a) $ = 'notnot;
theorem ngen (a: wff x) (h: $ ~a $): $ ~E. x a $ = '(notnot1 (ax_gen h));
theorem alex (a: wff x): $ A. x a <-> ~(E. x ~a) $ =
'(bitr (aleqi notnot) alnex);
theorem exnal (a: wff x): $ E. x ~a <-> ~(A. x a) $ = '(con2b alex);
theorem eal (a: wff x): $ A. x a -> a $ = '(ax_3 @ sylib exnal iex);
theorem exor (a b: wff x): $ E. x (a \/ b) <-> E. x a \/ E. x b $ =
'(bitr (noteqi (bitr (aleqi notor) alan)) notan);
theorem eximd (G) (a b: wff x) (h: $ G -> a -> b $): $ G -> E. x a -> E. x b $ = '(syl exim @ iald h);
theorem excomb (a: wff x y): $ E. x E. y a <-> E. y E. x a $ =
'(noteq @ bitr3 (aleqi alnex) @ bitr alcomb (aleqi alnex));
theorem excom (a: wff x y): $ E. x E. y a -> E. y E. x a $ = '(bi1 excomb);
theorem nexi (a: wff x) (h: $ ~a $): $ ~E. x a $ = '(mpbi alnex @ ax_gen h);
theorem nexd (a: wff x) (h: $ G -> ~a $): $ G -> ~E. x a $ = '(sylib alnex @ iald h);

@_ local def nf {x: nat} (a: wff x): wff = $ A. x (a -> A. x a) $;
prefix nf: $F/$ prec 10;

theorem nfv: $ F/ x a $ = '(ax_gen ax_5);
theorem nfi (a: wff x) (h: $ F/ x a $): $ a -> A. x a $ = '(eal h);
theorem nfri (a: wff x) (h: $ a -> A. x a $): $ F/ x a $ = '(ax_gen h);
theorem nfeqi (a b: wff x) (h: $ a <-> b $): $ (F/ x a) <-> (F/ x b) $ = '(trud @ nfeqd @ a1i h);
theorem nfx (a b: wff x) (h1: $ a <-> b $) (h2: $ F/ x b $): $ F/ x a $ = '(bi2i (nfeqi h1) h2);
theorem nfal (a: wff x y) (h: $ F/ x a $): $ F/ x A. y a $ =
'(nfri @ syl ax_11 @ alimi @ nfi h);
theorem nfnot (a: wff x) (h: $ F/ x a $): $ F/ x ~a $ =
'(nfri @ con1 @ syl eal @ syl (con1 @ !! ax_10 x) @ eximi @ nfi h);
theorem nfim (a b: wff x) (h1: $ F/ x a $) (h2: $ F/ x b $): $ F/ x a -> b $ =
'(nfri @ cases
   (syl6 (syl (alimi ax_1) (nfi h2)) (com12 id))
   (a1d @ syl (alimi absurd) @ nfi @ nfnot h1));
theorem nfan (a b: wff x) (h1: $ F/ x a $) (h2: $ F/ x b $): $ F/ x a /\ b $ = '(nfnot @ nfim h1 @ nfnot h2);
theorem nfor (a b: wff x) (h1: $ F/ x a $) (h2: $ F/ x b $): $ F/ x a \/ b $ = '(nfim (nfnot h1) h2);
theorem nfbi (a b: wff x) (h1: $ F/ x a $) (h2: $ F/ x b $): $ F/ x a <-> b $ = '(nfan (nfim h1 h2) (nfim h2 h1));
theorem nfex1 (a: wff x): $ F/ x E. x a $ = '(ax_gen ax_10);
theorem nfex (a: wff x y) (h: $ F/ x a $): $ F/ x E. y a $ = '(nfnot @ nfal @ nfnot h);
theorem nfal1 (a: wff x): $ F/ x A. x a $ = '(nfx alex @ nfnot nfex1);

theorem ialdh (a b: wff x) (h1: $ F/ x a $) (h2: $ a -> b $): $ a -> A. x b $ =
'(syl (alimi h2) (nfi h1));
theorem eexh (a b: wff x) (h1: $ F/ x b $) (h2: $ a -> b $): $ E. x a -> b $ =
'(con1 @ ialdh (nfnot h1) @ con3 h2);
theorem eexdh (a b c: wff x) (h1: $ F/ x a $) (h2: $ F/ x c $)
  (h3: $ a -> b -> c $): $ a -> E. x b -> c $ =
'(con1d @ exp @ ialdh (nfan h1 (nfnot h2)) (imp @ con3d h3));
theorem alimdh (a b c: wff x) (h1: $ F/ x a $) (h2: $ a -> b -> c $):
  $ a -> A. x b -> A. x c $ = '(syl ax_4 @ ialdh h1 h2);
theorem aleqdh (G a b: wff x) (h1: $ F/ x G $) (h: $ G -> (a <-> b) $):
  $ G -> (A. x a <-> A. x b) $ = '(syl aleq @ ialdh h1 h);
theorem eexd (a: wff) (b: wff x) (c: wff)
  (h: $ a -> b -> c $): $ a -> E. x b -> c $ = '(eexdh nfv nfv h);
theorem eexda (a: wff) (b: wff x) (c: wff)
  (h: $ a /\ b -> c $): $ a -> E. x b -> c $ = '(eexd (exp h));
theorem eexb (a: wff x) (b: wff): $ (E. x a -> b) <-> A. x (a -> b) $ =
'(ibii (ialdh (nfim nfex1 nfv) (imim1i iex)) (eexdh nfal1 nfv eal));
theorem iexeh (a: nat) (b c: wff x) (h: $ F/ x c $)
  (e: $ x = a -> (b <-> c) $): $ c -> E. x b $ =
'(mpi ax_6 @ syl exim @ ialdh h @ com12 @ bi2d e);
theorem ealeh (a: nat) (b c: wff x) (h: $ F/ x c $)
  (e: $ x = a -> (b <-> c) $): $ A. x b -> c $ =
'(ax_3 @ sylib exnal @ iexeh (nfnot h) @ noteqd e);
theorem alim1 (a) (b: wff x): $ A. x (a -> b) <-> a -> A. x b $ =
'(ibii (com12 @ alimd @ com12 id) (ialdh (nfim nfv nfal1) @ imim2i eal));
theorem eqerd {x} (h: $ G -> a = x -> p $): $ G -> p $ = '(mpi ax_6 @ eexd @ syl5 eqcom h);
theorem eale (a: nat) (b: wff x) (c: wff)
  (e: $ x = a -> (b <-> c) $): $ A. x b -> c $ = '(ealeh nfv e);
theorem iexdeh (a: nat) (G b: wff x) (h: $ F/ x G $)
  (e: $ G /\ x = a -> b $): $ G -> E. x b $ = '(mpi ax_6 (syl exim @ ialdh h (exp e)));
theorem iexde (G) (a: nat) (b: wff x)
  (e: $ G /\ x = a -> b $): $ G -> E. x b $ = '(iexdeh nfv e);
theorem iexdde (G b) (a: nat) (c: wff x)
  (e: $ G /\ x = a -> b -> c $): $ G -> b -> E. x c $ =
'(exp @ iexde @ imp @ imp @ com23 @ exp e);
theorem iexe (a: nat) (b: wff x) (c: wff)
  (e: $ x = a -> (b <-> c) $): $ c -> E. x b $ = '(iexde @ mpbird (anwr e) anl);
theorem ealdeh (a: nat) (G b c: wff x) (h1: $ F/ x G $) (h2: $ F/ x c $)
  (e: $ G /\ x = a -> b -> c $): $ G -> A. x b -> c $ =
'(con4d @ exp @ sylib exnal @ iexdeh (nfan h1 @ nfnot h2) @ anrasss @ imp @ con3d e);
theorem ealieh (a: nat) (b: wff x) (h: $ F/ x c $)
  (e: $ x = a -> b -> c $): $ A. x b -> c $ =
'(trud @ ealdeh nfv h @ anwr e);
theorem ealde (G) (a: nat) (b: wff x)
  (e: $ G /\ x = a -> b -> c $): $ G -> A. x b -> c $ = '(ealdeh nfv nfv e);
theorem ealie (a: nat) (b: wff x) (e: $ x = a -> b -> c $): $ A. x b -> c $ = '(ealieh nfv e);
theorem exan1 (a) (b: wff x): $ E. x (a /\ b) <-> a /\ E. x b $ =
'(ibii (iand (eex anl) (eximi anr)) (imp @ eximd ian));
theorem exan2 (a: wff x) (b): $ E. x (a /\ b) <-> E. x a /\ b $ =
'(bitr (exeqi ancomb) @ bitr exan1 ancomb);
theorem alexan (a b: wff x): $ A. x a -> E. x b -> E. x (a /\ b) $ =
'(syl exim @ alimi ian);

theorem cbvalh (p q: wff x y) (h1: $ F/ y p $) (h2: $ F/ x q $)
  (e: $ x = y -> (p <-> q) $): $ A. x p <-> A. y q $ =
'(ibii (ialdh (nfal h1) (ealeh h2 e))
  (ialdh (nfal h2) (ealeh h1 @ bicomd @ syl e eqcom)));
theorem cbval (p: wff x) (q: wff y)
  (e: $ x = y -> (p <-> q) $): $ A. x p <-> A. y q $ = '(cbvalh nfv nfv e);

theorem cbvexh (p q: wff x y) (h1: $ F/ y p $) (h2: $ F/ x q $)
  (e: $ x = y -> (p <-> q) $): $ E. x p <-> E. y q $ =
'(noteq (cbvalh (nfnot h1) (nfnot h2) (noteqd e)));
theorem cbvex (p: wff x) (q: wff y)
  (e: $ x = y -> (p <-> q) $): $ E. x p <-> E. y q $ = '(cbvexh nfv nfv e);

@_ def ne (a b: nat): wff = $ ~ a = b $; infixl ne: $!=$ prec 50;

theorem necom: $ a != b -> b != a $ = '(con3 eqcom);

def sb (a: nat) {x .y: nat} (ph: wff x): wff =
  $ A. y (y = a -> A. x (x = y -> ph)) $;
notation sb (a x ph) = ($[$:41) a ($/$:0) x ($]$:0) ph;

theorem sbq (a: nat) (b: wff x): $ x = a -> (b <-> [a / x] b) $ =
'(! ibid _ _ (al y _) (exp @ iald @ exp @ sylc ax_12 (eqtr4d anll anr) anlr)
  (mpi ax_6 @ eexdh nfv (nfim nfal1 nfv) @ exp @ syl5 eal @
    syld (com12 @ imim1i anr) @ syl (com12 eal) @ imp eqtr4));
theorem sbqcom (a: nat) (b: wff x): $ a = x -> ([a / x] b <-> b) $ = '(bicomd @ rsyl eqcom sbq);
theorem nfsb1 (a: nat) (b: wff x): $ F/ x [a / x] b $ =
'(!! nfal _ y (nfim nfv nfal1));
theorem nfsb (a: nat y) (b: wff x y) (h: $ F/ x b $): $ F/ x [a / y] b $ =
'(!! nfal _ z (nfim nfv (nfal (nfim nfv h))));
theorem sbeq1 (a b: nat x) (c: wff x): $ a = b -> ([a / x] c <-> [b / x] c) $ =
'(!! aleqd y @ imeq1d eqeq2);
theorem sbeq1d (G: wff x) (a b: nat x) (c: wff x) (h: $ G -> a = b $):
  $ G -> ([a / x] c <-> [b / x] c) $ = '(syl sbeq1 h);
do ((derive-eq) 'sb);
theorem sbeq2i (a: nat x) (b c: wff x) (h: $ b <-> c $):
  $ [a / x] b <-> [a / x] c $ = '(trud @ sbeq2d @ a1i h);

theorem sbeht (a: nat) (b c: wff x) (h: $ F/ x c $):
  $ A. x (x = a -> (b <-> c)) -> ([a / x] b <-> c) $ =
'(eexh (nfim nfal1 (nfbi nfsb1 h))
  (exp (bitr3d (anwl sbq) (impcom eal))) ax_6);
theorem sbeh (a: nat) (b c: wff x) (h: $ F/ x c $)
  (e: $ x = a -> (b <-> c) $): $ [a / x] b <-> c $ = '(sbeht h (ax_gen e));
theorem sbet (a: nat) (b: wff x) (c: wff):
  $ A. x (x = a -> (b <-> c)) -> ([a / x] b <-> c) $ = '(sbeht nfv);
theorem sbe (a: nat) (b: wff x) (c: wff)
  (e: $ x = a -> (b <-> c) $): $ [a / x] b <-> c $ = '(sbeh nfv e);
theorem sbed (a: nat) (b: wff x) (c: wff)
  (e: $ G /\ x = a -> (b <-> c) $): $ G -> ([a / x] b <-> c) $ =
'(syl sbet @ iald @ exp e);
theorem dfsb2 (a: nat) (b: wff x): $ [a / x] b <-> A. x (x = a -> b) $ =
'(! ibii (al y _) _
  (mpi ax_6 @ eexdh nfal1 nfv @ syl (a2i @ alimd @ imim1d @ com12 eqtr4) eal)
  (iald @ com12 @ alimd @ imim1d @ com12 eqtr));
theorem dfsb3 (a: nat) (b: wff x): $ [a / x] b <-> E. x (x = a /\ b) $ =
'(sbeh nfex1 @ syl con2b @ syl5bb (bitr4 (aleqi notan2) dfsb2) @ bicomd sbq);
theorem sbco (a: nat x) (b: wff x):
  $ [a / y] [y / x] b <-> [a / x] b $ = '(bitr dfsb2 (aleqi (imeq2i dfsb2)));
theorem sbid (a: wff x): $ [x / x] a <-> a $ =
'(! ibii (al y _) _
  (mpi ax_6 @ eexdh nfal1 nfv @ rsyl eal @ a2i @ rsyl eqcom @ com12 eal)
  (iald @ com12 @ bi1d @ syl6bb dfsb2 @ syl sbq eqcom));
theorem sbth (a: nat x) (p: wff x) (h: $ p $): $ [a / x] p $ =
'(!! ax_gen y @ a1i @ ax_gen @ a1i h);
theorem sbthd (p: wff x) (h: $ G /\ x = a -> p $): $ G -> [a / x] p $ =
'(mpbiri tru @ sbed @ syl (mpi tru bith) h);
theorem sbeth (p: wff x) (e: $ x = a -> (p <-> q) $) (h: $ p $): $ q $ =
'(mpbi (sbe e) @ sbth h);
theorem sbethh (p q: wff x) (h: $ F/ x q $)
  (e: $ x = a -> (p <-> q) $) (hp: $ p $): $ q $ =
'(mpbi (sbeh h e) @ sbth hp);
theorem cbvsbh (a: nat) (p q: wff x y) (h1: $ F/ y p $) (h2: $ F/ x q $)
  (e: $ x = y -> (p <-> q) $): $ [a / x] p <-> [a / y] q $ =
'(!! aleqi z (imeq2i (cbvalh (nfim nfv h1) (nfim nfv h2) (imeqd (eqeq1) e))));
theorem cbvsb (a: nat) (p: wff x) (q: wff y)
  (e: $ x = y -> (p <-> q) $): $ [a / x] p <-> [a / y] q $ = '(cbvsbh nfv nfv e);

theorem aleqe (a: nat) (p: wff x) (q: wff)
  (e: $ x = a -> (p <-> q) $): $ A. x (x = a -> p) <-> q $ = '(bitr3 dfsb2 @ sbe e);
theorem exeqe (a: nat) (p: wff x) (q: wff)
  (e: $ x = a -> (p <-> q) $): $ E. x (x = a /\ p) <-> q $ = '(bitr3 dfsb3 @ sbe e);
theorem cbvals (p: wff x): $ A. x p <-> A. y ([y / x] p) $ = '(cbvalh nfv nfsb1 sbq);
theorem cbvexs (p: wff x): $ E. x p <-> E. y ([y / x] p) $ = '(cbvexh nfv nfsb1 sbq);
theorem cbvald (G) (p: wff x) (q: wff y)
  (h: $ G /\ x = y -> (p <-> q) $): $ G -> (A. x p <-> A. y q) $ =
'(bitrd (a1i cbvals) (aleqd @ syl sbet @ iald @ exp h));
theorem cbvexd (G) (p: wff x) (q: wff y)
  (h: $ G /\ x = y -> (p <-> q) $): $ G -> (E. x p <-> E. y q) $ =
'(bitrd (a1i cbvexs) (exeqd @ syl sbet @ iald @ exp h));

-- FOL mode: a natural deduction language that compiles to MM0 peano axioms
do {
  (def folmode-context (ref!))

  -- (folmode) initializes the FOL goal state from the MM0 goal state.
  -- For example, if the initial state is
  --   h1: G -> a
  --   h2: G -> b
  --   |- G /\ c -> a /\ b
  -- then the generated FOL state will be
  --   h1: a
  --   h2: b
  --   _h0: c
  --   |- a /\ b
  --
  -- The context is populated with all the MM0 hypotheses, as well as all
  -- antecedents of the goal implication, except for a leftmost variable called
  -- G or _G. The antecedents can be named using arguments to (folmode); for
  -- example (folmode 'hc _) produces
  --   h1: a
  --   h2: b
  --   hc: c
  --   |- a /\ b
  -- instead.
  --
  -- The last argument to folmode is a refine script that is passed to (folrefine).
  (def (folmode . vs)
    @ match (match (split-last vs) [() (#undef)] [r r]) @ (r . vs)
    (set! folmode-context
      (def vs (ref! vs))
      @ rmap (get-goals) @ fn (g)
      (def t (goal-type g))
      @ match (match t [('im G R) (list G R)] [_ (list #undef t)]) @ (G rhs)
      (def hs1 (rmap (local-ctx) @ fn (h)
        (def t (infer-type h))
        @ if (undef? G) '(,h (,t ,h))
        @ match t
          [('im L R) (=> break)
            @ letrec ([upgrade @ match-fn
              [(? (fn (G) {L == G})) h]
              [('an G1 D) '(anwl ,G1 ,D ,R ,(upgrade G1))]
              [_ (break)]])
            '(,h (,R ,(upgrade G)))]
          [_ '(,h (,t (a1i ,G ,t ,h)))]))
      (def hs
        @ if (undef? G) hs1
        @ letrec ([add-locals @ match-fn*
          [(('an G D) left)
            (def hsG (add-locals G left))
            (def hsD (add-locals D #f))
            @ fn (f hs)
            @ hsG (fn (v a p) (f v a '(anwl ,G ,D ,a ,p)))
            @ hsD (fn (v a p) (f v a '(anwr ,G ,D ,a ,p))) hs]
          [((or 'G '_G) #t) @ fn (f hs) (append hs1 hs)]
          [(a _)
            (def v @ match vs
              [(v . vs2) (set! vs vs2) v]
              [_
                (def n @ if (number? vs) vs 0)
                (set! vs {n + 1})
                (atom-app "_h" n)])
            @ fn (f hs) '(,(f v a '(id ,a)) . ,hs)]])
        ((add-locals G #t) (fn (v a p) '(,v (,a ,p))) ()))
      (list G (apply atom-map! hs) (rev @ map hd hs) rhs g))
    (set-close-fn folmode-end)
    (folrefine r))

  -- (folmode-pp-goal g) converts the FOL goal g to a string.
  (def folmode-pp-goal @ match-fn @ (G hm hs t g)
    (def ss @ foldr hs "" @ fn (v acc)
      @ match (lookup hm v)
      [(e _) (string-append acc (->string v) ": " (pp e) "\n")]
      [#undef acc])
    (string-append ss "|- " (pp t) "\n"))

  -- (folstat-str) returns the FOL goals as a string, or #undef if there are no goals.
  (def (folstat-str)
    @ match (apply append @ map (fn (g) (list "\n" (folmode-pp-goal g))) folmode-context)
    [()]
    [(_ . gs) @ apply string-append gs])

  -- (folstat) is the analogue of (stat) for the FOL goal state.
  (def (folstat)
    (def s (folstat-str))
    (if (def? s) (display s)))

  -- Resets the MM0 goals using the FOL goals.
  (def (folmode-reset-goals)
    (apply set-goals @ map (fn (g) (nth 4 g)) folmode-context))

  -- Closer for the FOL mode - prints all the FOL goals that have not been closed
  -- (and suppresses MM0 goal printing).
  (def (folmode-end)
    (scan folmode-context @ fn (g)
      (error-at (nth 4 g) @ folmode-pp-goal g))
    @ if (not (null? folmode-context)) @ begin
    (error @ string-append "not all goals are solved\n" (folstat-str)))

  -- (folrefine) runs a refine script in FOL mode. This is similar to (refine) but
  -- includes operations for manipulating the context using lambda-calculus
  -- inspired proof terms.
  --
  -- * If `h` is in the context, then `h` applies it to solve the goal.
  -- * A `_` in the term generates a new subgoal.
  -- * `(ian p1 p2 ... pn)` proves |- a1 /\ a2 /\ ... /\ an if pi proves |- ai.
  -- * `(iim x1 ... xn p)` proves |- a1 -> a2 -> ... -> an -> b if
  --   p is a proof of x1: a1, x2: a2, ..., xn: an |- b .
  -- * `(:base p)` provides `p` as an MM0 refine script.
  -- * `(p p1 ... pn)` proves `b` if `p: a1 -> a2 -> ... -> an -> b` and pi: ai.
  (def (folrefine . rs)
    (def newgs (ref! ()))
    (def (push . a) @ set! newgs @ cons a @ get! newgs)
    (def (im2 G e) @ if (def? G) '(im ,G ,e) e)
    @ letrec ([((folref G hm hs p) refine tgt)
      (def (im e) (im2 G e))
      (def rhs (match tgt [('im _ e) e] [_ tgt]))
      (def (app sp p ps)
        @ match (lookup hm p)
          [(t pr)
            (def mp (if (def? G) 'mpd 'ax_mp))
            @ copy-span sp @ foldl ps
              (copy-span p '{(:verb ,pr) : (:verb ,(im t))})
              (fn (acc p2) (list mp acc (folref G hm hs p2)))]
          [#undef (error-at p "unimplemented") (copy-span p '?)])
      (def out @ match p
        [('ian p1 . ps)
          (def ian (if (def? G) 'iand 'ian))
          @ foldl ps (folref G hm hs p1) @ fn (acc p2)
          @ copy-span p (list ian acc (folref G hm hs p2))]
        [('iim . ps)
          @ letrec ([(iim G hm hs ps rhs) @ match ps
            [(p) (folref G hm hs p)]
            [(x . ps2)
              @ match (match rhs
                [('im D rhs2) (list D rhs2)]
                [_ (list (copy-span x (mvar! 'wff #f)) (mvar! 'wff #f))])
                @ (D rhs2)
              (def G2 @ if (def? G) '(an ,G ,D) D)
              (def hm2 @ apply atom-map! @ rmap (rev hs) @ if (def? G)
                (fn (h) @ match (lookup hm h) [(R pr) '(,h (,R (anwl ,G ,D ,R ,pr)))])
                (fn (h) @ match (lookup hm h) [(R pr) '(,h (,R (a1i ,D ,R ,pr)))]))
              (def hs2 @ match x ['_ hs] @ _
                (insert! hm2 x @ list D @ if (def? G) '(anr ,G ,D) '(id ,D))
                (cons x hs))
              '{(exp ,(iim G2 hm2 hs2 ps2 rhs2)) : ,(im2 G '(im ,D ,rhs2))}]
            [_ (error-at p "expected > 1 argument") (copy-span p '?)]])
          (iim G hm hs ps rhs)]
        [(or '_ ('_))
          (def g (goal! p tgt))
          (push G hm hs rhs g)
          '(:verb ,g)]
        [(? atom?) (app p p ())]
        [(':base p) p]
        [((? atom? p1) . ps) (app p p1 ps)])
      (refine tgt out)])
    (def oldgs (ref! @ get! folmode-context))
    (apply refine @ rmap rs @ match-fn
      [#undef]
      [e @ match oldgs
        [((G hm hs _ _) . gs) (set! oldgs gs) (folref G hm hs e)]
        [_ (error "no more goals")]])
    (set! folmode-context @ append (rev newgs) oldgs)
    (folmode-reset-goals))
};

strict sort set;
term ab {x: nat} (p: wff x): set;
notation ab {x: nat} (p: wff x): set = (${$:max) x ($|$:0) p ($}$:0);
term el (a: nat) (A: set): wff; infixl el: $e.$ prec 50;
axiom elab (a: nat) {x: nat} (p: wff x):
  $ a e. {x | p} <-> [a / x] p $;
axiom ax_8 (a b: nat) (A: set): $ a = b -> a e. A -> b e. A $;

def eqs (A B: set) {.x: nat}: wff = $ A. x (x e. A <-> x e. B) $;
infixl eqs: $==$ prec 50;

theorem eqsid: $ A == A $ = '(!! ax_gen x biid);
theorem eqscom: $ A == B -> B == A $ = '(!! alimi x bicom);
theorem eqscomb: $ A == B <-> B == A $ = '(ibii eqscom eqscom);
theorem eqstr: $ A == B -> B == C -> A == C $ = '(syl ax_4 @ !! alimi x bitr);
theorem eqstr2: $ A == B -> B == C -> C == A $ = '(syl6 eqscom eqstr);
theorem eqstr3: $ B == A -> B == C -> A == C $ = '(syl eqstr eqscom);
theorem eqstr4: $ A == B -> C == B -> A == C $ = '(syl5 eqscom eqstr);
theorem eqstr3d (h1: $ G -> B == A $) (h2: $ G -> B == C $): $ G -> A == C $ = '(sylc eqstr3 h1 h2);
theorem eqsidd (G A): $ G -> A == A $ = '(a1i eqsid);
theorem eqscomd (h: $ G -> A == B $): $ G -> B == A $ = '(syl eqscom h);
theorem eqstrd (h1: $ G -> A == B $) (h2: $ G -> B == C $): $ G -> A == C $ = '(sylc eqstr h1 h2);
theorem eqstr4d (h1: $ G -> A == B $) (h2: $ G -> C == B $): $ G -> A == C $ = '(sylc eqstr4 h1 h2);
theorem syl5eqs (h1: $ A == B $) (h2: $ G -> B == C $): $ G -> A == C $ = '(eqstrd (a1i h1) h2);
theorem syl5eqsr (h1: $ B == A $) (h2: $ G -> B == C $): $ G -> A == C $ = '(eqstr3d (a1i h1) h2);
theorem syl6eqs (h1: $ B == C $) (h2: $ G -> A == B $): $ G -> A == C $ = '(eqstrd h2 (a1i h1));
theorem syl6eqsr (h1: $ C == B $) (h2: $ G -> A == B $): $ G -> A == C $ = '(eqstr4d h2 (a1i h1));
theorem eqstr3g (h1: $ A == C $) (h2: $ B == D $) (h: $ G -> A == B $):
  $ G -> C == D $ = '(syl5eqsr h1 @ syl6eqs h2 h);
theorem eqstr4g (h1: $ C == A $) (h2: $ D == B $) (h: $ G -> A == B $):
  $ G -> C == D $ = '(syl5eqs h1 @ syl6eqsr h2 h);

theorem eleq1: $ a = b -> (a e. A <-> b e. A) $ = '(ibid ax_8 @ syl ax_8 eqcom);
theorem eleq2: $ A == B -> (a e. A <-> a e. B) $ = '(!! eale x @ bieqd eleq1 eleq1);
theorem eleq1d (h: $ G -> a = b $): $ G -> (a e. A <-> b e. A) $ = '(syl eleq1 h);
theorem eleq2d (h: $ G -> A == B $): $ G -> (a e. A <-> a e. B) $ = '(syl eleq2 h);
@(register-eqd 'el) theorem eleqd (G a b A B) (h1: $ G -> a = b $) (h2: $ G -> A == B $):
  $ G -> (a e. A <-> b e. B) $ = '(bitrd (eleq1d h1) (eleq2d h2));
do ((derive-eq) 'eqs);

theorem abeq (p q: wff x): $ A. x (p <-> q) -> {x | p} == {x | q} $ =
'(!! iald y @ bitr4g elab elab @ ealeh (nfbi nfsb1 nfsb1) (bieqd sbq sbq));
@(register-eqd 'ab) theorem abeqd (G) {x} (p q: wff x)
  (h: $ G -> (p <-> q) $): $ G -> {x | p} == {x | q} $ = '(syl abeq @ iald h);
theorem abeqi (p q: wff x) (h : $ p <-> q $): $ {x | p} == {x | q} $ = '(trud @ abeqd @ a1i h);
theorem eqri {x} (h: $ x e. A <-> x e. B $): $ A == B $ = '(ax_gen h);
theorem eqrd (G) {x} (h: $ G -> (x e. A <-> x e. B) $): $ G -> A == B $ = '(iald h);
theorem cbvabh (p q: wff x y) (h1: $ F/ y p $) (h2: $ F/ x q $)
  (e: $ x = y -> (p <-> q) $): $ {x | p} == {y | q} $ =
'(!! eqri z @ bitr4gi elab elab @ cbvsbh h1 h2 e);
theorem cbvab (p: wff x) (q: wff y)
  (e: $ x = y -> (p <-> q) $): $ {x | p} == {y | q} $ = '(cbvabh nfv nfv e);
theorem cbvabs (p: wff x): $ {x | p} == {y | [y / x] p} $ = '(cbvabh nfv nfsb1 sbq);
theorem cbvabd (G) (p: wff x) (q: wff y)
  (h: $ G /\ x = y -> (p <-> q) $): $ G -> {x | p} == {y | q} $ =
'(eqstrd (a1i cbvabs) @ abeqd @ syl sbet @ iald @ exp h);
theorem elab2 (a: nat x) (p: wff x): $ a e. {x | p} <-> [a / x] p $ =
'(bitr (bitr (eleq2 (cbvabh nfv nfsb1 sbq)) elab) (!! sbco x y));
theorem elabe (a: nat) (p: wff x) (q: wff)
  (e: $ x = a -> (p <-> q) $): $ a e. {x | p} <-> q $ = '(bitr elab2 (sbe e));
theorem elabed (a: nat) (p: wff x) (q: wff)
  (e: $ G /\ x = a -> (p <-> q) $): $ G -> (a e. {x | p} <-> q) $ =
'(syl5bb elab2 @ sbed e);
theorem eelabd (a: nat x) (p: wff x) (q: wff)
  (h: $ G -> p -> q $): $ G -> a e. {x | p} -> q $ =
(named '(syl5 (sylibr (cbvexh nfv nfsb1 sbq) @ iexe @ syl6bbr elab2 sbeq1) (eexd h)));
theorem abid (p: wff x): $ x e. {x | p} <-> p $ = '(bitr elab2 sbid);
theorem abid2: $ {x | x e. A} == A $ = '(!! eqri y @ elabe eleq1);

@(derive-eq 'ss) def subset (A B: set): wff = $ A. x (x e. A -> x e. B) $;
infixl subset: $C_$ prec 50;

theorem dfss: $ A C_ B <-> A. x (x e. A -> x e. B) $ =
'(!! cbval y _ @ imeqd eleq1 eleq1);
theorem ssel: $ A C_ B -> a e. A -> a e. B $ = '(!! eale x @ imeqd eleq1 eleq1);
theorem sseld (h1: $ G -> A C_ B $) (h2: $ G -> a e. A $): $ G -> a e. B $ = '(sylc ssel h1 h2);
theorem ssid: $ A C_ A $ = '(!! ax_gen x id);
theorem sstr: $ A C_ B -> B C_ C -> A C_ C $ =
'(exp @ !! iald x @ syld (anwl ssel) (anwr ssel));
theorem eqss: $ A == B -> A C_ B $ = '(mpbii ssid sseq2);
theorem eqssr: $ A == B -> B C_ A $ = '(mpbii ssid sseq1);
theorem ssasym: $ A C_ B -> B C_ A -> A == B $ = '(!! al2imi x ian);
theorem ssasymd (h1: $ G -> A C_ B $) (h2: $ G -> B C_ A $): $ G -> A == B $ = '(sylc ssasym h1 h2);

@(derive-eq 'in) def Inter (A B: set): set = $ {x | x e. A /\ x e. B} $;
infixl Inter: $i^i$ prec 70;

theorem elin: $ a e. A i^i B <-> a e. A /\ a e. B $ = '(!! elabe x @ aneqd eleq1 eleq1);

theorem incom: $ A i^i B == B i^i A $ = '(!! eqri x @ bitr elin @ bitr4 ancomb elin);

theorem inss1: $ A i^i B C_ A $ = '(!! ax_gen x @ sylbi elin anl);
theorem inss2: $ A i^i B C_ B $ = '(mpbi (sseq1 incom) inss1);
theorem ssin: $ A C_ B i^i C <-> A C_ B /\ A C_ C $ =
'(ibii (iand (mpi inss1 sstr) (mpi inss2 sstr)) @
  !! iald x @ exp @ sylibr elin @ iand (sseld anll anr) (sseld anlr anr));
theorem ssin1: $ A C_ B -> A i^i C C_ B i^i C $ = '(sylibr ssin @ iand (sstr inss1) (a1i inss2));
theorem ssin2: $ B C_ C -> A i^i B C_ A i^i C $ = '(sylibr ssin @ iand (a1i inss1) (sstr inss2));

theorem eqin1: $ A C_ B <-> A i^i B == A $ =
'(ibii (ssasymd (a1i inss1) @ sylibr ssin @ iand (a1i ssid) id) (mpbii inss2 sseq1));
theorem eqin2: $ A C_ B <-> B i^i A == A $ = '(bitr eqin1 @ eqseq1 incom);

@(derive-eq 'un) def Union (A B: set): set = $ {x | x e. A \/ x e. B} $;
infixl Union: $u.$ prec 65;

theorem elun: $ a e. A u. B <-> a e. A \/ a e. B $ = '(!! elabe x @ oreqd eleq1 eleq1);
theorem uncom: $ A u. B == B u. A $ = '(!! eqri x @ bitr elun @ bitr4 orcomb elun);

theorem ssun1: $ A C_ A u. B $ = '(!! ax_gen x @ sylibr elun orl);
theorem ssun2: $ B C_ A u. B $ = '(mpbi (sseq2 uncom) ssun1);
theorem unss: $ A u. B C_ C <-> A C_ C /\ B C_ C $ =
'(ibii (iand (sstr ssun1) (sstr ssun2)) @
  !! iald x @ syl5bi elun @ eord (anwl ssel) (anwr ssel));

theorem equn1: $ A C_ B <-> A u. B == B $ =
'(ibii (ssasymd (sylibr unss @ iand id (a1i ssid)) (a1i ssun2)) (mpbii ssun1 sseq2));
theorem equn2: $ A C_ B <-> B u. A == B $ = '(bitr equn1 @ eqseq1 uncom);

@(derive-eq 'cpl) def Compl (A: set): set = $ {x | ~x e. A} $;

theorem elcpl: $ a e. Compl A <-> ~a e. A $ = '(!! elabe x @ noteqd eleq1);

theorem sscpl: $ B C_ A <-> Compl A C_ Compl B $ =
'(!! aleqi x @ bitr4 con3bi @ imeqi elcpl elcpl);
theorem cplcpl: $ Compl (Compl A) == A $ =
'(!! eqri x @ bitr elcpl @ bitr4 (noteq elcpl) notnot);
theorem cplinj: $ A == B <-> Compl A == Compl B $ =
'(ibii cpleq @ sylib (eqseq cplcpl cplcpl) cpleq);
theorem cplin: $ Compl (A i^i B) == Compl A u. Compl B $ =
'(!! eqri x @ bitr elcpl @ bitr4 (noteq elin) @ bitr elun @ bitr4 (oreq elcpl elcpl) notan);
theorem cplun: $ Compl (A u. B) == Compl A i^i Compl B $ =
'(eqstr (cpleq @ eqstr2 cplin @ uneq cplcpl cplcpl) cplcpl);

def Univ: set = $ {x | T.} $; prefix Univ: $_V$ prec max;

theorem elv: $ a e. _V $ = '(mpbir (!! elabe x biidd) tru);
theorem inv1: $ _V i^i A == A $ = '(!! eqri x @ bitr elin @ bian1 elv);
theorem inv2: $ A i^i _V == A $ = '(eqstr incom inv1);
theorem uncpl: $ A u. Compl A == _V $ =
'(!! eqri x @ bith (mpbir elun @ mpbir (oreq2i elcpl) em) elv);

local def nfs {x: nat} (A: set x): wff = $ A. y (F/ x y e. A) $;
prefix nfs: $FS/$ prec 10;
local def nfn {x: nat} (a: nat x): wff = $ A. y (F/ x y = a) $;
prefix nfn: $FN/$ prec 10;

theorem nfsbid (G) {x} (A B: set x) (h: $ G -> A == B $):
  $ G -> ((FS/ x A) <-> (FS/ x B)) $ = '(!! aleqd y @ nfeqd @ eleq2d h);
theorem nfnbid (G) {x} (a b: nat x) (h: $ G -> a = b $):
  $ G -> ((FN/ x a) <-> (FN/ x b)) $ = '(!! aleqd y @ nfeqd @ eqeq2d h);
theorem nfsv: $ FS/ x A $ = '(!! ax_gen y nfv);
theorem nfnv: $ FN/ x a $ = '(!! ax_gen y nfv);
theorem nfsri {x y} (A: set x) (h: $ F/ x y e. A $): $ FS/ x A $ = '(ax_gen h);
theorem nfnri {x y} (a: nat x) (h: $ F/ x y = a $): $ FN/ x a $ = '(ax_gen h);
theorem nfel2 (a: nat) (A: set x) (h: $ FS/ x A $): $ F/ x a e. A $ = '(!! eale y (nfeqd eleq1) h);
theorem nf_eq (a b: nat x) (h1: $ FN/ x a $) (h2: $ FN/ x b $): $ F/ x a = b $ =
'(nfx (bicom @ !! exeqe y eqeq1) (nfex @ nfan (eal h1) (eal h2)));
theorem nfeq2 (b: nat x) (h: $ FN/ x b $): $ F/ x a = b $ = '(nf_eq nfnv h);
theorem nfsb1h (a: nat x) (b: wff x) (h: $ FN/ x a $): $ F/ x [a / x] b $ =
'(!! nfal _ z (nfim (nfeq2 h) nfal1));
theorem nfsbh (a: nat x y) (b: wff x y) (h1: $ FN/ x a $) (h2: $ F/ x b $): $ F/ x [a / y] b $ =
'(!! nfal _ z (nfim (nfeq2 h1) (nfal (nfim nfv h2))));
theorem nfel (a: nat x) (A: set x) (h1: $ FN/ x a $) (h2: $ FS/ x A $): $ F/ x a e. A $ =
'(nfx (bicom @ !! exeqe y eleq1) (nfex @ nfan (eal h1) (eal h2)));
theorem nfab1 (p: wff x): $ FS/ x {x | p} $ = '(!! nfsri _ y @ nfx elab nfsb1);
theorem nfab (p: wff x y) (h: $ F/ x p $): $ FS/ x {y | p} $ = '(!! nfsri _ z @ nfx elab @ nfsb h);
theorem nfeqs (A B: set x) (h1: $ FS/ x A $) (h2: $ FS/ x B $): $ F/ x A == B $ =
'(!! nfal _ y @ nfbi (nfel2 h1) (nfel2 h2));
theorem nfnx (a b: nat x) (h1: $ a = b $) (h2: $ FN/ x b $): $ FN/ x a $ =
'(!! nfnri _ y @ nfx (eqeq2 h1) @ nfeq2 h2);
theorem nfin (A B: set x) (h1: $ FS/ x A $) (h2: $ FS/ x B $): $ FS/ x A i^i B $ =
'(!! nfab _ y @ nfan (nfel2 h1) (nfel2 h2));
theorem nfss (A B: set x) (h1: $ FS/ x A $) (h2: $ FS/ x B $): $ F/ x A C_ B $ =
'(!! nfal _ y @ nfim (nfel2 h1) (nfel2 h2));

theorem abeqb (p q: wff x): $ A. x (p <-> q) <-> {x | p} == {x | q} $ =
'(ibii abeq (ialdh (nfeqs nfab1 nfab1) (sylib (bieq abid abid) eleq2)));
theorem eqab2d (p: wff x) (h: $ G -> (x e. A <-> p) $): $ G -> A == {x | p} $ =
'(sylib (!! cbvalh _ y nfv (nfbi nfv @ nfel2 nfab1) @ bieqd eleq1 @ syl5bbr abid eleq1) (iald h));
theorem eqab2i (p: wff x) (h: $ x e. A <-> p $): $ A == {x | p} $ = '(trud @ eqab2d @ a1i h);
theorem eqab1d (p: wff x) (h: $ G -> (p <-> x e. A) $): $ G -> {x | p} == A $ = '(eqscomd @ eqab2d @ bicomd h);
theorem eqab1i (p: wff x) (h: $ p <-> x e. A $): $ {x | p} == A $ = '(trud @ eqab1d @ a1i h);
theorem ssab (p q: wff x): $ A. x (p -> q) <-> {x | p} C_ {x | q} $ =
'(!! cbvalh _ y nfv (nfim (nfel2 nfab1) (nfel2 nfab1)) @
  imeqd (syl6bbr elab sbq) (syl6bbr elab sbq));
theorem ssab1 (p: wff x): $ A. x (p -> x e. A) <-> {x | p} C_ A $ =
'(!! cbvalh _ y nfv (nfim (nfel2 nfab1) nfv) @ imeqd (syl6bbr elab sbq) eleq1);
theorem ssab2 (p: wff x): $ A. x (x e. A -> p) <-> A C_ {x | p} $ =
'(!! cbvalh _ y nfv (nfim nfv (nfel2 nfab1)) @ imeqd eleq1 (syl6bbr elab sbq));

def sbs (a: nat) {x .y: nat} (A: set x): set = $ {y | [a / x] y e. A} $;
notation sbs (a: nat) {x: nat} (A: set x): set =
  ($S[$:99) a ($/$:0) x ($]$:0) A;

theorem elsbs (a: nat x) (b: nat) (A: set x): $ b e. S[a / x] A <-> [a / x] b e. A $ =
'(bitr (!! elab y) @ sbe @ sbeq2d eleq1);
theorem sbsq (a: nat) (A: set x): $ x = a -> A == S[a / x] A $ =
'(!! eqrd y @ syl6bbr elsbs sbq);
theorem nfsbs1h (a: nat x) (A: set x) (h: $ FN/ x a $): $ FS/ x S[a / x] A $ =
'(!! nfsri _ y (nfx elsbs @ nfsb1h h));
theorem nfsbs1 (a: nat) (A: set x): $ FS/ x S[a / x] A $ =
'(nfsbs1h nfnv);
theorem nfsbsh (a: nat x) (A: set x y) (h1: $ FN/ x a $) (h2: $ FS/ x A $): $ FS/ x S[a / y] A $ =
'(!! nfsri _ z @ nfx elsbs @ nfsbh h1 @ nfel2 h2);
theorem nfsbs (a: nat) (A: set x y) (h: $ FS/ x A $): $ FS/ x S[a / y] A $ = '(nfsbsh nfnv h);
theorem sbseq1d (G) (a b: nat) (A: set x) (h: $ G -> a = b $):
  $ G -> S[a / x] A == S[b / x] A $ = '(!! abeqd y (sbeq1d h));
theorem sbseq2d (G) (a: nat x) (A B: set x)
  (h: $ G -> A == B $): $ G -> S[a / x] A == S[a / x] B $ =
'(!! abeqd y (sbeq2d (eleq2d h)));
@(register-eqd 'sbs) theorem sbseqd (G) {x} (a b: nat) (A B: set x)
  (h1: $ G -> a = b $) (h2: $ G -> A == B $):
  $ G -> S[a / x] A == S[b / x] B $ = '(eqstrd (sbseq1d h1) (sbseq2d h2));
theorem sbseht (a: nat) (A B: set x) (h: $ FS/ x B $):
  $ A. x (x = a -> A == B) -> S[a / x] A == B $ =
'(!! eqrd y @ syl5bb elsbs @ syl (sbeht @ nfel2 h) @ alimi @ imim2 eleq2);
theorem sbsco (a: nat) (A: set x): $ S[a / y] S[y / x] A == S[a / x] A $ =
'(!! abeqi z @ bitr (sbeq2i elsbs) sbco);
theorem sbseh (a: nat) (A B: set x) (h: $ FS/ x B $)
  (e: $ x = a -> A == B $): $ S[a / x] A == B $ = '(sbseht h (ax_gen e));
theorem sbset (a: nat) (A: set x) (B: set):
  $ A. x (x = a -> A == B) -> S[a / x] A == B $ = '(sbseht nfsv);
theorem sbse (a: nat) (A: set x) (B: set)
  (e: $ x = a -> A == B $): $ S[a / x] A == B $ = '(sbseh nfsv e);
theorem sbsed (a: nat) (A: set x) (B: set)
  (e: $ G /\ x = a -> A == B $): $ G -> S[a / x] A == B $ =
'(syl sbset @ iald @ exp e);
theorem sbsid (a: set x): $ S[x / x] A == A $ =
'(!! eqri y @ bitr elsbs sbid);

@_ local def eu {x: nat} (p: wff x): wff = $ E. y A. x (p <-> x = y) $;

term d0: nat; prefix d0: $0$ prec max;
term suc (n: nat): nat;

def d1:  nat = $suc 0$; prefix d1:  $1$  prec max;
def d2:  nat = $suc 1$; prefix d2:  $2$  prec max;
def d3:  nat = $suc 2$; prefix d3:  $3$  prec max;
def d4:  nat = $suc 3$; prefix d4:  $4$  prec max;
def d5:  nat = $suc 4$; prefix d5:  $5$  prec max;
def d6:  nat = $suc 5$; prefix d6:  $6$  prec max;
def d7:  nat = $suc 6$; prefix d7:  $7$  prec max;
def d8:  nat = $suc 7$; prefix d8:  $8$  prec max;
def d9:  nat = $suc 8$; prefix d9:  $9$  prec max;
def d10: nat = $suc 9$; prefix d10: $10$ prec max;

axiom peano1 (a: nat): $ suc a != 0 $;
axiom peano2 (a b: nat): $ suc a = suc b <-> a = b $;
axiom peano5 {x: nat} (ph: wff x):
  $ [0 / x] ph -> A. x (ph -> [suc x / x] ph) -> A. x ph $;

theorem d1ne0: $ 1 != 0 $ = 'peano1;
theorem d2ne0: $ 2 != 0 $ = 'peano1;
theorem suceq: $ a = b -> suc a = suc b $ = '(bi2 peano2);
@(register-eqd 'suc) theorem suceqd
  (h: $ G -> a = b $): $ G -> suc a = suc b $ = '(syl suceq h);

theorem ind {x y} (a: nat y) (px: wff x) (p0 pa py ps: wff y)
  (h0: $ x = 0 -> (px <-> p0) $)
  (hy: $ x = y -> (px <-> py) $)
  (hs: $ x = suc y -> (px <-> ps) $)
  (ha: $ x = a -> (px <-> pa) $)
  (h1: $ p0 $) (h2: $ py -> ps $): $ pa $ =
'(eale ha @ peano5
  (mpbir (sbe h0) h1)
  (mpbir (cbvalh nfv (nfim nfv nfsb1) @ imeqd hy @ sbeq1d suceq)
    (ax_gen @ rsyl h2 @ bi2i @ sbe hs)));

theorem indd (G) {x y} (a: nat y) (px: wff x) (p0 pa py ps: wff y)
  (h0: $ x = 0 -> (px <-> p0) $)
  (hy: $ x = y -> (px <-> py) $)
  (hs: $ x = suc y -> (px <-> ps) $)
  (ha: $ x = a -> (px <-> pa) $)
  (h1: $ G -> p0 $) (h2: $ G /\ py -> ps $): $ G -> pa $ =
'(ind (imeq2d h0) (imeq2d hy) (imeq2d hs) (imeq2d ha) h1 (a2i (exp h2)));

-- This is a simple macro for inductive proofs like `ind` and `indd` that
-- require 4 identical substitution proofs in the first few slots
do (def (mk-ind a h . xs) (append a @ cons h h h h xs));

theorem sucne0: $ a = suc b -> a != 0 $ = '(mpbiri peano1 neeq1);
theorem exsuc (a: nat): $ a != 0 <-> E. x a = suc x $ =
'(ibii
  (! ind y z _ $ y != 0 -> E. x y = suc x $ _ _ _ _
    (imeqd (noteqd eqeq1) (exeqd eqeq1)) (imeqd (noteqd eqeq1) (exeqd eqeq1))
    (imeqd (noteqd eqeq1) (exeqd eqeq1)) (imeqd (noteqd eqeq1) (exeqd eqeq1))
    (absurdr eqid) (a1i (a1i (iexe (eqeq2d suceq) eqid))))
  (eex sucne0));

term the (A: set): nat;
axiom theid {x: nat} (A: set) (a: nat): $ A == {x | x = a} -> the A = a $;
axiom the0 {x y: nat} (A: set): $ ~E. y A == {x | x = y} -> the A = 0 $;

@(register-eqd 'the) theorem theeqd (G A B)
  (h: $ G -> A == B $): $ G -> the A = the B $ =
'(! casesd _ $ E. y A == {x | x = y} $ _
  (eexda @ eqtr4d (anwr theid) @ syl theid @ imp @ syl eqstr3 h)
  (exp @ eqtr4d (anwr the0) @ syl the0 @ impbi @ noteqd @ exeqd @ eqseq1d h));
theorem eqthed {x} (h: $ G -> (x e. A <-> x = a) $): $ G -> the A = a $ =
'(syl (!! theid z) @ eqrd @ syl6bbr (elabe eqeq1) h);
theorem eqtheabd (p: wff x) (h: $ G -> (p <-> x = a) $): $ G -> the {x | p} = a $ =
'(!! eqthed y @ syl5bb elab @
  rsyl (iald h) @ ealeh (nfbi nfsb1 nfv) @ bieqd sbq eqeq1);

theorem eqthe0d {x} (h: $ G -> x e. A -> x = 0 $): $ G -> the A = 0 $ =
(focus
  '(casesd (eexda _) (a1i (!! the0 y x)))
  '(syl theid @ eqstrd anr @ syl (abeqd eqeq2) _)
  '(mpd (mpbiri (mpbir (elabe eqeq1) eqid) (anwr eleq2)) (anwl h)));
theorem eqthe0abd (p: wff x) (h: $ G -> p -> x = 0 $): $ G -> the {x | p} = 0 $ =
'(!! eqthe0d y @ syl5bi elab @
  rsyl (iald h) @ ealeh (nfim nfsb1 nfv) @ imeqd sbq eqeq1);

theorem eqtheb: $ a = the A <-> (A == {x | x = a} \/ ~E. y A == {x | x = y} /\ a = 0) $ =
'(ibii
  (casesda
    (imp @ eexdh nfv (nfor nfv @ nfan (nfnot nfex1) nfv) @ exp @ orld @ mpbird
      (syl (eqseq2d @ abeqd eqeq2) @ eqtrd anl @ anwr theid) anr)
    (orrd @ iand anr @ eqtrd anl @ anwr the0))
  (eor (eqcomd theid) (eqtrd anr @ anwl @ eqcomd the0)));

theorem nfthe (A: set x) (h: $ FS/ x A $): $ FN/ x the A $ =
'(!! nfnri _ y (nfx (!! eqtheb u v)
  (nfor (nfeqs h nfsv) (nfan (nfnot (nfex (nfeqs h nfsv))) nfv))));

-- Variation on "the" that returns an optional value.
-- theo A = suc a if A = {a} and theo A = 0 otherwise
@_ local def theo (A: set): nat = $ the {x | E. y (x = suc y /\ y e. A)} $;
theorem theoid1 {x: nat} (A: set) (a: nat): $ A == {x | x = a} -> theo A = suc a $ =
(named '(eqtheabd @ ibid
  (eexda @ eqtrd anrl @ suceqd @ sylib (elabe eqeq1) @ mpbid (eleq2d anl) anrr)
  (exp @ sylan (iexe @ aneqd (eqeq2d suceq) eleq1) anr @
    mpbiri (mpbir (elabe eqeq1) eqid) (eleq2d anl))));

theorem theo01 {x: nat} (A: set): $ ~E. y A == {x | x = y} -> theo A = 0 $ =
(named @ focus
  '(syl the0 @ con3 @ !! eex n @ sylbir (bitr abeqb @ eqseq2 @ cbvab eqeq1) @
    mpd (rsyl (eale @ bieqd (exeqd @ aneq1d eqeq1) eqeq1) @
        sylibr (cbvex @ aneqd (eqeq2d suceq) eleq1) (mpi eqid bi2)) @
      eximd @ exp @ eqab2d @ ibida _ (mpbird (eleq1d anr) (anwl anrr)))
  (have 'h '(anwll @ rsyl (alimi @ sylib eexb bi1) @ rsyl ax_11 @ alimi @
    syl (imim1i @ ian eqid) @ eale @ imeqd (aneq1d eqeq1) eqeq1))
  (def (h x) '(sylc (eale @ imeqd eleq1 @ eqeq1d suceq) h ,x))
  '(sylib peano2 @ eqtr4d ,(h 'anr) ,(h '(anwl anrr))));

theorem theoid {x: nat} (A: set) (a: nat): $ A == {x | x = a} <-> theo A = suc a $ =
(named '(ibii theoid1 @ mpd (rsyl sucne0 @ con1 theo01) @ eexda @
  eqstrd anr @ syl (abeqd eqeq2) @ sylib peano2 @ eqtr3d (anwr theoid1) anl));

theorem theo0 {x y: nat} (A: set): $ ~E. y A == {x | x = y} <-> theo A = 0 $ =
'(ibii theo01 @ con2 @ eex @ syl sucne0 theoid1);

@_ local def subsn (A: set) = $ A. x A. y (x e. A -> y e. A -> x = y) $;

theorem subsni (h: $ G -> subsn A $) (h1: $ G -> a e. A $) (h2: $ G -> b e. A $): $ G -> a = b $ =
'(mpd h2 @ mpd h1 @ mpd h @ !! ealde x @ !! ealde y @
  bi1d @ imeqd (eleq1d anlr) @ imeqd (eleq1d anr) @ eqeqd anlr anr);

theorem subsnss: $ A C_ B -> subsn B -> subsn A $ =
'(!! alimd x @ !! alimd y @ imimd ssel @ imim1d ssel);

theorem subsnsn: $ subsn {x | x = a} $ =
'(!! ax_gen u @ !! ax_gen v @ exp @
  eqtr4d (sylib (elabe eqeq1) anl) (sylib (elabe eqeq1) anr));

theorem eqsubsnd {x} (h: $ G -> x e. A -> x = a $): $ G -> subsn A $ =
'(sylc subsnss (sylib ssab2 @ iald h) @ a1i subsnsn);

theorem eqsubsnabd (p: wff x) (h: $ G -> p -> x = a $): $ G -> subsn {x | p} $ =
'(sylc subsnss (sylib ssab @ iald h) @ a1i subsnsn);

theorem subsnthe: $ subsn A -> a e. A -> the A = a $ =
(named '(exp @ eqthed @ ibida (subsni anll anr anlr) @ mpbird (eleq1d anr) anlr));

theorem subsntheo: $ subsn A -> (theo A = suc a <-> a e. A) $ =
'(syl5bbr theoid @ ibid
  (a1i @ mpbiri (mpbir (!! elabe x eqeq1) eqid) eleq2)
  (exp @ eqab2d @ ibida (subsni anll anr anlr) (mpbird (eleq1d anr) anlr)));

def sbn (a: nat) {x: nat} (b: nat x): nat = $ the {y | [a / x] y = b} $;
notation sbn (a: nat) {x: nat} (b: nat x): nat =
  ($N[$:99) a ($/$:0) x ($]$:0) b;
do { (add-eqd-thm 'sbn) (add-eq-thm 'sbn) };

theorem sbnq (a: nat) (b: nat x): $ x = a -> b = N[a / x] b $ =
'(eqcomd @ !! eqtheabd y @ bicomd sbq);
theorem nfsbn1h (a b: nat x) (h: $ FN/ x a $): $ FN/ x N[a / x] b $ =
'(nfthe @ !! nfab _ y @ nfsb1h h);
theorem nfsbn1 (a: nat) (b: nat x): $ FN/ x N[a / x] b $ =
'(nfsbn1h nfnv);
theorem nfsbnh (a b: nat x y) (h1: $ FN/ x a $) (h2: $ FN/ x b $): $ FN/ x N[a / y] b $ =
'(nfthe @ !! nfab _ z @ nfsbh h1 @ nfeq2 h2);
theorem nfsbn (a: nat) (b: nat x y) (h: $ FN/ x b $): $ FN/ x N[a / y] b $ = '(nfsbnh nfnv h);
theorem sbneq2d (G) (a b c: nat x)
  (h: $ G -> b = c $): $ G -> N[a / x] b = N[a / x] c $ =
'(theeqd @ !! cbvabd y z @ sbeq2d @ eqeqd anr @ anwl h);
theorem sbneht (a: nat) (b c: nat x) (h: $ FN/ x c $):
  $ A. x (x = a -> b = c) -> N[a / x] b = c $ =
'(!! eqtheabd y @ syl (sbeht @ nfeq2 h) @ alimi @ imim2 eqeq2);
theorem sbneh (a: nat) (b c: nat x) (h: $ FN/ x c $)
  (e: $ x = a -> b = c $): $ N[a / x] b = c $ = '(sbneht h @ ax_gen e);
theorem sbnet (a: nat) (b: nat x) (c: nat):
  $ A. x (x = a -> b = c) -> N[a / x] b = c $ = '(sbneht nfnv);
theorem sbne (a: nat) (b: nat x) (c: nat)
  (e: $ x = a -> b = c $): $ N[a / x] b = c $ = '(sbneh nfnv e);
theorem sbned (a: nat) (b: nat x) (c: nat)
  (e: $ G /\ x = a -> b = c $): $ G -> N[a / x] b = c $ = '(syl sbnet @ iald @ exp e);
theorem sbneq1 (a b c: nat x): $ a = b -> N[a / x] c = N[b / x] c $ =
'(theeqd @ !! abeqd y sbeq1);
theorem sbneq1d (G: wff x) (a b c: nat x)
  (h: $ G -> a = b $): $ G -> N[a / x] c = N[b / x] c $ = '(syl sbneq1 h);
theorem sbnid (a: nat x): $ N[x / x] a = a $ = '(trud @ !! eqtheabd y @ a1i sbid);

theorem nfnlem {y} (b: nat y) (a c: nat x)
  (e: $ y = a -> b = c $) (h: $ FN/ x a $): $ FN/ x c $ =
'(nfnx (eqcom @ sbne e) @ nfsbnh h nfnv);
theorem nfnlem2 {y z} (c: nat y z) (a b d: nat x) (e: $ y = a /\ z = b -> c = d $)
  (h1: $ FN/ x a $) (h2: $ FN/ x b $): $ FN/ x d $ =
'(nfnx (eqcom @ sbne @ sbned e) @ nfsbnh h1 @ nfsbnh h2 nfnv);

theorem nfsuc (a: nat x) (h: $ FN/ x a $): $ FN/ x suc a $ = '(!! nfnlem _ y suceq h);

term add (a b: nat): nat; infixl add: $+$ prec 64;
term mul (a b: nat): nat; infixl mul: $*$ prec 70;

axiom addeq (a b c d: nat): $ a = b -> c = d -> a + c = b + d $;
axiom muleq (a b c d: nat): $ a = b -> c = d -> a * c = b * d $;
axiom add0 (a: nat): $ a + 0 = a $;
axiom addS (a b: nat): $ a + suc b = suc (a + b) $;
axiom mul0 (a: nat): $ a * 0 = 0 $;
axiom mulS (a b: nat): $ a * suc b = a * b + a $;

@(register-eqd 'add) theorem addeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> a + c = b + d $ = '(sylc addeq h1 h2);
@(register-eqd 'mul) theorem muleqd (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> a * c = b * d $ = '(sylc muleq h1 h2);
do { (add-eqN-thms 'add) (add-eqN-thms 'mul) };
theorem nfadd (a b: nat x) (h1: $ FN/ x a $) (h2: $ FN/ x b $):
  $ FN/ x a + b $ = '(!! nfnlem2 _ y z (addeqd anl anr) h1 h2);
theorem nfmul (a b: nat x) (h1: $ FN/ x a $) (h2: $ FN/ x b $):
  $ FN/ x a * b $ = '(!! nfnlem2 _ y z (muleqd anl anr) h1 h2);

theorem add02: $ a + 0 = a $ = 'add0;
theorem add01: $ 0 + a = a $ =
'(! ind x y _ $ 0 + x = x $ _ _ _ _
  (eqeqd addeq2 id) (eqeqd addeq2 id)
  (eqeqd addeq2 id) (eqeqd addeq2 id)
  add0 (syl5eq addS suceq));

theorem addS2: $ a + suc b = suc (a + b) $ = 'addS;
theorem addS1: $ suc a + b = suc (a + b) $ =
'(! ind x y _ $ suc a + x = suc (a + x) $ _ _ _ _
  (eqeqd addeq2 (suceqd addeq2)) (eqeqd addeq2 (suceqd addeq2))
  (eqeqd addeq2 (suceqd addeq2)) (eqeqd addeq2 (suceqd addeq2))
  (eqtr4 add0 (suceq add0))
  (syl5eq addS (suceqd (syl6eqr addS id))));
theorem addSass: $ suc a + b = a + suc b $ = '(eqtr4 addS1 addS2);

theorem add12: $ a + 1 = suc a $ = '(eqtr addS (suceq add0));
theorem add11: $ 1 + a = suc a $ = '(eqtr addS1 (suceq add01));

theorem addcom: $ a + b = b + a $ =
'(! ind x y _ $ a + x = x + a $ _ _ _ _
  (eqeqd addeq2 addeq1) (eqeqd addeq2 addeq1)
  (eqeqd addeq2 addeq1) (eqeqd addeq2 addeq1)
  (eqtr4 add0 add01) (eqtr4g addS addS1 suceq));

theorem addass: $ (a + b) + c = a + (b + c) $ =
'(! ind x y _ $ (a + b) + x = a + (b + x) $ _ _ _ _
  (eqeqd addeq2 (addeq2d addeq2)) (eqeqd addeq2 (addeq2d addeq2))
  (eqeqd addeq2 (addeq2d addeq2)) (eqeqd addeq2 (addeq2d addeq2))
  (eqtr4 add0 (addeq2 add0))
  (eqtr4g addS (eqtr (addeq2 addS) addS) suceq));

theorem add32: $ (a + b) + c = (a + c) + b $ =
'(eqtr addass (eqtr4 (addeq2 addcom) addass));

theorem add4: $ (a + b) + (c + d) = (a + c) + (b + d) $ =
'(eqtr3 addass @ eqtr (addeq1 add32) addass);

theorem addcan1: $ a + c = b + c <-> a = b $ =
'(! ind x y _ $ a + x = b + x <-> a = b $ _ _ _ _
  (bieq1d (eqeqd addeq2 addeq2)) (bieq1d (eqeqd addeq2 addeq2))
  (bieq1d (eqeqd addeq2 addeq2)) (bieq1d (eqeqd addeq2 addeq2))
  (eqeq add0 add0) (syl5bb (bitr (eqeq addS addS) peano2) id));
theorem addcan2: $ a + b = a + c <-> b = c $ =
'(bitr (eqeq addcom addcom) addcan1);

theorem mul02: $ a * 0 = 0 $ = 'mul0;
theorem mul01: $ 0 * a = 0 $ =
'(! ind x y _ $ 0 * x = 0 $ _ _ _ _
  (eqeq1d muleq2) (eqeq1d muleq2) (eqeq1d muleq2) (eqeq1d muleq2)
  mul0 (syl5eq (eqtr mulS add0) id));

theorem mulS2: $ a * suc b = a * b + a $ = 'mulS;
theorem mulS1: $ suc a * b = a * b + b $ =
'(! ind x y _ $ suc a * x = a * x + x $ _ _ _ _
  (eqeqd muleq2 (addeqd muleq2 id)) (eqeqd muleq2 (addeqd muleq2 id))
  (eqeqd muleq2 (addeqd muleq2 id)) (eqeqd muleq2 (addeqd muleq2 id))
  (eqtr4 mul0 (eqtr add0 mul0))
  (eqtr4g mulS (eqtr (addeq1 mulS) @
    eqtr addS @ eqtr4 (suceq add32) addS) addeq1));

theorem mulcom: $ a * b = b * a $ =
'(! ind x y _ $ a * x = x * a $ _ _ _ _
  (eqeqd muleq2 muleq1) (eqeqd muleq2 muleq1)
  (eqeqd muleq2 muleq1) (eqeqd muleq2 muleq1)
  (eqtr4 mul0 mul01) (eqtr4g mulS mulS1 addeq1));

theorem mul12: $ a * 1 = a $ = '(eqtr mulS (eqtr (addeq1 mul0) add01));
theorem mul11: $ 1 * a = a $ = '(eqtr mulcom mul12);
theorem mul22: $ a * 2 = a + a $ = '(eqtr mulS2 @ addeq1 mul12);
theorem mul21: $ 2 * a = a + a $ = '(eqtr mulcom mul22);

theorem muladd: $ a * (b + c) = a * b + a * c $ =
'(! ind x y _ $ a * (b + x) = a * b + a * x $ _ _ _ _
  (eqeqd (muleq2d addeq2) (addeq2d muleq2))
  (eqeqd (muleq2d addeq2) (addeq2d muleq2))
  (eqeqd (muleq2d addeq2) (addeq2d muleq2))
  (eqeqd (muleq2d addeq2) (addeq2d muleq2))
  (eqtr4 (muleq2 add0) (eqtr (addeq2 mul0) add0))
  (eqtr4g (eqtr (muleq2 addS) mulS) (eqtr4 (addeq2 mulS) addass) addeq1));

theorem addmul: $ (a + b) * c = a * c + b * c $ =
'(eqtr mulcom (eqtr muladd (addeq mulcom mulcom)));

theorem mulass: $ (a * b) * c = a * (b * c) $ =
'(! ind x y _ $ (a * b) * x = a * (b * x) $ _ _ _ _
  (eqeqd muleq2 (muleq2d muleq2)) (eqeqd muleq2 (muleq2d muleq2))
  (eqeqd muleq2 (muleq2d muleq2)) (eqeqd muleq2 (muleq2d muleq2))
  (eqtr4 mul0 (eqtr (muleq2 mul0) mul0))
  (eqtr4g mulS (eqtr (muleq2 mulS) muladd) addeq1));

theorem mul32: $ (a * b) * c = (a * c) * b $ =
'(eqtr mulass (eqtr4 (muleq2 mulcom) mulass));

@_ def sub (a b: nat): nat = $ the {x | b + x = a} $;
infixl sub: $-$ prec 64;

theorem eqsub2: $ a + b = c -> c - a = b $ =
'(!! eqthed x @ syl5bb (!! elabe y @ eqeq1d addeq2) (syl6bb addcan2 @ bicomd eqeq2));
theorem eqsub1: $ a + b = c -> c - b = a $ = '(sylbi (eqeq1 addcom) eqsub2);
theorem pncan: $ a + b - b = a $ = '(eqsub1 eqid);
theorem pncan2: $ a + b - a = b $ = '(eqsub2 eqid);
theorem sub02: $ a - 0 = a $ = '(eqsub1 add0);
theorem subid: $ a - a = 0 $ = '(eqsub1 add01);
theorem sucsub1: $ suc a - 1 = a $ = '(eqtr3 (subeq1 add12) pncan);

@_ def le (a b .x: nat): wff = $ E. x a + x = b $;
infixl le: $<=$ prec 50;

theorem dfle: $ a <= b <-> E. x a + x = b $ = '(!! cbvex y x (eqeq1d addeq2));

theorem leid: $ a <= a $ = '(!! iexe x (eqeq1d addeq2) add0);
theorem eqle: $ a = b -> a <= b $ = '(mpbii leid leeq2);
theorem eqler: $ a = b -> b <= a $ = '(syl eqle eqcom);

theorem pncan3: $ a <= b -> a + (b - a) = b $ =
'(!! eex x @ mpbii (addeq2 pncan2) (eqeqd (addeq2d subeq1) id));
theorem npcan: $ b <= a -> a - b + b = a $ = '(syl5eq addcom pncan3);

theorem leaddid1: $ a <= a + b $ = '(!! iexe x (eqeq1d addeq2) eqid);
theorem leaddid2: $ a <= b + a $ = '(mpbi (leeq eqid addcom) leaddid1);

theorem lesucid: $ a <= suc a $ = '(mpbi (leeq2 add12) leaddid1);

theorem le01: $ 0 <= a $ = '(mpbi (leeq2 add0) leaddid2);

theorem leadd1: $ a <= b <-> a + c <= b + c $ =
'(bitr dfle (!! exeqi x (bitr3 addcan1 (eqeq1 add32))));
theorem leadd2: $ b <= c <-> a + b <= a + c $ = '(bitr leadd1 (leeq addcom addcom));
theorem lesuc: $ a <= b <-> suc a <= suc b $ = '(bitr leadd1 (leeq add12 add12));

theorem letrd (h1: $ G -> a <= b $) (h2: $ G -> b <= c $): $ G -> a <= c $ =
'(mpd h1 @ !! eexda x @ mpd (anwl h2) @ !! eexda y @ syl
  (!! iexe z @ eqeq1d addeq2) @
  syl5eqr addass @ eqtrd (addeq1d anlr) anr);

theorem letr: $ a <= b -> b <= c -> a <= c $ = '(exp (letrd anl anr));

theorem leasymd (h1: $ G -> a <= b $) (h2: $ G -> b <= a $): $ G -> a = b $ =
(focus
  '(mpd h1 (!! eexda x (! casesda _ $ x = 0 $ _ _ _)))
  (focus
    '(syl5eqr add0 (eqtr3d (anwr addeq2) anlr)))
  (focus
    '(imp (syl5bi exsuc (!! eexda y _)))
    '(mpd (anwl (anwl h2)) (!! eexda z _))
    '(sylc absurd (a1i peano1) _)
    '(syl5eqr addS1 @ eqtr3d (addeq1d anlr) (sylib addcan2 _))
    '(eqtr4g (eqcom addass) add0 (eqtrd (addeq1d (anwl anlr)) anr))));

theorem leasym: $ a <= b -> b <= a -> a = b $ = '(exp (leasymd anl anr));
theorem eqlele: $ a = b <-> a <= b /\ b <= a $ =
'(ibii (iand eqle eqler) (imp leasym));

theorem le02: $ a <= 0 <-> a = 0 $ = '(ibii (mpi le01 leasym) eqle);
theorem le11: $ 1 <= a <-> a != 0 $ = '(bitr4 (!! exeqi x (bitr eqcomb @ eqeq2 add11)) exsuc);

theorem addeq0: $ a + b = 0 <-> a = 0 /\ b = 0 $ =
'(ibii (iand (sylib le02 @ mpbii leaddid1 leeq2) (sylib le02 @ mpbii leaddid2 leeq2)) @
  syl6eq add0 @ imp addeq);

theorem sub1can: $ a != 0 -> suc (a - 1) = a $ = '(sylbir le11 @ syl5eqr add12 npcan);

theorem leaddd (h1: $ G -> a <= b $) (h2: $ G -> c <= d $): $ G -> a + c <= b + d $ =
'(letrd (sylib leadd1 h1) (sylib leadd2 h2));

theorem leadd: $ a <= b -> c <= d -> a + c <= b + d $ = '(exp @ leaddd anl anr);

theorem lemul1a: $ a <= b -> a * c <= b * c $ =
(mk-ind '(! indd _ x y _ $ a * x <= b * x $ _ _ _ _)
  '(leeqd muleq2 muleq2)
  '(a1i (eqle (eqtr4 mul0 mul0))) '(sylibr (leeq mulS mulS) (leaddd anr anl)));
theorem lemul2a: $ b <= c -> a * b <= a * c $ = '(sylib (leeq mulcom mulcom) lemul1a);
theorem lemuld (h1: $ G -> a <= b $) (h2: $ G -> c <= d $): $ G -> a * c <= b * d $ =
'(letrd (syl lemul1a h1) (syl lemul2a h2));

@_ def lt (a b: nat): wff = $ suc a <= b $;
infixl lt: $<$ prec 50;

theorem ltletr: $ a < b -> b <= c -> a < c $ = 'letr;
theorem ltletrd (h1: $ G -> a < b $) (h2: $ G -> b <= c $): $ G -> a < c $ = '(letrd h1 h2);

theorem ltle: $ a < b -> a <= b $ = '(letrd (a1i lesucid) id);
theorem ltlei (h: $ a < b $): $ a <= b $ = '(ltle h);
theorem ltled (h: $ G -> a < b $): $ G -> a <= b $ = '(syl ltle h);

theorem lelttr: $ a <= b -> b < c -> a < c $ = '(sylbi lesuc letr);
theorem lelttrd (h1: $ G -> a <= b $) (h2: $ G -> b < c $): $ G -> a < c $ = '(sylc lelttr h1 h2);

theorem lttr: $ a < b -> b < c -> a < c $ = '(syl lelttr ltle);
theorem lttri (h1: $ a < b $) (h2: $ b < c $): $ a < c $ = '(lttr h1 h2);
theorem lttrd (h1: $ G -> a < b $) (h2: $ G -> b < c $): $ G -> a < c $ = '(sylc lttr h1 h2);

theorem ltsucid: $ a < suc a $ = 'leid;

theorem lt01: $ 0 < a <-> a != 0 $ = 'le11;
theorem lt02: $ ~ a < 0 $ = '(con3 (bi1 le02) peano1);
theorem lt01S: $ 0 < suc a $ = '(mpbir lt01 peano1);

theorem ltadd1: $ a < b <-> a + c < b + c $ = '(bitr leadd1 (leeq1 addS1));
theorem ltadd2: $ b < c <-> a + b < a + c $ = '(bitr ltadd1 (lteq addcom addcom));
theorem ltsuc: $ a < b <-> suc a < suc b $ = '(bitr ltadd1 (lteq add12 add12));
theorem leltsuc: $ a <= b <-> a < suc b $ = 'lesuc;

theorem ltirr: $ ~ a < a $ = '(mtbi (bitr ltadd1 @ lteq add01 add01) lt02);
theorem ltne: $ a < b -> a != b $ = '(mpi ltirr @ con3d @ com12 @ bi1d lteq1);
theorem ltner: $ a < b -> b != a $ = '(syl necom ltne);

theorem d0lt1: $ 0 < 1 $ = 'lt01S;
theorem d0lt2: $ 0 < 2 $ = 'lt01S;
theorem d1lt2: $ 1 < 2 $ = '(mpbi ltsuc d0lt1);
theorem lt12: $ a < 1 <-> a = 0 $ = '(bitr3 leltsuc le02);

theorem nlesubeq0: $ ~b <= a -> a - b = 0 $ =
'(!! eqthe0abd x @ syl5 (mpbii leaddid1 leeq2) absurd);

theorem subleid: $ a - b <= a $ =
'(cases (mpbii leaddid1 @ leeq2d npcan) (mpbiri le01 @ leeq1d nlesubeq0));
theorem subltid: $ 0 < a /\ 0 < b -> a - b < a $ =
'(casesda
  (sylibr ltadd1 @ mpbird (anwr @ lteq1d @ syl6eqr add0 npcan) @ sylib ltadd2 anlr)
  (mpbird (anwr @ lteq1d nlesubeq0) anll));

theorem lesub1i: $ a <= b -> a - c <= b - c $ =
'(cases
  (exp @ sylibr leadd1 @ mpbird (leeqd (anwl npcan) (syl npcan (imp letr))) anr)
  (a1d @ mpbiri le01 (leeq1d nlesubeq0)));

theorem leloe: $ a <= b <-> a < b \/ a = b $ =
'(ibii (!! eex x @ casesd
    (exp (orrd (syl5eqr add0 (eqtr3d (anwr addeq2) anl))))
    (syl5bi exsuc @ !! eexda y @ orld @ mpbii leaddid1 @
      leeq2d @ syl5eq addSass @ eqtr3d (anwr addeq2) anl))
  (eor ltle eqle));

theorem ltlene: $ a < b <-> a <= b /\ a != b $ =
'(ibii (iand ltle ltne) (imp (con1d (bi1 leloe))));
theorem ltlenle: $ a < b <-> a <= b /\ ~b <= a $ =
'(ibii (iand ltle (mtd (a1i ltirr) ltletr))
  (sylibr ltlene @ iand anl @ anwr @ con3 eqler));

theorem ltorle: $ a < b \/ b <= a $ =
'(! ind x y _ $ a < x \/ x <= a $ _ _ _ _
  (oreqd lteq2 leeq1) (oreqd lteq2 leeq1) (oreqd lteq2 leeq1) (oreqd lteq2 leeq1)
  (orr le01)
  (eor (orld (mpi ltsucid lttr))
    (syl5 (con3 (bi1 lesuc)) @ exp @ bi2 ltlenle)));
theorem leorlt: $ a <= b \/ b < a $ = '(orcom ltorle);

theorem ltnle: $ a < b <-> ~b <= a $ = '(ibii (sylbi ltlenle anr) leorlt);
theorem lenlt: $ a <= b <-> ~b < a $ = '(con2b ltnle);
theorem ltnlt: $ a < b -> ~b < a $ = '(sylbi ltnle (con3 ltle));
theorem leorle: $ a <= b \/ b <= a $ = '(syl ltle leorlt);

theorem neltlt: $ a != b <-> a < b \/ b < a $ =
'(ibii (mpi ltorle @ imim2d @ rsyl necom @ com12 @ exp @ bi2i ltlene) (eor ltne ltner));

theorem eqalle2: $ a = b <-> A. i (a <= i <-> b <= i) $ =
'(ibii (iald leeq1) @ leasymd
  (mpbiri leid @ eale @ bieqd leeq2 leeq2)
  (mpbii leid @ eale @ bieqd leeq2 leeq2));
theorem eqallt1: $ a = b <-> A. i (i < a <-> i < b) $ =
'(bitr eqalle2 @ aleqi @ bitr4 con3bb @ bieq ltnle ltnle);

theorem ltsubeq0: $ a < b -> a - b = 0 $ = '(sylbi ltnle nlesubeq0);
theorem lesubeq0: $ a <= b <-> a - b = 0 $ =
'(ibii (sylbi leloe @ eor ltsubeq0 @ syl6eq subid subeq1) @
  syla contra @ syl eqle @
  eqtr3d (syl npcan @ anwr leorle) (syl6eq add01 @ anwl addeq1));

theorem subpos: $ a < b <-> 0 < b - a $ = '(bitr ltnle @ bitr4 (noteq lesubeq0) lt01);

theorem lesubadd2: $ a - b <= c <-> a <= b + c $ =
'(ibii
  (eor (a1d @ mpi leaddid1 letr) (bi1d @ syl5bb leadd2 @ leeq1d pncan3) leorle)
  (sylib (leeq2 pncan2) lesub1i));

theorem lesubadd: $ a - b <= c <-> a <= c + b $ = '(bitr lesubadd2 (leeq2 addcom));

theorem ltaddsub: $ a + b < c <-> a < c - b $ =
'(bitr4 ltnle @ bitr ltnle @ noteqi lesubadd);

theorem ltaddsub2: $ a + b < c <-> b < c - a $ = '(bitr (lteq1 addcom) ltaddsub);

theorem mulsub: $ a * (b - c) = a * b - a * c $ =
'(eor
  (eqcomd @ syl eqsub1 @ syl5eqr muladd @ muleq2d npcan)
  (eqtr4d (syl6eq mul02 @ sylbi lesubeq0 muleq2)
    (sylib lesubeq0 lemul2a)) leorle);
theorem submul: $ (a - b) * c = a * c - b * c $ =
'(eqtr mulcom @ eqtr mulsub @ subeq mulcom mulcom);

theorem ltmul1: $ 0 < c -> (a < b <-> a * c < b * c) $ =
'(ibid
  (com12 ,(mk-ind '(! indd _ x y _ $ 0 < x -> a * x < b * x $ _ _ _ _)
    '(imeqd lteq2 (lteqd muleq2 muleq2))
    '(a1i @ absurd lt02)
    '(a1d @ anwl @ sylibr (lteq mulS mulS) @
      ltletrd (bi1 ltadd2) @ sylib leadd1 @ syl lemul1a ltle)))
  (a1i (mpbir (imeqi ltnle ltnle) (con3 lemul1a))));
theorem ltmul2: $ 0 < a -> (b < c <-> a * b < a * c) $ =
'(syl6bb (lteq mulcom mulcom) ltmul1);
theorem lemul1: $ 0 < c -> (a <= b <-> a * c <= b * c) $ =
'(sylibr (bieq lenlt lenlt) (noteqd ltmul1));
theorem lemul2: $ 0 < a -> (b <= c <-> a * b <= a * c) $ =
'(syl6bb (leeq mulcom mulcom) lemul1);

theorem mulcan1: $ c != 0 -> (a * c = b * c <-> a = b) $ =
'(ibid (sylbir lt01 @ exp (leasymd
    (mpbird (anwl lemul1) (anwr eqle))
    (mpbird (anwl lemul1) (anwr eqler))))
  (a1i muleq1));
theorem mulcan2: $ a != 0 -> (a * b = a * c <-> b = c) $ =
'(syl5bb (eqeq mulcom mulcom) mulcan1);

theorem mulpos: $ 0 < a * b <-> 0 < a /\ 0 < b $ =
'(ibii (iand
    (sylbi lt01 @ sylibr lt01 @ con3 @ syl6eq mul01 muleq1)
    (sylbi lt01 @ sylibr lt01 @ con3 @ syl6eq mul02 muleq2))
  (sylib (lteq1 mul0) @ mpbid (anwl ltmul2) anr));

theorem mulne0: $ a * b != 0 <-> a != 0 /\ b != 0 $ =
'(bitr3 lt01 @ bitr mulpos @ aneq lt01 lt01);

theorem sub01: $ 0 - a = 0 $ =
'(cases (sylbi le02 @ syl6eq sub02 subeq2) nlesubeq0);

theorem pnpcan2: $ (a + c) - (b + c) = a - b $ =
'(cases
  (syl eqsub1 @ syl5eqr addass @ addeq1d npcan)
  (eqtr4d (sylbi (noteq leadd1) nlesubeq0) nlesubeq0));

theorem pnpcan: $ (a + b) - (a + c) = b - c $ = '(eqtr (subeq addcom addcom) pnpcan2);
theorem subSS: $ suc a - suc b = a - b $ = '(eqtr3 (subeq add12 add12) pnpcan2);

theorem indlt (G) {x y} (a: nat) (px: wff x) (p0 pa py ps: wff y)
  (h0: $ x = 0 -> (px <-> p0) $)
  (hy: $ x = y -> (px <-> py) $)
  (hs: $ x = suc y -> (px <-> ps) $)
  (ha: $ x = a -> (px <-> pa) $)
  (h1: $ G -> p0 $) (h2: $ G /\ y < a /\ py -> ps $): $ G -> pa $ =
'(mpi leid @ indd
  (imeqd leeq1 h0) (imeqd leeq1 hy) (imeqd leeq1 hs) (imeqd leeq1 ha)
  (a1d h1) (imp @ syl5 (imim1i ltle) @ a2d @ exp @ exp h2));

theorem indstr (G) {x y} (a: nat y) (px: wff x) (pa py: wff y)
  (hy: $ x = y -> (px <-> py) $)
  (ha: $ x = a -> (px <-> pa) $)
  (h: $ G /\ A. x (x < y -> px) -> py $): $ G -> pa $ =
'(syl (mpi ltsucid @ eale @ imeqd lteq1 ha) ,(mk-ind
  '(! indd _ z y _ $ A. x (x < z -> px) $ _ _ _ _)
  '(aleqd @ imeq1d lteq2)
  '(a1i @ ax_gen @ absurd lt02)
  '(mpd (rsyl h @ iald @ com12 @ bi2d hy) @
    anwr @ al2imi @ syl6 (imim1i @ bi1i @ bitr3 leltsuc leloe) eor)));

@(derive-eq 'fin) def finite (A: set): wff = $ E. n A. x (x e. A -> x < n) $;

theorem nffin (A: set x) (h: $ FS/ x A $): $ F/ x finite A $ =
(named '(nfex @ nfal @ nfim (nfel2 h) nfv));

theorem finss: $ A C_ B -> finite B -> finite A $ =
'(!! eximd n @ !! alimd x @ imim1d ssel);

theorem ltfin: $ finite {x | x < n} $ =
'(!! iexe m (aleqd @ imeq2d @ lteq2) @ !! ax_gen y @ bi1i @ elabe lteq1);

theorem lefin: $ finite {x | x <= n} $ =
'(!! iexe m (aleqd @ imeq2d @ lteq2) @ !! ax_gen y @ sylbi (elabe leeq1) @ bi1i leltsuc);

theorem snfin: $ finite {x | x = n} $ =
'(finss (mpbi ssab @ ax_gen eqle) lefin);

theorem infin1: $ finite A -> finite (A i^i B) $ = '(finss inss1);
theorem infin2: $ finite B -> finite (A i^i B) $ = '(finss inss2);

@_ abstract def if (p: wff) (a b: nat): nat = $ the {n | ifp p (n = a) (n = b)} $;

pub theorem ifpos (p: wff) (a b: nat): $ p -> if p a b = a $ = '(!! eqtheabd n ifppos);
pub theorem ifneg (p: wff) (a b: nat): $ ~p -> if p a b = b $ = '(!! eqtheabd n ifpneg);

theorem ifid: $ if p a a = a $ = '(cases ifpos ifneg);
theorem ifeq2a: $ (p -> a = b) -> if p a c = if p b c $ =
'(casesd (imim2i ifeq2) (a1i @ eqtr4d ifneg ifneg));
theorem ifeq3a: $ (~p -> b = c) -> if p a b = if p a c $ =
'(casesd (a1i @ eqtr4d ifpos ifpos) (imim2i ifeq3));

@_ def true (n: nat): wff = $ n != 0 $;
@_ def bool (n: nat): wff = $ n < 2 $;
@_ def nat (p: wff): nat = $ if p 1 0 $;

theorem true1: $ true 1 $ = 'd1ne0;
theorem true0: $ ~ true 0 $ = '(notnot1 eqid);

theorem letrue: $ a <= b -> true a -> true b $ =
'(sylib (imeqi lt01 lt01) @ com12 ltletr);

theorem truemul: $ true (a * b) <-> true a /\ true b $ = 'mulne0;

theorem bool0: $ bool 0 $ = 'd0lt2;
theorem bool1: $ bool 1 $ = 'd1lt2;
theorem bool01: $ bool n <-> n = 0 \/ n = 1 $ =
'(bitr3 leltsuc (bitr leloe (oreq1i lt12)));

theorem lebool: $ a <= b -> bool b -> bool a $ = 'lelttr;

theorem letrueb: $ bool a -> (a <= b <-> (true a -> true b)) $ =
'(ibid (a1i letrue) @ sylbi bool01 @ eor
  (a1d @ mpbiri le01 leeq1)
  (mpbiri (bi2i le11) @ imeqd (syl biim1 @ mpbiri true1 trueeq) leeq1));

theorem dftrue2: $ bool n -> (true n <-> n = 1) $ =
'(ibid (bi1 bool01) (a1i @ mpbiri d1ne0 neeq1));

theorem boolnat: $ bool (nat p) $ =
'(cases (mpbiri d1lt2 @ lteq1d ifpos) (mpbiri d0lt2 @ lteq1d ifneg));

theorem truenat: $ true (nat p) <-> p $ =
'(ibii (con1 ifneg) (mpbiri d1ne0 (neeq1d ifpos)));
theorem nattrue: $ bool n -> nat (true n) = n $ =
'(sylbi bool01 @ eor
  (eqtr4d (nateqd trueeq) @ syl6eqr (ifneg true0) id)
  (eqtr4d (nateqd trueeq) @ syl6eqr (ifpos true1) id));

theorem natle: $ (p -> q) <-> nat p <= nat q $ =
'(bicom @ bitr (letrueb boolnat) (imeqi truenat truenat));

theorem nattruele: $ nat (true n) <= n $ =
'(eor id (syl eqle @ syl nattrue @ mpi boolnat lebool) leorle);

theorem boolext: $ bool a -> bool b -> ((true a <-> true b) <-> a = b) $ =
'(exp @ ibid
  (exp @ mpbid (eqeqd (syl nattrue anll) (syl nattrue anlr)) @ anwr nateq)
  (a1i trueeq));

@_ def min (a b: nat): nat = $ if (a < b) a b $;
@_ def max (a b: nat): nat = $ if (a < b) b a $;

theorem nfmax {x} (a b: nat x)
  (h1: $ FN/ x a $) (h2: $ FN/ x b $): $ FN/ x max a b $ =
'(!! nfnlem2 _ u v (maxeqd anl anr) h1 h2);

theorem eqmin1: $ a <= b -> min a b = a $ =
'(sylbi leloe @ eor ifpos @ syl6eq ifid (ifeq3d eqcom));
theorem eqmax2: $ a <= b -> max a b = b $ =
'(sylbi leloe @ eor ifpos @ syl6eq ifid (ifeq3d id));

theorem mincom: $ min a b = min b a $ =
'(cases (eqtr4d ifpos @ syl ifneg ltnlt) (eqtr4d ifneg @ sylbir lenlt eqmin1));
theorem maxcom: $ max a b = max b a $ =
'(cases (eqtr4d ifpos @ syl ifneg ltnlt) (eqtr4d ifneg @ sylbir lenlt eqmax2));

theorem eqmin2: $ b <= a -> min a b = b $ = '(syl5eq mincom eqmin1);
theorem eqmax1: $ b <= a -> max a b = a $ = '(syl5eq maxcom eqmax2);

theorem minle1: $ min a b <= a $ =
'(cases (syl eqle ifpos) (mpbird (leeq1d ifneg) (bi2 lenlt)));
theorem minle2: $ min a b <= b $ = '(mpbi (leeq1 mincom) minle1);
theorem lemin: $ a <= min b c <-> a <= b /\ a <= c $ =
'(ibii (iand (mpi minle1 letr) (mpi minle2 letr)) @ casesda
  (mpbird (anwr @ leeq2d ifpos) anll)
  (mpbird (anwr @ leeq2d ifneg) anlr));
theorem ltmin: $ a < min b c <-> a < b /\ a < c $ = 'lemin;

theorem subaddmin: $ (a - b) + min a b = a $ =
'(eor (eqtrd (addeq2d eqmin2) npcan)
  (eqtrd (sylbi lesubeq0 addeq1) @ syl5eq add01 @ eqmin1) leorle);
theorem minaddsub: $ min a b + (a - b) = a $ = '(eqtr addcom subaddmin);

theorem submin: $ a - min a b = a - b $ =
'(eor (eqtr4d (subeq2d eqmin1) @ syl6eqr subid @ bi1 lesubeq0)
  (subeq2d eqmin2) leorle);

theorem lemax1: $ a <= max a b $ =
'(cases (mpbird (leeq2d ifpos) ltle) (syl eqler ifneg));
theorem lemax2: $ b <= max a b $ = '(mpbi (leeq2 maxcom) lemax1);
theorem maxle: $ max a b <= c <-> a <= c /\ b <= c $ =
'(ibii (iand (letr lemax1) (letr lemax2)) @ casesda
  (mpbird (anwr @ leeq1d ifpos) anlr)
  (mpbird (anwr @ leeq1d ifneg) anll));

theorem ltmax: $ a < max b c <-> a < b \/ a < c $ =
'(con4b @ bitr3 lenlt @ bitr maxle @ bitr4 (aneq lenlt lenlt) notor);

theorem minadd1: $ min a b + c = min (a + c) (b + c) $ =
'(cases (eqtr4d (addeq1d ifpos) (sylbi ltadd1 ifpos))
  (eqtr4d (addeq1d ifneg) (sylbi (noteq ltadd1) ifneg)));
theorem maxadd1: $ max a b + c = max (a + c) (b + c) $ =
'(cases (eqtr4d (addeq1d ifpos) (sylbi ltadd1 ifpos))
  (eqtr4d (addeq1d ifneg) (sylbi (noteq ltadd1) ifneg)));

theorem minS: $ suc (min a b) = min (suc a) (suc b) $ =
'(eqtr3 add12 @ eqtr minadd1 @ trud @ mineqd (a1i add12) (a1i add12));
theorem maxS: $ suc (max a b) = max (suc a) (suc b) $ =
'(eqtr3 add12 @ eqtr maxadd1 @ trud @ maxeqd (a1i add12) (a1i add12));

theorem maxlt: $ max a b < c <-> a < c /\ b < c $ = '(bitr (leeq1 maxS) maxle);
theorem lemax: $ a <= max b c <-> a <= b \/ a <= c $ =
'(con4b @ bitr3 ltnle @ bitr maxlt @ bitr4 (aneq ltnle ltnle) notor);

theorem unfin: $ finite A -> finite B -> finite (A u. B) $ =
'(!! eex m @ !! eexd n @
  syl6 (!! iexe z @ aleqd @ imeq2d lteq2) @ !! al2imi x @
  rsyl (imim2i @ mpi lemax1 ltletr) @
  syl5 (imim2i @ mpi lemax2 ltletr) @
  syl6ibr (imeq1i elun) eor);

@_ abstract def div (a b: nat): nat = $ the {q | E. r (r < b /\ b * q + r = a)} $;
infixl div: $//$ prec 70;
@_ abstract def mod (a b: nat): nat = $ a - b * (a // b) $;
infixl mod: $%$ prec 70;

pub theorem div0 (a: nat): $ a // 0 = 0 $ =
'(trud @ !! eqthe0abd q @ a1i @ !! eex r @ anwl @ absurd lt02);
theorem mod0: $ a % 0 = a $ = '(eqtr (subeq2 mul01) sub02);

theorem divlem1
  (h1: $ G -> r1 < b $) (h2: $ G -> r2 < b $)
  (h3: $ G -> b * q1 + r1 <= b * q2 + r2 $):
  $ G -> q1 <= q2 $ =
(focus
  (have 'b0 $ G -> 0 < b $ '(lelttrd (a1i le01) h1))
  '(sylibr leltsuc @ mpbird (syl ltmul2 b0) @ lelttrd (a1i leaddid1) _)
  '(lelttrd h3 @ sylibr (lteq2 mulS) @ sylib ltadd2 h2));

theorem divlem2 (h1: $ G -> R < b $) (h2: $ G -> b * Q + R = a $):
  $ G -> (E. r (r < b /\ b * q + r = a) <-> q = Q) $ =
(focus
  (have 'b0 $ G -> b != 0 $ '(syl ltner @ lelttrd (a1i le01) h1))
  '(ibid (eexda @ leasymd
      (divlem1 anrl (anwl h1) @ syl eqle @ eqtr4d anrr (anwl h2))
      (divlem1 (anwl h1) anrl @ syl eqle @ eqtr4d (anwl h2) anrr))
    (exp @ syl
      (iexe @ aneqd lteq1 @ eqeq1d addeq2)
      (iand (anwl h1) @ eqtrd (anwr @ addeq1d muleq2) (anwl h2)))));

theorem divlem3: $ b != 0 -> E. q E. r (r < b /\ b * q + r = a) $ =
(mk-ind '(! indd _ x y _ $ E. q E. r (r < b /\ b * q + r = x) $ _ _ _ _)
  '(exeqd @ exeqd @ aneq2d eqeq2)
  '(iexde @ iexde @ iand
    (mpbird (anwr lteq1) @ sylibr lt01 anll)
    (syl6eq add0 @ addeqd (syl6eq mul02 @ anwl @ anwr muleq2) anr))
  '(imp @ syl5bi (!! cbvex _ u @ !! cbvexd _ v
    (aneqd (anwr lteq1) @ eqeq1d @ addeqd (anwl muleq2) anr))
    (eexd @ eexda @ mpd (sylib leloe anrl) @ eorda
      (iexde @ iexde @ iand
        (mpbird (anwr lteq1) (anwll anr))
        (eqtrd (anwr addeq2) @ syl5eq addS @ suceqd @
          eqtrd (addeq1d @ muleq2d anlr) (anw3l anrr)))
      (iexde @ iexde @ iand
        (mpbird (anwr lteq1) (sylibr lt01 (anw3l anl)))
        (eqtrd (addeqd (muleq2d anlr) anr) @
          syl5eq add0 @ syl5eq mulS @ eqtr3d (addeq2d @ anwll anr) @
            syl5eq addS @ suceqd @ anw3l anrr)))));

theorem eqdivmod (h1: $ G -> R < b $) (h2: $ G -> b * Q + R = a $):
  $ G -> a // b = Q /\ a % b = R $ =
(focus
  (have 'eq $ G -> a // b = Q $
    '(!! eqtheabd q @ !! divlem2 r h1 h2))
  '(iand eq (syl eqsub2 @ eqtrd (addeq1d @ muleq2d eq) h2)));

pub theorem divmod (a b: nat): $ b * (a // b) + a % b = a $ =
(focus
  '(pncan3 @ cases _ _)
  (focus
    '(mpbiri le01 @ leeq1d @ syl6eq mul0 @ muleq2d @ syl6eq div0 diveq2))
  (focus
    '(mpd (!! divlem3 q r) @ eexd @ eexda @ mpbii leaddid1 _)
    '(leeq2d @ eqtrd (addeq1d @ muleq2d _) anrr)
    '(!! eqtheabd x @ !! divlem2 y anrl anrr)));

pub theorem modlt (a b: nat): $ b != 0 -> a % b < b $ =
'(mpd (!! divlem3 q r) @ eexd @ eexda @
  mpbird (lteq1d @ anrd @ eqdivmod anrl anrr) anrl);

theorem modle1: $ a % b <= a $ = '(mpbi (leeq2 divmod) leaddid2);

theorem div01: $ 0 // a = 0 $ =
'(cases (syl6eq div0 diveq2) @ anld @
  eqdivmod (bi2 lt01) (a1i @ eqtr add0 mul0));
theorem mod01: $ 0 % a = 0 $ =
'(cases (syl6eq mod0 modeq2) @ anrd @
  eqdivmod (bi2 lt01) (a1i @ eqtr add0 mul0));

theorem mod12: $ a % 1 = 0 $ = '(mpbi lt12 @ modlt d1ne0);
theorem div12: $ a // 1 = a $ =
'(eqtr3 (eqtr (addeq mul11 mod12) add02) divmod);

theorem muldiv2: $ b != 0 -> b * a // b = a $ =
'(anld @ eqdivmod (bi2 lt01) (a1i add0));
theorem muldiv1: $ b != 0 -> a * b // b = a $ =
'(eqtrd (diveqd (a1i mulcom) eqidd) muldiv2);
theorem mulmod1: $ b * a % b = 0 $ =
'(cases
  (eqtrd modeq2 @ syl5eq mod0 @ syl6eq mul01 muleq1)
  (anrd @ eqdivmod (bi2 lt01) (a1i add0)));
theorem mulmod2: $ a * b % b = 0 $ =
'(eqtr (modeqd id eqidd mulcom) mulmod1);

theorem lediv1: $ a <= b -> a // c <= b // c $ =
'(casesda (mpbiri le01 @ leeq1d @ syl6eq div0 (anwr diveq2))
  (divlem1 (anwr modlt) (anwr modlt) @ sylibr (leeq divmod divmod) anl));

theorem muldivle: $ b * (a // b) <= a $ = '(mpbi (leeq2 divmod) leaddid1);
theorem divleid: $ a // b <= a $ =
'(cases (mpbiri le01 @ leeq1d @ syl6eq div0 diveq2)
  (letrd (sylib (leeq1 mul11) @ sylbir le11 lemul1a) (a1i muldivle)));

theorem ledivmul1: $ c != 0 -> (a <= b // c <-> c * a <= b) $ =
'(ibida (letrd (anwr lemul2a) (a1i muldivle))
  (sylibr leltsuc @
    mpbird (syl ltmul2 @ sylibr lt01 anl) @ lelttrd anr @ anwl @
    sylibr (lteq2 mulS) @ sylib (lteq1 divmod) @ sylib ltadd2 @ modlt));
theorem ledivmul2: $ c != 0 -> (a <= b // c <-> a * c <= b) $ =
'(syl6bb (leeq1 mulcom) ledivmul1);
theorem ltdivmul1: $ b != 0 -> (a // b < c <-> a < b * c) $ =
'(syl5bb ltnle @ syl6bbr ltnle @ noteqd @ ledivmul1);
theorem ltdivmul2: $ b != 0 -> (a // b < c <-> a < c * b) $ =
'(syl6bb (lteq2 mulcom) ltdivmul1);

theorem diveq0: $ b != 0 -> (a // b = 0 <-> a < b) $ =
'(syl5bbr lt12 @ syl6bb (lteq2 mul12) ltdivmul1);

theorem divdiv: $ a // b // c = a // (b * c) $ =
'(cases (eqtr4d (syl6eq div01 @ diveq1d @ syl6eq div0 diveq2)
    (syl6eq div0 @ diveq2d @ syl6eq mul01 muleq1)) @
  casesda (anwr @ eqtr4d (syl6eq div0 diveq2)
    (syl6eq div0 @ diveq2d @ syl6eq mul02 muleq2)) @
  leasymd
    (mpbird (sylbir mulne0 ledivmul1) @ a1i @
      mpbir (leeq1 mulass) @ letr (lemul2a muldivle) muldivle)
    (mpbird (anwr ledivmul1) @ mpbird (anwl ledivmul1) @ a1i @
      mpbi (leeq1 mulass) muldivle));

theorem divmod1: $ a // b % c = a % (b * c) // b $ =
'(cases (eqtr4d (syl6eq mod01 @ modeq1d @ syl6eq div0 diveq2) @ syl6eq div0 diveq2) @
  casesda (anwr @ eqtr4d (syl6eq mod0 modeq2) @
    diveq1d @ syl6eq mod0 @ modeq2d @ syl6eq mul02 muleq2) @
  anrd @ eqdivmod (mpbird (anwl ltdivmul1) @ sylbir mulne0 modlt) @
  eqcomd @ anld @ eqdivmod (anwl modlt) @ a1i @
  eqtr (addeq1 muladd) @ eqtr addass @ eqtr (addeq2 divmod) @
  eqtr3 (addeq1 mulass) divmod);

theorem divmod2: $ a // b % c = a % (c * b) // b $ =
'(eqtr divmod1 @ diveq1 @ modeq2 mulcom);

@_ def dvd (a b: nat): wff = $ E. c c * a = b $;
infixl dvd: $||$ prec 50;

theorem idvd: $ c * a = b -> a || b $ = '(!! iexe x @ eqeq1d muleq1);
theorem idvd2: $ a * c = b -> a || b $ = '(sylbi (eqeq1 mulcom) idvd);

theorem divmul: $ b || a -> a // b * b = a $ =
(focus
  '(!! eex x @ eqtr3d (muleq1d diveq1) @ syl5eq _ id)
  '(cases (eqtr4d (syl6eq mul0 muleq2) (syl6eq mul0 muleq2)) (muleq1d muldiv1)));
theorem muldiv3: $ b || a -> b * (a // b) = a $ = '(syl5eq mulcom divmul);

theorem dvdadd1: $ n || a -> (n || b <-> n || a + b) $ =
(focus
  '(!! eex x @ ibid _ _)
  (focus
    '(!! eexda y @ syl idvd @ syl5eq addmul @ imp addeq))
  (focus
    '(!! eexda z @ syl idvd @ sylib addcan2 _)
    '(eqtr3d (anwl addeq1) @ syl5eqr addmul @ eqtrd _ anr)
    '(casesda (anwr @ eqtr4d (syl6eq mul0 muleq2) (syl6eq mul0 muleq2)) _)
    '(muleq1d @ syl pncan3 _)
    '(mpbiri leaddid1 @ bitrd (anwr @ sylbir lt01 @ lemul1) @ leeqd anll anlr)));

theorem dvdadd2: $ n || a -> (n || b <-> n || b + a) $ =
'(syl6bb (dvdeqd eqidd id addcom) dvdadd1);

theorem dvdmul1: $ a || b * a $ = '(idvd eqid);
theorem dvdmul2: $ a || a * b $ = '(mpbi (dvdeq2 mulcom) dvdmul1);

theorem dvdtr: $ a || b -> b || c -> a || c $ =
'(!! eex x @ !! eexda y @ syl idvd @ eqtrd (anwl @ syl5eq mulass muleq2) anr);

theorem dvdmul12: $ a || b -> a || c * b $ = '(mpi dvdmul1 dvdtr);
theorem dvdmul11: $ a || b -> a || b * c $ = '(mpi dvdmul2 dvdtr);

theorem modeq0: $ a % n = 0 <-> n || a $ =
'(! ibii _ (ex x _)
  (iexde @ eqtrd (anwr muleq1) @ syl5eq mulcom @
    syl5eqr add0 @ eqtr3d (anwl addeq2) @ a1i divmod)
  (eex @ syl6eq mulmod2 @ modeqd eqcom eqidd));

theorem dvd02: $ a || 0 $ = '(idvd mul01);
theorem dvd01: $ 0 || a <-> a = 0 $ =
'(ibii (!! eex x @ eqcomd @ bi1 @ eqeq1 mul02) (mpbiri dvd02 dvdeq2));

theorem dvdid: $ a || a $ = '(idvd mul11);

theorem dvdle (h1: $ G -> b != 0 $) (h2: $ G -> a || b $): $ G -> a <= b $ =
'(mpd h2 @ !! eexda x @ mpbid (leeqd (a1i mul11) anr) @
  syl lemul1a @ sylibr lt01 @ mtand (anwl h1) @
  eqtr3d anlr @ syl6eq mul01 (anwr muleq1));

theorem dvdasymd (h1: $ G -> a || b $) (h2: $ G -> b || a $): $ G -> a = b $ =
'(casesda (eqtr4d anr (sylib dvd01 @ mpbid (anwr dvdeq1) (anwl h1))) @
  casesda (eqtr4d (sylib dvd01 @ mpbid (anwr dvdeq1) (anwll h2)) anr) @
  leasymd (dvdle anr @ anwll h1) (dvdle anlr @ anwll h2));

theorem dvd11: $ 1 || a $ = '(idvd mul12);
theorem dvd12: $ a || 1 <-> a = 1 $ =
'(ibii (leasymd (dvdle (a1i d1ne0) id) @
    sylibr le11 @ mtani d1ne0 @ sylib dvd01 @ mpbid (anwr dvdeq1) anl)
  (mpbiri dvdid dvdeq1));

theorem d2dvd1: $ ~2 || 1 $ = '(mt (dvdle (a1i d1ne0) id) @ mpbi ltnle d1lt2);

theorem d2dvdS: $ 2 || suc n <-> ~2 || n $ =
'(ibii
  (mtd (a1i d2dvd1) @ exp @ mpbird (syl6bb (dvdeq2 add12) (anwr dvdadd1)) anl)
  ,(mk-ind '(! ind x y _ $ 2 || x \/ 2 || suc x $ _ _ _ _)
    '(oreqd dvdeq2 @ dvdeq2d suceq)
    '(orl dvd02)
    '(eor (orrd @ sylib (dvdeq2 @ eqtr addS @ suceq add12) @ mpbii dvdid dvdadd1) orl)));

theorem modlteq: $ a < n -> a % n = a $ =
'(anrd @ eqdivmod id @ a1i @ eqtr (addeq1 mul0) add01);

theorem modmodid: $ a % n % n = a % n $ =
'(cases (modeqd (syl6eq mod0 modeq2) eqidd) (syl modlteq modlt));

theorem dvdsubmod: $ n || a - a % n $ = '(idvd2 @ eqcom @ eqsub1 @ divmod);

theorem div2lt: $ 0 < n -> n // 2 < n $ =
'(sylibr (ltdivmul1 d2ne0) @ sylib (lteq1 mul11) @ mpbii d1lt2 ltmul1);

theorem boolmod2: $ bool (n % 2) $ = '(modlt d2ne0);

@_ local def eqm (n a b) = $ a % n = b % n $;
notation eqm (n a b) = ($mod($:50) n ($):$:50) a ($=$:50) b;

theorem eqmid: $ mod(n): a = a $ = 'eqid;
theorem eqmtr: $ mod(n): a = b -> mod(n): b = c -> mod(n): a = c $ = 'eqtr;
theorem eqmcom: $ mod(n): a = b -> mod(n): b = a $ = 'eqcom;
theorem eqmcomb: $ mod(n): a = b <-> mod(n): b = a $ = '(ibii eqmcom eqmcom);

theorem eqmeq23d (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> (mod(n): a = c <-> mod(n): b = d) $ = '(eqmeqd eqidd h1 h2);

theorem eqeqm: $ a = b -> mod(n): a = b $ = '(mpbii eqmid eqmeq3);

theorem eqmmod: $ mod(n): a % n = a $ = 'modmodid;

theorem eqm03: $ mod(n): a = 0 <-> n || a $ = '(bitr (eqeq2 mod01) modeq0);

theorem eqmdvdsub: $ a <= b -> (mod(n): a = b <-> n || b - a) $ =
(focus
  (have 'h $ a <= b -> b - a % n = b - a + (a - a % n) $
    '(syl eqsub1 @ syl5eq addass @ syl5eq (addeq2 @ npcan modle1) npcan))
  '(ibida
    (sylibr (dvdadd2 dvdsubmod) @
      mpbiri dvdsubmod @ dvdeqd eqidd @ eqtr3d (anwl h) (anwr subeq2))
    (casesda _ _))
  (focus
    '(modeq1d @ eqtr3d
      (syl6eq add01 @ addeq1d @ sylib dvd01 @ mpbid (anwr dvdeq1) anlr)
      (anwll npcan)))
  (focus
    '(eqcomd @ anrd @ eqdivmod (anwr modlt) @ eqtrd
      (addeq1d @ syl5eq muladd @ eqtr4d _ @ anwll h)
      (syl npcan @ letrd (a1i modle1) anll))
    '(addeqd (syl muldiv3 anlr) @ a1i @ eqcom @ eqsub1 divmod)));

theorem eqmaddlem (h1: $ G -> a <= b $) (h2: $ G -> mod(n): a = b $):
  $ G -> mod(n): a + c = b + c $ =
'(mpbird (rsyl h1 @ sylbi leadd1 eqmdvdsub)
  (sylibr (dvdeq2 pnpcan2) @ mpbid (syl eqmdvdsub h1) h2));

theorem eqmadd1d (h: $ G -> mod(n): a = b $): $ G -> mod(n): a + c = b + c $ =
'(eor (exp @ eqmaddlem anl @ anwr h)
  (exp @ syl eqmcom @ eqmaddlem anl @ anwr @ syl eqmcom h) leorle);
theorem eqmadd2d (h: $ G -> mod(n): b = c $): $ G -> mod(n): a + b = a + c $ =
'(mpbid (eqmeq23d (a1i addcom) (a1i addcom)) (eqmadd1d h));

theorem eqmaddd (h1: $ G -> mod(n): a = b $) (h2: $ G -> mod(n): c = d $):
  $ G -> mod(n): a + c = b + d $ =
'(sylc eqmtr (eqmadd1d h1) (eqmadd2d h2));

theorem dvdeqm (h1: $ G -> m || n $)
  (h2: $ G -> mod(n): a = b $): $ G -> mod(m): a = b $ =
'(mpi leorle @ eorda
  (mpbird (anwr eqmdvdsub) @ sylc dvdtr (anwl h1) @ mpbid (anwr eqmdvdsub) (anwl h2))
  (syl eqmcom @
    mpbird (anwr eqmdvdsub) @ sylc dvdtr (anwl h1) @
    mpbid (anwr eqmdvdsub) (anwl @ syl eqmcom h2)));

theorem modmod: $ m || n -> a % n % m = a % m $ = '(dvdeqm id @ a1i eqmmod);

theorem eqm11: $ mod(1): a = b $ = '(eqtr4 mod12 mod12);
theorem eqm01: $ mod(0): a = b <-> a = b $ = '(eqeq mod0 mod0);

@_ def b0 (n: nat): nat = $ n + n $;
@_ def b1 (n: nat): nat = $ suc (b0 n) $;
@_ def odd (n: nat): wff = $ n % 2 = 1 $;

theorem b00: $ b0 0 = 0 $ = 'add0;
theorem b10: $ b1 0 = 1 $ = '(suceq b00);

theorem b0mul21: $ 2 * n = b0 n $ = 'mul21;
theorem b0mul22: $ n * 2 = b0 n $ = 'mul22;

theorem b0ne0: $ b0 n != 0 <-> n != 0 $ =
'(bitr3 (neeq1 b0mul21) @ bitr mulne0 @ bian1 d2ne0);

theorem b1ne0: $ b1 n != 0 $ = 'peano1;

theorem b1mul21: $ 2 * n + 1 = b1 n $ = '(eqtr (addeq1 b0mul21) add12);

theorem b0dvd2: $ 2 || b0 n $ = '(idvd b0mul22);
theorem b1dvd2: $ ~2 || b1 n $ = '(mpbi (con2b d2dvdS) b0dvd2);

theorem dfodd2: $ odd n <-> true (n % 2) $ = '(bicom @ dftrue2 boolmod2);
theorem odddvd: $ odd n <-> ~ 2 || n $ = '(bitr dfodd2 @ noteq modeq0);

theorem b0odd: $ ~odd (b0 n) $ = '(mpbi (con2b odddvd) b0dvd2);
theorem b1odd: $ odd (b1 n) $ = '(mpbir odddvd b1dvd2);

theorem b0mod2: $ b0 n % 2 = 0 $ = '(mpbir modeq0 b0dvd2);
theorem b1mod2: $ b1 n % 2 = 1 $ = 'b1odd;

theorem b0div2: $ b0 n // 2 = n $ = '(eqtr3 (diveq1 b0mul21) (muldiv2 d2ne0));
theorem b1div2: $ b1 n // 2 = n $ =
'(trud @ anld @ eqdivmod (a1i d1lt2) (a1i b1mul21));
theorem b0can: $ b0 a = b0 b <-> a = b $ =
'(ibii (sylib (eqeq b0div2 b0div2) diveq1) b0eq);
theorem b1can: $ b1 a = b1 b <-> a = b $ =
'(ibii (sylib (eqeq b1div2 b1div2) diveq1) b1eq);
theorem b1neb0: $ b1 a != b0 b $ = '(mt (mpbii b1odd oddeq) b0odd);
theorem b0neb1: $ b0 a != b1 b $ = '(necom b1neb0);

theorem sucb0: $ suc (b0 a) = b1 a $ = 'eqid;
theorem sucb1: $ suc (b1 a) = b0 (suc a) $ = '(eqtr2 addS1 @ suceq addS);
theorem addb00: $ b0 a + b0 b = b0 (a + b) $ = 'add4;
theorem addb01: $ b0 a + b1 b = b1 (a + b) $ = '(eqtr addS @ suceq addb00);
theorem addb10: $ b1 a + b0 b = b1 (a + b) $ = '(eqtr addcom @ eqtr addb01 @ b1eq addcom);
theorem addb11: $ b1 a + b1 b = b0 (suc (a + b)) $ = '(eqtr addS @ eqtr (suceq addb10) sucb1);

theorem b0le: $ a <= b <-> b0 a <= b0 b $ =
'(bitr (lemul2 d0lt2) (leeq b0mul21 b0mul21));
theorem b1le: $ a <= b <-> b1 a <= b1 b $ = '(bitr b0le lesuc);

theorem b0lt: $ a < b <-> b0 a < b0 b $ =
'(bitr (ltmul2 d0lt2) (lteq b0mul21 b0mul21));
theorem b1lt: $ a < b <-> b1 a < b1 b $ = '(bitr b0lt ltsuc);

theorem b0orb1: $ n = b0 (n // 2) \/ n = b1 (n // 2) $ =
'(rsyl (con3 @ eqcomd @ syl5eqr b0mul21 muldiv3) @
  sylbir odddvd @ syl5eqr divmod @ syl6eq b1mul21 addeq2);

theorem b0leid: $ n <= b0 n $ = 'leaddid1;
theorem b1ltid: $ n < b1 n $ = '(mpbi leltsuc b0leid);
theorem b1leid: $ n <= b1 n $ = '(ltle b1ltid);
theorem b0ltid: $ n != 0 <-> n < b0 n $ = '(bitr3 lt01 @ bitr ltadd2 @ lteq1 add0);

theorem ltb0tr (h: $ a < b $): $ a < b0 b $ = '(ltletr h b0leid);
theorem ltb1tr (h: $ a <= b $): $ a < b1 b $ = '(lelttr h b1ltid);
theorem leb0tr (h: $ a <= b $): $ a <= b0 b $ = '(letr h b0leid);
theorem leb1tr (h: $ a <= b $): $ a <= b1 b $ = '(ltle @ ltb1tr h);

theorem eqb0: $ ~ odd n <-> n = b0 (n // 2) $ =
'(ibii (con1 @ rsyl b0orb1 @ mpbiri b1odd oddeq) (mpbiri b0odd (noteqd oddeq)));
theorem eqb1: $ odd n <-> n = b1 (n // 2) $ =
'(ibii (syl b0orb1 @ con2 @ mpbiri b0odd @ noteqd oddeq) (mpbiri b1odd oddeq));

theorem splitb (h0: $ G -> a = b0 (a // 2) -> p $) (h1: $ G -> a = b1 (a // 2) -> p $): $ G -> p $ =
'(mpi b0orb1 @ eord h0 h1);

theorem splitb0 (h: $ G -> a = b0 c -> p $): $ G -> b = c -> a = b0 b -> p $ =
'(exp @ exp @ sylc h anll @ eqtrd anr @ b0eqd anlr);

theorem splitb1 (h: $ G -> a = b1 c -> p $): $ G -> b = c -> a = b1 b -> p $ =
'(exp @ exp @ sylc h anll @ eqtrd anr @ b1eqd anlr);

-- Proves $ G /\ a = a1 <> ... <> an -> p $ > $ G -> p $ (where n >= 2)
do (def (splitpr n h) @
  iterate {n - 2} (fn (x) '(! splitpr1 _ _ _ _ ,(dummy! 'nat) ,x)) @ list 'splitpr1 @
  iterate {n - 2} (fn (x) '(splitpr2 ,x)) '(exp ,h));

theorem odd0: $ ~ odd 0 $ = '(mtbir (eqeq1 mod01) (mt eqcom d1ne0));
theorem oddS: $ odd (suc n) <-> ~odd n $ =
'(bitr odddvd @ noteq @ bitr4 d2dvdS odddvd);
theorem odd1: $ odd 1 $ = '(mpbir oddS odd0);

@_ def pr (a b: nat): nat = $ (a + b) * suc (a + b) // 2 + b $;
infixr pr: $<>$ prec 55;

theorem nfpr (a b: nat x) (h1: $ FN/ x a $) (h2: $ FN/ x b $): $ FN/ x a <> b $ =
'(!! nfnlem2 _ y z (preqd anl anr) h1 h2);

theorem preqadd: $ a <> b = (a + b <> 0) + b $ =
'(eqcom @ addeq1 @ eqtr add0 @ diveq1 @ muleq add0 @ suceq add0);

theorem prlem1: $ 2 || n * suc n $ = '(cases dvdmul11 @ sylbir d2dvdS dvdmul12);

theorem prlem2: $ a <> c <= b <> d -> a + c <= b + d $ =
(focus
  '(sylibr lenlt @ mtd (sylib ltnle _) (exp @ sylibr (lemul2 d0lt2) _))
  '(lelttrd (letr leaddid1) @ a1i @ mpbi ltadd2 @ mpbi leltsuc leaddid2)
  '(mpbird
    (leeqd
      (syl6eqr addmul @ syl5eq muladd @ addeq1d @ a1i @ muldiv3 prlem1)
      (a1i @ eqtr (muldiv3 prlem1) mulcom))
    (lemuld (sylibr (leeq1 addS) @ sylib lesuc @ sylibr (leeq1 add12) anr) anr)));

theorem prth: $ a <> c = b <> d <-> a = b /\ c = d $ =
(focus
  '(ibii _ (preqd anl anr))
  (have 'h $ (a <> c = b <> d) -> a + c = b + d $
    '(leasymd (syl prlem2 eqle) (syl prlem2 eqler)))
  (have 'h2 $ (a <> c = b <> d) -> c = d $
    '(sylib addcan2 @ mpbid (rsyl h @ eqeq1d @
      addeq1d @ diveq1d @ muleqd id suceq) id))
  '(iand (sylib addcan1 @ eqtr4d h @ sylibr addcan2 h2) h2));

theorem prltsuc: $ a <> b < suc (a + b) <> 0 $ =
'(mpbir ltnle @ mt prlem2 @ mpbi ltnle @ mpbir (lteq2 add0) ltsucid);

theorem addlepr: $ a + b <= a <> b $ =
'(letr
  (cases (mpbiri le01 leeq1) @ sylibr (ledivmul2 d2ne0) @
    sylbi (bitr3 le11 lesuc) lemul2a)
  leaddid1);

theorem leprid1: $ a <= a <> b $ = '(letr leaddid1 addlepr);
theorem leprid2: $ b <= a <> b $ = '(letr leaddid2 addlepr);

theorem lepr1tr (h: $ a <= b $): $ a <= b <> c $ = '(letr h leprid1);
theorem lepr2tr (h: $ a <= c $): $ a <= b <> c $ = '(letr h leprid2);
theorem ltpr1tr (h: $ a < b $): $ a < b <> c $ = '(ltletr h leprid1);
theorem ltpr2tr (h: $ a < c $): $ a < b <> c $ = '(ltletr h leprid2);

theorem lepr1: $ a <= b <-> a <> c <= b <> c $ =
'(ibii
  (syla contra @ syl eqle @ preq1d @
    leasymd anl @ sylibr leadd1 @ syl prlem2 @ anwr leorle)
  (sylibr leadd1 prlem2));
theorem lepr2: $ b <= c <-> a <> b <= a <> c $ =
'(ibii
  (syla contra @ syl eqle @ preq2d @
    leasymd anl @ sylibr leadd2 @ syl prlem2 @ anwr leorle)
  (sylibr leadd2 prlem2));

theorem ltpr1: $ a < b <-> a <> c < b <> c $ =
'(bitr4gi ltnle ltnle @ noteq lepr1);
theorem ltpr2: $ b < c <-> a <> b < a <> c $ =
'(bitr4gi ltnle ltnle @ noteq lepr2);

@_ abstract def fst (a: nat): nat = $ the {x | E. y a = x <> y} $;
@_ abstract def snd (a: nat): nat = $ the {y | E. x a = x <> y} $;

pub theorem pr0: $ 0 <> 0 = 0 $ =
'(eqtr (addeq1 @ eqtr (diveq1 @ eqtr (muleq1 add0) mul01) div01) add0);

theorem expr: $ E. x E. y a = x <> y $ =
(focus
  (mk-ind '(! ind u v _ $ E. x E. y u = x <> y $ _ _ _ _)
    '(exeqd @ exeqd eqeq1)
    '(trud @ iexde @ iexde @ syl5eqr pr0 @ eqcomd @ preqd anlr anr)
    '(sylib (cbvex @ cbvexd @ eqeq2d @ preqd anl anr) @
      eex @ eex @ casesd _ _))
  (focus
    '(exp @ !! iexde m @ !! iexde n _)
    (have 'h3 $ _ /\ m = suc y /\ n = 0 -> m + n = suc y $
      '(syl6eq add0 (addeqd anlr anr)))
    (have 'h4 $ _ /\ x = 0 /\ m = suc y /\ n = 0 -> x + y = y $
      '(syl6eq add01 @ addeq1d @ anwll anr))
    '(eqtrd (suceqd an3l) @ syl5eqr addS @ eqtr4d (sylib (mulcan2 d2ne0) _)
      (syl6eq add0 @ addeqd (diveq1d @ muleqd h3 @ suceqd h3) anr))
    '(syl5eq muladd @ syl6eqr (eqtr (muldiv3 prlem1) mulcom) _)
    '(eqtrd
      (addeq1d @ syl5eq (muldiv3 prlem1) @ muleqd h4 @ suceqd h4)
      (syl5eqr addmul @ a1i @ muleq1 @ eqtr addS @ suceq add12)))
  (focus
    (have 'h $ _ /\ x = suc z /\ m = z /\ n = suc y -> x + y = m + n $
      '(eqtr4d
        (syl6eq addSass @ anwll @ anwr addeq1)
        (addeqd anlr anr)))
    '(syl5bi exsuc @ !! eexda z @ !! iexde m @ !! iexde n @
      eqtrd (anw3l suceq) @ syl5eqr addS @ addeqd
      (diveq1d @ muleqd h @ suceqd h) (eqcomd anr))));

theorem splitpr1 {x y} (h: $ G -> a = x <> y -> p $): $ G -> p $ =
'(mpi expr @ eexd @ eexd h);

theorem splitpr2 (h: $ G -> a = x <> y <> z -> p $):
  $ G -> yz = y <> z -> a = x <> yz -> p $ =
'(exp @ exp @ sylc h anll @ eqtrd anr @ preq2d anlr);

do {
  -- Proves $ G -> a = a1 <> ... <> an -> p $ > $ G -> p $ (where n >= 1)
  (def (splitpr n h)
    @ if {n = 1} (list 'eqerd h) @
    iterate {n - 2} (fn (x) '(! splitpr1 _ _ _ _ ,(dummy! 'nat) ,x)) @ list 'splitpr1 @
    iterate {n - 2} (fn (x) '(splitpr2 ,x)) h)

  -- Performs a case analysis on sums of products.
  -- Proves $ G -> p $ given proofs of facts like $ G /\ a = b0 (b1 (b0 (a1 <> ... <> an))) -> p $.
  -- The input takes a form such as `(split-sop '{(1 => pr1) + {(3 => pr2) + (2 => pr3)}})`,
  -- which expects:
  --   * `pr1 : G /\ ?a = b0 ?x1 -> p`
  --   * `pr2 : G /\ ?a = b1 (b0 (?y1 <> ?y2 <> ?y3)) -> p`
  --   * `pr3 : G /\ ?a = b1 (b1 (?z1 <> ?z2)) -> p`
  -- The alternative form `n as e => p` provides an expression `e` for each branch
  -- in place of e.g. `b1 (b0 (a <> b <> c))`.
  (def (split-sop hs)
    @ letrec
      ([(f hs g) @ match hs
        [{hs0 '+ hs1} @ list 'splitb
          (f hs0 @ fn (x) '(splitb0 ,(g x)))
          (f hs1 @ fn (x) '(splitb1 ,(g x)))]
        [((? number? n) '=> h) (splitpr n (g '(exp ,h)))]
        [((? number? n) 'as e '=> h)
          (splitpr n (g '{(exp ,h) : $ _ -> _ = ,e -> _ $}))]
        [((and e (...)) '=> h)
          (splitpr {(len e) - 1} (g '{(exp ,h) : $ _ -> _ = ,e -> _ $}))]])
      (f hs id))
};

pub theorem fstpr (a b: nat): $ fst (a <> b) = a $ =
'(trud @ !! eqtheabd x @ a1i @ ibii
  (!! eex y @ sylbi prth @ eqcomd anl)
  (rsyl (eqcomd preq1) @ iexe @ eqeq2d preq2));
pub theorem sndpr (a b: nat): $ snd (a <> b) = b $ =
'(trud @ !! eqtheabd y @ a1i @ ibii
  (!! eex x @ sylbi prth @ eqcomd anr)
  (rsyl (eqcomd preq2) @ iexe @ eqeq2d preq1));
pub theorem fstsnd (a: nat): $ fst a <> snd a = a $ =
'(!! eex x (!! eex y @ eqtr4d (preqd (syl6eq fstpr fsteq) (syl6eq sndpr sndeq)) id) expr);

theorem fstleid: $ fst a <= a $ = '(mpbi (leeq2 fstsnd) leprid1);
theorem sndleid: $ snd a <= a $ = '(mpbi (leeq2 fstsnd) leprid2);

theorem eqrd2 (G) {x y} (h: $ G -> (x <> y e. A <-> x <> y e. B) $): $ G -> A == B $ =
'(!! eqrd p @ mpi expr @ eexd @ eexd @ syl5ibrcom (bieqd eleq1 eleq1) h);
theorem eqri2 {x y} (h: $ x <> y e. A <-> x <> y e. B $): $ A == B $ = '(trud @ eqrd2 @ a1i h);

theorem fst0: $ fst 0 = 0 $ = '(eqtr3 (fsteq pr0) fstpr);
theorem snd0: $ snd 0 = 0 $ = '(eqtr3 (sndeq pr0) sndpr);

@_ def pi11 (n: nat): nat = $ fst (fst n) $;
@_ def pi12 (n: nat): nat = $ snd (fst n) $;
@_ def pi21 (n: nat): nat = $ fst (snd n) $;
@_ def pi22 (n: nat): nat = $ snd (snd n) $;
@_ def pi221 (n: nat): nat = $ fst (pi22 n) $;
@_ def pi222 (n: nat): nat = $ snd (pi22 n) $;

theorem pi11pr: $ pi11 ((a <> b) <> c) = a $ = '(eqtr (fsteq fstpr) fstpr);
theorem pi12pr: $ pi12 ((a <> b) <> c) = b $ = '(eqtr (sndeq fstpr) sndpr);
theorem pi21pr: $ pi21 (a <> b <> c) = b $ = '(eqtr (fsteq sndpr) fstpr);
theorem pi22pr: $ pi22 (a <> b <> c) = c $ = '(eqtr (sndeq sndpr) sndpr);
theorem pi221pr: $ pi221 (a <> b <> c <> d) = c $ = '(eqtr (fsteq pi22pr) fstpr);
theorem pi222pr: $ pi222 (a <> b <> c <> d) = d $ = '(eqtr (sndeq pi22pr) sndpr);

@(derive-eq 'isf) def isfun (A: set): wff =
$ A. a A. b A. b2 (a <> b e. A -> a <> b2 e. A -> b = b2) $;

theorem isfd (h1: $ G -> isfun F $)
  (h2: $ G -> a <> b e. F $) (h3: $ G -> a <> b2 e. F $):
  $ G -> b = b2 $ =
'(mpd h3 @ mpd h2 @ mpd h1 @ !! ealde x @ !! ealde y @ !! ealde z @ bi1d @
  imeqd (eleq1d @ preqd anllr anlr) @
  imeqd (eleq1d @ preqd anllr anr) @ eqeqd anlr anr);

theorem isfbd (h1: $ G -> isfun F $) (h2: $ G -> a <> b e. F $):
  $ G -> (a <> b2 e. F <-> b = b2) $ =
'(ibida (isfd (anwl h1) (anwl h2) anr) @ mpbid (eleq1d @ anwr preq2) (anwl h2));

theorem isfss: $ A C_ B -> isfun B -> isfun A $ =
'(exp @ !! iald a @ !! iald b @ !! iald c @ exp @ exp @
  isfd anllr (sseld an3l anlr) (sseld an3l anr));

@_ def sab {x: nat} (A: set x): set =
$ {z | snd z e. S[fst z / x] A} $;
notation sab {x: nat} (A: set x): set = ($S\$:100) x ($,$:0) A;

theorem cbvsabs (A: set x): $ S\ x, A == S\ y, (S[y / x] A) $ =
'(!! abeqi z @ eleq2 @ eqscom sbsco);

theorem elsabs (A: set x): $ a <> b e. S\ x, A <-> b e. (S[a / x] A) $ =
'(!! elabe p @ eleqd (syl6eq sndpr sndeq) (sbseq1d @ syl6eq fstpr fsteq));

theorem elsab (A: set x) (h: $ x = a -> A == B $):
  $ a <> b e. S\ x, A <-> b e. B $ =
'(bitr elsabs @ eleq2 @ sbse h);

theorem elsabed (A: set x) (h: $ G /\ x = a -> (b e. A <-> p) $):
  $ G -> (a <> b e. S\ x, A <-> p) $ =
'(syl5bb elsabs @ mpi ax_6 @ eexdh nfv (nfbi (nfel2 nfsbs1) nfv) @
  exp @ bitr3d (eleq2d @ anwr sbsq) h);

theorem elsabe (A: set x) (h: $ x = a -> (b e. A <-> p) $):
  $ a <> b e. S\ x, A <-> p $ = '(trud @ elsabed @ anwr h);

theorem eexsabd {z} (y: nat x z) (A: set x) (h: $ G -> z e. A -> p $):
  $ G -> y e. S\ x, A -> p $ =
'(syl5 (iexe eleq1) @ !! eexd w @
  syl5bir (eleq1 fstsnd) @ syl5bi elsabs @
  syl5 (iexe eleq1) @ eexd @
  sbethh (nfim nfv @ nfim (nfel2 nfsbs1) nfv) (imeq2d @ imeq1d @ eleq2d sbsq) h);

-- Indexed disjoint union, a restricted version of S\
@_ def xab {x: nat} (A: set) (B: set x): set =
$ {z | fst z e. A /\ snd z e. S[fst z / x] B} $;
notation xab {x: nat} (A: set) (B: set x): set =
  ($X\$:100) x ($e.$:50) A ($,$:0) B;

theorem xabeq2da (B C: set x) (h: $ G /\ x e. A -> B == C $):
  $ G -> X\ x e. A, B == X\ x e. A, C $ =
'(!! abeqd z @ syl aneq2a @ syl6 eleq2 @
  syl (ealeh (nfim nfv @ nfeqs nfsbs1 nfsbs1) @
    imeqd eleq1 @ eqseqd sbsq sbsq) @ iald @ exp h);

theorem cbvxabs (B: set x): $ X\ x e. A, B == X\ y e. A, (S[y / x] B) $ =
'(!! abeqi z @ aneq2i @ eleq2 @ eqscom sbsco);

theorem elxabs (B: set x):
  $ a <> b e. X\ x e. A, B <-> a e. A /\ b e. (S[a / x] B) $ =
'(!! elabe p @ aneqd (eleq1d @ syl6eq fstpr fsteq) @
  eleqd (syl6eq sndpr sndeq) (sbseq1d @ syl6eq fstpr fsteq));

theorem elxab (B: set x) (h: $ x = a -> B == C $):
  $ a <> b e. X\ x e. A, B <-> a e. A /\ b e. C $ =
'(bitr elxabs @ aneq2i @ eleq2 @ sbse h);

theorem elxabed (B: set x) (h: $ G /\ x = a -> (b e. B <-> p) $):
  $ G -> (a <> b e. X\ x e. A, B <-> a e. A /\ p) $ =
'(syl5bb elxabs @ mpi ax_6 @ eexdh nfv (nfbi (nfan nfv @ nfel2 nfsbs1) nfv) @
  exp @ aneq2d @ bitr3d (eleq2d @ anwr sbsq) h);

theorem elxabe (B: set x) (h: $ x = a -> (b e. B <-> p) $):
  $ a <> b e. X\ x e. A, B <-> a e. A /\ p $ =
'(trud @ elxabed @ anwr h);

theorem xabssd (B C: set x) (h: $ G /\ x e. A -> B C_ C $):
  $ G -> X\ x e. A, B C_ X\ x e. A, C $ =
(named '(sylib ssab @ iald @ syl anim2a @ exp @ syl ssel @
  sbethh (nfim nfv @ nfss nfsbs1 nfsbs1)
    (imeqd (aneq2d eleq1) (sseqd sbsq sbsq)) h));

theorem sabxab {y} (B: set x) (h: $ G -> y e. B -> x e. A $):
  $ G -> S\ x, B == X\ x e. A, B $ =
'(!! eqrd2 z y @ bitr4g elsabs elxabs @ bicomd @ syl bian1a @
  sbethh (nfim nfv @ nfim (nfel2 nfsbs1) nfv) (imeq2d @ imeqd (eleq2d sbsq) eleq1) h);

@_ def opab {x y: nat} (p: wff x y): set =
$ {z | E. x E. y (z = x <> y /\ p)} $;

theorem elopabs (p: wff x y): $ a <> b e. opab x y p <-> [a / x] [b / y] p $ =
'(!! elabe z @ syl6bbr dfsb3 @ exeqd @ syl6bbr (aneq2i dfsb3) @ syl6bb exan1 @
  exeqd @ syl6bb anass @ aneq1d @ syl6bb prth @ syl6bb eqcomb eqeq1);

theorem opabsab (p: wff x y): $ opab x y p == S\ x, {y | p} $ =
'(!! eqri2 a b @ bitr4 elopabs @ bitr elsabs @ bitr elsbs @ sbeq2i elab);

theorem elopabd (p: wff x y) (h: $ G /\ x = a /\ y = b -> (p <-> q) $):
  $ G -> (a <> b e. opab x y p <-> q) $ = '(syl5bb elopabs @ sbed @ sbed h);
theorem elopab (p: wff x y) (h: $ x = a /\ y = b -> (p <-> q) $):
  $ a <> b e. opab x y p <-> q $ = '(bitr elopabs @ sbe @ sbed h);

theorem nfopab1 (p: wff x y): $ FS/ x opab x y p $ = '(!! nfab _ z nfex1);
theorem nfopab2 (p: wff x y): $ FS/ y opab x y p $ = '(!! nfab _ z @ nfex nfex1);
theorem nfopab (p: wff x y z) (h: $ F/ x p $): $ FS/ x opab y z p $ =
'(!! nfab _ w @ nfex @ nfex @ nfan nfv h);

@(derive-eq 'xp) def Xp (A B: set): set = $ opab x y (x e. A /\ y e. B) $;

theorem nfxp (A B: set x) (h1: $ FS/ x A $) (h2: $ FS/ x B $): $ FS/ x Xp A B $ =
'(!! nfopab _ y z @ nfan (nfel2 h1) (nfel2 h2));
theorem prelxp: $ a <> b e. Xp A B <-> a e. A /\ b e. B $ =
'(!! elopab x y (aneqd (eleq1d anl) (eleq1d anr)));
theorem elxp: $ a e. Xp A B <-> fst a e. A /\ snd a e. B $ =
'(bitr3 (eleq1 fstsnd) prelxp);
theorem xpvv: $ Xp _V _V == _V $ =
'(!! eqri p @ bith (mpbir elxp @ ian elv elv) elv);
theorem xpfst: $ a e. Xp A B -> fst a e. A $ = '(sylbi elxp anl);
theorem xpsnd: $ a e. Xp A B -> snd a e. B $ = '(sylbi elxp anr);

theorem xpfin: $ finite A -> finite B -> finite (Xp A B) $ =
'(!! eex m @ !! eexda n @ syl (!! iexe z @ aleqd @ imeq2d lteq2) @
  !! iald p @ syl5bi elxp @ syl6
    (sylib (lteq1 fstsnd) @ imp @ sylibr (imeqi ltnle ltnle) @ con3d @
      syl5 prlem2 @ syl5bi (leeq1 add0) @
      syl6ibr leadd2 @ syl letr @ sylib leadd1 ltle)
    (animd
      (anwl @ !! eale x @ imeqd eleq1 lteq1)
      (anwr @ !! eale y @ imeqd eleq1 lteq1)));

theorem xabconst: $ X\ x e. A, B == Xp A B $ =
(named '(eqri2 @ bitr4 (elxab eqsidd) prelxp));

@(derive-eq 'dm) def Dom (A: set): set = $ {x | E. y x <> y e. A} $;
@(derive-eq 'rn) def Ran (A: set): set = $ {y | E. x x <> y e. A} $;
@(derive-eq 'ima) def Im (F A: set): set = $ {y | E. x (x e. A /\ x <> y e. F)} $;
infixl Im: $''$ prec 80;

theorem eldm: $ a e. Dom A <-> E. y a <> y e. A $ = '(!! elabe x @ exeqd @ eleq1d preq1);
theorem elrn: $ a e. Ran A <-> E. x x <> a e. A $ = '(!! elabe y @ exeqd @ eleq1d preq2);
theorem preldm: $ a <> b e. A -> a e. Dom A $ = '(sylibr eldm @ !! iexe y @ eleq1d preq2);
theorem prelrn: $ a <> b e. A -> b e. Ran A $ = '(sylibr elrn @ !! iexe x @ eleq1d preq1);
theorem fsteldm: $ p e. A -> fst p e. Dom A $ = '(sylbir (eleq1 fstsnd) preldm);
theorem sndelrn: $ p e. A -> snd p e. Ran A $ = '(sylbir (eleq1 fstsnd) prelrn);

theorem dmfin: $ finite A -> finite (Dom A) $ =
(named '(eximi @ iald @ syl5bi eldm @ eexd @
  syl6 (lelttr leprid1) (eale @ imeqd eleq1 lteq1)));
theorem rnfin: $ finite A -> finite (Ran A) $ =
(named '(eximi @ iald @ syl5bi elrn @ eexd @
  syl6 (lelttr leprid2) (eale @ imeqd eleq1 lteq1)));

theorem elima: $ b e. F '' A <-> E. x (x e. A /\ x <> b e. F) $ =
'(!! elabe y @ exeqd @ aneq2d @ eleq1d preq2);
theorem elimai: $ a <> b e. F -> a e. A -> b e. F '' A $ =
'(expcom @ sylibr elima @ !! iexe x @ aneqd eleq1 @ eleq1d preq1);
theorem imv: $ F '' _V == Ran F $ =
'(!! eqri x @ bitr4 elima @ bitr4 elrn @ !! exeqi y @ bian1 elv);

@_ def cnv (A: set): set = $ opab x y (y <> x e. A) $;

@(derive-eq 'co) def comp (F G: set): set =
$ opab x z (E. y (x <> y e. G /\ y <> z e. F)) $;
infixr comp: $o.$ prec 91;

@_ def res (A B: set): set = $ A i^i Xp B _V $;
infixl res: $|`$ prec 54;

theorem nfres (A B: set x) (h1: $ FS/ x A $) (h2: $ FS/ x B $): $ FS/ x A |` B $ =
'(nfin h1 @ nfxp h2 nfsv);
theorem elres: $ a e. A |` B <-> a e. A /\ fst a e. B $ =
'(bitr elin @ aneq2i @ bitr elxp @ bian2 elv);
theorem prelres: $ a <> b e. A |` B <-> a <> b e. A /\ a e. B $ =
'(bitr elres @ aneq2i @ eleq1 fstpr);
theorem resss: $ A |` B C_ A $ = 'inss1;
theorem resv: $ F |` _V == F $ = '(eqstr (ineq2 xpvv) inv2);
theorem resfin: $ finite F -> finite (F |` A) $ = '(finss resss);
theorem resisf: $ isfun F -> isfun (F |` A) $ = '(isfss resss);
theorem dmres: $ Dom (F |` A) == Dom F i^i A $ =
'(!! eqri x @ bitr (!! eldm y) @ bitr4 (exeqi prelres) @
  bitr elin @ bitr4 (aneq1i eldm) exan2);
theorem rnres: $ Ran (F |` A) == F '' A $ =
(named '(abeqi @ exeqi @ bitr prelres ancomb));

@_ def lam {x: nat} (a: nat x): set = $ {p | E. x p = x <> a} $;
notation lam {x: nat} (a: nat x): set = ($\$:53) x ($,$:0) a;

theorem ellam (a: nat x): $ p e. (\ x, a) <-> E. x p = x <> a $ =
'(!! elabe q @ exeqd eqeq1);
theorem lameq (a b: nat x): $ A. x a = b -> (\ x, a) == (\ x, b) $ =
'(sylib (!! abeqb p) @ iald @ syl exeq @ alimi @ eqeq2d preq2);
theorem lameqi (a b: nat x) (h: $ a = b $): $ (\ x, a) == (\ x, b) $ = '(lameq @ ax_gen h);
theorem nflam1 (a: nat x): $ FS/ x \ x, a $ = '(!! nfab _ p nfex1);
theorem nflam (a: nat x y) (h: $ FN/ x a $): $ FS/ x \ y, a $ =
'(!! nfab _ p @ nfex @ nf_eq nfnv @ nfpr nfnv h);
theorem cbvlamh (a b: nat x y) (h1: $ FN/ y a $) (h2: $ FN/ x b $)
  (e: $ x = y -> a = b $): $ (\ x, a) == (\ y, b) $ =
'(!! cbvab p1 p2 @ syl5bb
  (cbvexh (nfeq2 @ nfpr nfnv h1) (nfeq2 @ nfpr nfnv h2) @ eqeq2d @ preqd id e) @
  exeqd eqeq1);
theorem cbvlam (a: nat x) (b: nat y)
  (e: $ x = y -> a = b $): $ (\ x, a) == (\ y, b) $ = '(cbvlamh nfnv nfnv e);
theorem cbvlams (a: nat x): $ (\ x, a) == (\ y, N[y / x] a) $ = '(cbvlamh nfnv nfsbn1 sbnq);
theorem cbvlamd (G) (a: nat x) (b: nat y)
  (h: $ G /\ x = y -> a = b $): $ G -> (\ x, a) == (\ y, b) $ =
'(eqstrd (a1i cbvlams) @ lameqd @ syl sbnet @ iald @ exp h);

theorem lamisf (a: nat x): $ isfun (\ x, a) $ =
'(!! ax_gen u @ !! ax_gen v @ !! ax_gen w @
  sylbi ellam @ eexh (nfim (nfel2 nflam1) nfv) @ sylbi prth @
  syl5bi (bitr ellam @
    cbvexh nfv (nfeq2 @ nfpr nfnv nfsbn1) @ eqeq2d @ preqd id sbnq) @
  !! eexd y @ syl5bi prth @ exp @ eqtr4d anlr @ eqtr4d anrr @ syl sbnq @
  eqtr3d anll anrl);

theorem finlam (v: nat x): $ finite A -> finite ((\ x, v) |` A) $ =
(focus
  (have 'h (mk-ind '(! ind a b _ $ E. n A. x (x < a -> x <> v < n) $ _ _ _ _)
    '(exeqd @ aleqd @ imeq1d @ lteq2)
    '(trud @ ! iexde _ _ $0$ _ @ iald @ a1i @ absurd lt02)
    '(sylibr (!! cbvex _ m @ aleqd @ imeq2d @ lteq2) @
      eex @ syl (iexe @
        aleqdh (nfeq2 @ nfmax nfnv @ nfsuc @ nfpr nfnv nfsbn1) @
        imeq2d @ lteq2) @
      alimi @ syl5bir leltsuc @ syl5bi leloe @ eord
        (imim2i @ mpi lemax1 ltletr)
        (a1i @ mpbii lemax2 @ lteq2d @
          maxeqd eqidd @ suceqd @ preqd id sbnq))))
  '(!! eex m @ mpi h @ eximd @ syl6 _ @ al2imi @ exp @ syld anl anr)
  '(!! iald p @ syl5bi elres @ sylibr impexp @
    syl5bi (!! elabe q @ exeqd eqeq1) @ sylibr eexb @ alimi @
    syl5ibrcom (imeqd (eleq1d @ syl6eq fstpr fsteq) lteq1) id));

theorem ellamima (v: nat x): $ a e. (\ x, v) '' A <-> E. x (x e. A /\ a = v) $ =
'(bitr elima @ bitr (exeqi @ bitr4 (aneq2i ellam) exan1) @ bitr excomb @
  exeqi @ bitr (exeqi @ bitr (aneq2i prth) anlass) @ !! exeqe y @ aneq1d eleq1);

theorem ellamimaab (v: nat x) (p: wff x): $ a e. (\ x, v) '' {x | p} <-> E. x (p /\ a = v) $ =
'(bitr (eleq2 @ imaeq1 cbvlams) @ bitr4 (!! ellamima y) @
  cbvexh nfv (nfan (nfel2 nfab1) (nfeq2 nfsbn1)) @ aneqd (syl6bbr elab sbq) (eqeq2d sbnq));

theorem finlamima (v: nat x): $ finite A -> finite ((\ x, v) '' A) $ =
'(sylib (fineq rnres) @ syl rnfin finlam);

theorem lameqb (a b: nat x): $ A. x a = b <-> (\ x, a) == (\ x, b) $ =
'(ibii lameq @ sylbir (!! abeqb p) @
  sylibr (!! cbvalh x y nfv (nf_eq nfsbn1 nfsbn1) (eqeqd sbnq sbnq)) @
  iald @ syl (eex @ sylbi prth @ imp @ bi2d @ eqeq2d sbneq1) @
  mpbii (iexe (eqeq2d @ preqd id sbneq1) eqid) @ eale @ bieqd
    (syl5bb (!! cbvexh x z nfv
      (nfeq2 @ nfpr nfnv nfsbn1) @ eqeq2d @ preqd id sbnq) (exeqd eqeq1))
    (syl5bb (!! cbvexh x z nfv
      (nfeq2 @ nfpr nfnv nfsbn1) @ eqeq2d @ preqd id sbnq) (exeqd eqeq1)));

theorem reslameq (a b: nat x):
  $ A. x (x e. A -> a = b) -> (\ x, a) |` A == (\ x, b) |` A $ =
'(!! eqrd p @ bitr4g elres elres @ syla aneq1a @
  bitr4g ellam ellam @ syl exeq @ impcom @ alimd @ exp @
  rbida (syl6eq fstpr (fsteqd anr)) (syl6eq fstpr (fsteqd anr)) @
  eqeq2d @ preq2d @ mpd (mpbid (eleq1d anr) anll) anlr);

theorem dmlam (a: nat x): $ Dom (\ x, a) == _V $ =
'(!! eqri y @ bith (preldm @ mpbir (eleq2 cbvlams) @
  mpbir ellam @ !! iexe z (eqeq2d @ preqd id sbneq1) eqid) elv);

theorem dmreslam (a: nat x): $ Dom ((\ x, a) |` A) == A $ =
'(eqstr dmres @ eqstr (ineq1 dmlam) inv1);

@_ def app (F: set) (x: nat): nat = $ the {y | x <> y e. F} $;
infixl app: $@$ prec 200;

theorem nfapp (F: set x) (a: nat x) (h1: $ FS/ x F $) (h2: $ FN/ x a $):
  $ FN/ x F @ a $ = '(nfthe @ !! nfab _ y @ nfel (nfpr h2 nfnv) h1);

theorem isfappd (h1: $ G -> isfun F $) (h2: $ G -> a <> b e. F $):
  $ G -> F @ a = b $ =
'(!! eqtheabd x @ syl6bb eqcomb @ isfbd h1 h2);

theorem eqapp: $ A. y (a <> y e. F <-> a <> y e. G) -> F @ a = G @ a $ = '(theeqd abeq);

theorem ndmapp: $ ~a e. Dom F -> F @ a = 0 $ = '(!! eqthe0abd y @ syl5 preldm absurd);

theorem resapp: $ a e. A -> (F |` A) @ a = F @ a $ =
'(syl eqapp @ !! iald y @ syl5bb prelres bian2);

theorem applams (a b: nat x): $ (\ x, a) @ b = N[b / x] a $ =
'(trud @ isfappd (a1i lamisf) @ a1i @ mpbir
  (!! elabe p @ syl5bb
    (cbvexh nfv (nfeq2 @ nfpr nfnv nfsbn1) @ eqeq2d @ preqd id sbnq)
    (!! exeqd z eqeq1))
  (iexe (eqeq2d @ preqd id sbneq1) eqid));
theorem applam (a: nat x): $ (\ x, a) @ x = a $ = '(eqtr applams sbnid);
theorem applame (a: nat x) (e: $ x = b -> a = c $):
  $ (\ x, a) @ b = c $ = '(eqtr applams @ sbne e);
theorem applamed (a: nat x) (e: $ G /\ x = b -> a = c $):
  $ G -> (\ x, a) @ b = c $ = '(syl5eq applams @ sbned e);

theorem lamapp: $ isfun F -> (\ x, F @ x) |` Dom F == F $ =
'(!! eqrd2 y z @ syl5bb prelres @ ibid
  (sylibr impexp @ syl5bi (!! elabe p @ exeqd eqeq1) @ eexd @
    syl5ibrcom (imeqd (eleq1d @ sylbi prth anl) eleq1) @
    syl5bi eldm @ !! eexda y @ mpbird (eleq1d @ preq2d @ isfappd anl anr) anr)
  (exp @ iand (sylibr (!! elabe p @ exeqd eqeq1) @ iexde @ eqcomd @
    preqd anr @ eqtrd (appeq2d anr) @ isfappd anll anlr) (anwr preldm)));

@_ def case (A B: set): set =
  $ \ n, if (odd n) (B @ (n // 2)) (A @ (n // 2)) $;

pub theorem casel (A B: set) (n: nat): $ case A B @ b0 n = A @ n $ =
'(!! applame i @ eqtrd
  (syl ifneg @ mtbird oddeq (a1i b0odd))
  (appeq2d @ syl6eq b0div2 diveq1));
pub theorem caser (A B: set) (n: nat): $ case A B @ b1 n = B @ n $ =
'(!! applame i @ eqtrd
  (syl ifpos @ mpbird oddeq (a1i b1odd))
  (appeq2d @ syl6eq b1div2 diveq1));

@_ abstract def Sum (A B: set): set =
$ {n | ifp (odd n) (n // 2 e. B) (n // 2 e. A)} $;
pub theorem Suml (A B: set) (n: nat): $ b0 n e. Sum A B <-> n e. A $ =
'(!! elabe i @ bitrd
  (syl ifpneg @ mtbird oddeq @ a1i b0odd)
  (eleq1d @ syl6eq b0div2 diveq1));
pub theorem Sumr (A B: set) (n: nat): $ b1 n e. Sum A B <-> n e. B $ =
'(!! elabe i @ bitrd
  (syl ifppos @ mpbird oddeq @ a1i b1odd)
  (eleq1d @ syl6eq b1div2 diveq1));

@_ local def slam {x: nat} (A: set x): set = $ \ p, (S[fst p / x] A) @ snd p $;
notation slam {x: nat} (A: set x): set = ($\\$:30) x ($,$:0) A;

theorem appslams (A: set x): $ (\\ x, A) @ (a <> b) = (S[a / x] A) @ b $ =
'(!! applame p @ appeqd (sbseq1d @ syl6eq fstpr fsteq) (syl6eq sndpr sndeq));

theorem appslam (A: set x) (h: $ x = a -> A == B $):
  $ (\\ x, A) @ (a <> b) = B @ b $ =
'(eqtr appslams @ appeq1 @ sbse h);

theorem appslamed (A: set x) (h: $ G /\ x = a -> A @ b = c $):
  $ G -> (\\ x, A) @ (a <> b) = c $ =
'(syl5eq appslams @ mpi ax_6 @ eexdh nfv (nf_eq (nfapp nfsbs1 nfnv) nfnv) @
  exp @ eqtr3d (appeq1d @ anwr sbsq) h);

theorem appslame (A: set x) (h: $ x = a -> A @ b = c $):
  $ (\\ x, A) @ (a <> b) = c $ = '(trud @ appslamed @ anwr h);

@_ local def least (A: set): nat = $ the {x | x e. A /\ A. y (y e. A -> x <= y)} $;

theorem leastlem: $ a e. A -> least A e. A /\ A. z (z e. A -> least A <= z) $ =
(focus
  (have 'h1 $ A. z (z e. A -> a < z) \/ E. u (u e. A /\ A. z (z e. A -> u <= z)) $
    (mk-ind '(!! ind x y) '(oreq1d @ aleqd @ imeq2d lteq1)
      '(cases
        (orrd @ sylan (iexe @ aneqd eleq1 @ aleqd @ imeq2d leeq1)
          id (a1i @ ax_gen @ a1i le01))
        (orld @ iald @ exp @ sylibr lt01 @
          mtd anl @ com12 @ syl5 anr (bi1d eleq1)))
      '(eor
        (casesda
          (orrd @ sylan (iexe @ aneqd eleq1 @ aleqd @ imeq2d leeq1) anr anl)
          (orld @ ialdh (nfan nfal1 nfv) @ exp @ sylibr ltlene
            (iand (imp @ anwl eal) (mtand anlr @ mpbird (anwr eleq1) anlr))))
        orr)))
  (have 'h2 $ a e. A -> E. u (u e. A /\ A. z (z e. A -> u <= z)) $
    '(syl h1 @ mtd (a1i ltirr) @ com12 @ eale @ imeqd eleq1 lteq2))
  (have 'h3 $ u e. A /\ A. z (z e. A -> u <= z) -> least A = u $
    '(!! eqtheabd v @ ibid
      (exp @ leasymd
        (mpd anll @ anwr @ anwr @ eale @ imeqd eleq1 leeq2)
        (mpd anrl @ anwl @ anwr @ eale @ imeqd eleq1 leeq2))
      (com12 @ bi2d @ aneqd eleq1 @ aleqd @ imeq2d leeq1)))
  '(rsyl h2 @ eex @ mpbird (rsyl h3 @ aneqd eleq1 @ aleqd @ imeq2d @ leeq1) id));

theorem leastel: $ a e. A -> least A e. A $ = '(anld @ !! leastlem x);

theorem leastle: $ a e. A -> least A <= a $ =
'(mpd (!! leastlem x) @ com12 @ anwr @ eale @ imeqd eleq1 leeq2);

theorem least0: $ ~E. x x e. A -> least A = 0 $ =
'(! eqthe0abd _ y $ _ /\ A. z _ $ @ com12 @ syl absurdr @ anwl @ iexe eleq1);

theorem subsnfin: $ subsn A -> finite A $ =
(named '(syl (mpi snfin finss) @ sylib ssab2 @
  iald @ exp @ subsni anl anr @ anwr leastel));

@_ local def znsub (m n) = $ if (m < n) (b1 (n - suc m)) (b0 (m - n)) $;
infixl znsub: $-ZN$ prec 64;

@_ local def zfst (n) = $ case (\ mpos, mpos) (\ mneg, 0) @ n $;
@_ local def zsnd (n) = $ case (\ mpos, 0) (\ mneg, suc mneg) @ n $;

theorem zfstb0: $ zfst (b0 n) = n $ = (named '(eqtr casel @ applame id));
theorem zfstb1: $ zfst (b1 n) = 0 $ = (named '(eqtr caser @ applame eqidd));
theorem zsndb0: $ zsnd (b0 n) = 0 $ = (named '(eqtr casel @ applame eqidd));
theorem zsndb1: $ zsnd (b1 n) = suc n $ = (named '(eqtr caser @ applame suceq));

theorem zfstsnd: $ zfst n -ZN zsnd n = n $ =
'(eor
  (eqtrd (syl ifneg @ sylib lenlt @ mpbiri le01 @
      leeqd (syl6eq zsndb0 zsndeq) (syl6eq zfstb0 zfsteq)) @
    eqtr4d (b0eqd @ syl6eq sub02 @
      subeqd (syl6eq zfstb0 zfsteq) (syl6eq zsndb0 zsndeq)) id)
  (eqtrd (syl ifpos @ mpbiri lt01S @
      lteqd (syl6eq zfstb1 zfsteq) (syl6eq zsndb1 zsndeq)) @
    eqtr4d (b1eqd @ syl6eq (eqtr subSS sub02) @
      subeqd (syl6eq zsndb1 zsndeq) (suceqd @ syl6eq zfstb1 zfsteq)) id)
  b0orb1);

theorem zfstznsub: $ zfst (m -ZN n) = m - n $ =
'(cases
  (eqtr4d (syl6eq zfstb1 @ zfsteqd ifpos) ltsubeq0)
  (syl6eq zfstb0 @ zfsteqd ifneg));

theorem zfstsnd0: $ zfst n = 0 \/ zsnd n = 0 $ =
'(eor (orrd @ syl6eq zsndb0 zsndeq) (orld @ syl6eq zfstb1 zfsteq) b0orb1);

theorem zneqb (a b c d): $ a -ZN c = b -ZN d <-> a + d = b + c $ =
(focus
  '(cases (casesda _ _) (casesda _ _))
  '(bitrd (eqeqd (anwl ifpos) (anwr ifpos)) @
    syl5bb (bitr4 b1can @ bitr addcan2 eqcomb) @ eqeqd
      (syl5eq (eqtr3 (addeq1 addS2) addass) @ addeq2d @ anwr pncan3)
      (syl5eq (eqtr3 (addeq1 @ eqtr addcom addS1) addass) @ addeq2d @ anwl pncan3))
  '(bitrd (eqeqd (anwl ifpos) (anwr ifneg)) @ binthd (a1i b1neb0) @
    syl ltne @ ltletrd (sylib ltadd1 anl) @
    sylib (leeq2 addcom) @ sylib leadd2 @ sylibr lenlt anr)
  '(bitrd (eqeqd (anwl ifneg) (anwr ifpos)) @ binthd (a1i b0neb1) @
    syl ltner @ lelttrd (sylib leadd2 @ sylibr lenlt anl) @
    sylib (bitr ltadd2 @ lteq1 addcom) anr)
  '(bitrd (eqeqd (anwl ifneg) (anwr ifneg)) @
    syl5bb b0can @ syl5bbr addcan1 @ eqeqd
      (syl5eqr addass @ addeq1d @ syl npcan @ sylibr lenlt anl)
      (syl5eqr addass @ syl5eq add32 @ addeq1d @ syl npcan @ sylibr lenlt anr)));

@_ local def zneg (n) = $ zsnd n -ZN zfst n $;
prefix zneg: $-uZ$ prec 100;

theorem znegzn: $ -uZ (a -ZN b) = b -ZN a $ =
'(mpbir zneqb @ eqtr addcom @ eqtr3 (mpbi zneqb zfstsnd) addcom);

theorem znegneg: $ -uZ -uZ n = n $ = '(eqtr znegzn zfstsnd);

theorem zfstneg: $ zfst (-uZ n) = zsnd n $ =
'(eqtr (zfsteq @ eqtr3 znegzn @ znegeq zfstsnd) @
  eqtr zfstznsub @
  eor (syl6eq sub02 subeq2) (eqtr4d subeq1 @ syl6eqr sub01 id) zfstsnd0);

theorem zsndneg: $ zsnd (-uZ n) = zfst n $ = '(eqtr3 zfstneg @ zfsteq znegneg);

theorem zsndznsub: $ zsnd (m -ZN n) = n - m $ =
'(eqtr3 zfstneg @ eqtr (zfsteq znegzn) zfstznsub);

@_ local def zadd (m n) = $ (zfst m + zfst n) -ZN (zsnd m + zsnd n) $;
infixl zadd: $+Z$ prec 64;

theorem zaddzn: $ (a -ZN c) +Z (b -ZN d) = (a + b) -ZN (c + d) $ =
'(mpbir zneqb @ eqtr add4 @
  eqtr (addeq (mpbi zneqb zfstsnd) (mpbi zneqb zfstsnd)) add4);

@_ local def zmul (m n) =
$ (zfst m * zfst n + zsnd m * zsnd n) -ZN
  (zfst m * zsnd n + zsnd m * zfst n) $;
infixl zmul: $*Z$ prec 70;

theorem zmulznlem (a1 b1 c1 d1 a2 b2 c2 d2)
  (h1: $ a1 + c2 = a2 + c1 $) (h2: $ b1 + d2 = b2 + d1 $):
  $ (a1 * b1 + c1 * d1) + (a2 * d2 + b2 * c2) =
    (a2 * b2 + c2 * d2) + (a1 * d1 + c1 * b1) $ =
(focus
  (have 'h3 $ b1 * c2 + (a1 * b1 + a2 * d2) = a2 * b2 + c1 * b1 + a2 * d1 $
    '(eqtr addcom @ eqtr add32 @
      eqtr (addeq1 @ eqtr (addeq2 mulcom) @ eqtr3 addmul @ eqtr (muleq1 h1) addmul) @
      eqtr add32 @
      eqtr (addeq1 @ eqtr3 muladd @ eqtr (muleq2 h2) muladd)
      add32))
  (have 'h4 $ b1 * c2 + (c2 * d2 + a1 * d1) = a2 * d1 + (c1 * d1 + b2 * c2) $
    '(eqtr3 addass @
      eqtr (addeq1 @ eqtr (addeq2 mulcom) @ eqtr3 addmul @ eqtr (muleq1 h2) @ addmul) @
      eqtr addass @
      eqtr4 (addeq2 @
        eqtr (addeq1 mulcom) @ eqtr addcom @
        eqtr3 addmul @ eqtr (muleq1 h1) addmul) @
      eqtr3 addass addcom))
  '(eqtr add4 @ eqtr (mpbi addcan2 _) @ eqtr add4 (addeq2 addcom))
  '(eqtr3 addass @ eqtr (addeq1 h3) @
    eqtr addass @ eqtr3 (addeq2 h4) @
    eqtr3 addass @ eqtr (addeq1 addcom) addass));

theorem zmulzn: $ (a -ZN c) *Z (b -ZN d) = (a * b + c * d) -ZN (a * d + b * c) $ =
'(mpbir zneqb @ zmulznlem (mpbi zneqb zfstsnd) (mpbi zneqb zfstsnd));

@_ local def zabs (n) = $ zfst n + zsnd n $;

theorem zabsb0: $ zabs (b0 n) = n $ = '(eqtr (addeq zfstb0 zsndb0) add0);
theorem zabsneg: $ zabs (-uZ n) = zabs n $ = '(eqtr addcom @ addeq zsndneg zfstneg);
theorem zabszn: $ zabs (m -ZN n) = (m - n) + (n - m) $ = '(addeq zfstznsub zsndznsub);
theorem lezabszn: $ n <= m -> zabs (m -ZN n) = m - n $ =
'(syl5eq zabszn @ syl6eq add0 @ sylbi lesubeq0 addeq2);
theorem zabscom: $ zabs (m -ZN n) = zabs (n -ZN m) $ =
'(eqtr zabszn @ eqtr4 addcom zabszn);

@_ local def zdvd (m n) = $ zabs m || zabs n $;
infixl zdvd: $|Z$ prec 50;

theorem eqmdvdsub2: $ mod(n): a = b <-> n || zabs (b -ZN a) $ =
'(eor (bitr4d eqmdvdsub @ dvdeq2d lezabszn)
  (syl5bb eqmcomb @ bitr4d eqmdvdsub @
    dvdeq2d @ syl5eq zabscom lezabszn)
  leorle);

theorem eqmzdvdsub: $ mod(n): a = b <-> b0 n |Z b -ZN a $ =
'(bitr4 eqmdvdsub2 @ dvdeq1 zabsb0);

@_ local def zmod (a n: nat): nat = $ (zfst a + n - zsnd a % n) % n $;
infixl zmod: $%Z$ prec 70;

@_ local def gcd (a b: nat): nat = $ the {d | A. x (x || d <-> x || a /\ x || b)} $;

theorem gcdcom: $ gcd a b = gcd b a $ =
'(theeqd id @ !! cbvab d1 d2 @ !! cbvald x y @ bieqd (dvdeqd anr anl) @
  syl5bb ancomb @ anwr @ aneqd dvdeq1 dvdeq1);

theorem eqgcd {x} (h: $ G -> (x || d <-> x || a /\ x || b) $):
  $ G -> gcd a b = d $ =
(focus
  (def h1 '(rsyl (anwl @ iald h) @ eale @ bieqd dvdeq1 @ aneqd dvdeq1 dvdeq1))
  (def h2 '(anwr @ eale @ bieqd dvdeq1 @ aneqd dvdeq1 dvdeq1))
  '(!! eqtheabd d2 @ ibida
    (dvdasymd (mpbird ,h1 @ mpbii dvdid ,h2) (mpbird ,h2 @ mpbii dvdid ,h1))
    (mpbird
      (!! cbvald y x @ bieqd (dvdeqd anr anlr) (anwr @ aneqd dvdeq1 dvdeq1))
      (anwl @ iald h))));

theorem gcd00: $ gcd 0 0 = 0 $ =
'(trud @ !! eqgcd x @ a1i @ bith dvd02 @ ian dvd02 dvd02);

@_ local def bgcd (a b: nat): nat = $ least {d | 0 < d /\ E. x E. y x * a = y * b + d} $;

theorem dfbgcd: $ bgcd a b = least {d | 0 < d /\ E. x E. y x * a = y * b + d} $ =
'(leasteq @ !! cbvab d2 d @ aneqd lteq2 @ !! cbvexd z x @ !! cbvexd w y @
    eqeqd (muleq1d anlr) @ addeqd (anwr muleq1) anll);

theorem bgcd01: $ bgcd 0 b = 0 $ =
'(least0 @ !! ngen d @ mt (sylbi
  (!! elabe d2 @ aneqd lteq2 @ exeqd @ exeqd @
    eqeqd (a1i mul02) addeq2) @
  imp @ !! eexd x @ !! eexd y @
  syl absurd @ syl ltne @ mpi leaddid2 ltletr) notfal);

theorem bgcdlem: $ a != 0 -> 0 < bgcd a b /\ E. x E. y x * a = y * b + bgcd a b $ =
'(sylib
  (!! elabe d @ aneqd lteq2 @ !! cbvexd z x @ !! cbvexd w y @
    eqeqd (muleq1d anlr) @ addeqd (anwr muleq1) anll) @
  syl leastel @ sylibr (elabe @ aneqd lteq2 @ exeqd @ exeqd @ eqeq2d addeq2) @
  iand (bi2 lt01) @ iexde @ iexde @
  eqtr4d (syl6eq mul11 @ muleq1d anlr) @
  syl6eq add01 @ addeq1d @ syl6eq mul01 @ anwr muleq1);

theorem bgcdpos: $ a != 0 -> 0 < bgcd a b $ = '(anld @ ! bgcdlem a b x y);

theorem bgcdbezout: $ E. x E. y x * a = y * b + bgcd a b $ =
'(cases
  (iexde @ iexde @ eqtr4d (muleqd anlr anll) @ syl6eqr mul01 @
    syl6eq add0 @ addeqd (syl6eq mul01 @ anwr muleq1) (syl6eq bgcd01 @ bgcdeq1d anll))
  (anrd bgcdlem));

theorem bgcdled (h: $ G -> 0 < d $) (h2: $ G -> x * a = y * b + d $):
  $ G -> bgcd a b <= d $ =
'(syl leastle @ sylibr (!! elabe d2 @ aneqd lteq2 @ exeqd @ exeqd @ eqeq2d addeq2) @
  iand h @ !! iexde z @ !! iexde w @
  mpbird (eqeqd (muleq1d anlr) (addeq1d @ anwr muleq1)) (anwll h2));

theorem bgcd02: $ bgcd a 0 = a $ =
'(cases (eqtr4d (syl6eq bgcd01 bgcdeq1) id) @ leasymd
  (bgcdled (bi2i lt01) @ a1i @ eqtr mul11 @ eqcom @ eqtr (addeq1 mul01) add01)
  (mpi (!! bgcdbezout x y) @ eexd @ eexda @
    mpbid (leeqd (a1i mul11) @ syl6eq add01 @ syl6eq (addeq1 mul0) anr) @
    syl lemul1a @ sylibr lt01 @ mtand (anwl @ syl ltner bgcdpos) @ eqtr3d
      (anwl @ syl6eq add01 @ syl6eq (addeq1 mul0) anr)
      (syl6eq mul01 @ anwr muleq1)));

theorem dvdbgcd: $ d || a /\ d || b -> d || bgcd a b $ =
'(mpi (!! bgcdbezout x y) @ eexd @ eexda @
  mpbird (syl dvdadd1 @ syl dvdmul12 anlr) @
  mpbid (anwr dvdeq2) (anwll dvdmul12));

theorem bgcddvd1lem (h1: $ G -> a != 0 $) (h2: $ G -> x * a = y * b + d $)
  (h3: $ G -> b != 0 $) (h4: $ G -> d * q + r = a $)
  (h5: $ G -> x <= u $) (h6: $ G -> y <= u $):
  $ G -> suc ((u * b - x) * q) * a = (u * a - y) * q * b + r $ =
'(sylib addcan1 @ syl5eqr addass @
  eqtr4d (addeq1d @ syl5eqr addmul @ muleq1d @
    syl5eq addS1 @ suceqd @ syl5eqr addmul @ muleq1d @
    syl npcan @ letrd h5 @ sylib (leeq1 mul12) @ syl lemul2a @ sylibr lt01 h3) @
  syl5eq (addeq2 addcom) @ syl5eqr addass @
  eqtr4d (addeq1d @ syl5eq add32 @ addeq1d @
    syl5eqr addmul @ muleq1d @ syl5eqr addmul @ muleq1d @
    syl npcan @ letrd h6 @ sylib (leeq1 mul12) @ syl lemul2a @ sylibr lt01 h1) @
  syl6eqr add32 @ syl6eqr addass @
  syl5eq (addeq1 @ eqtr mulS1 @ addeq1 @
    eqtr mulass @ eqtr mulass @
    eqtr4 (muleq2 @ eqtr mulcom @ muleq1 mulcom) @
    eqtr (muleq1 mulass) mulass) @
  syl5eq addass @ addeq2d @ syl5eq addcom @
  eqtr3d (addeq2d h4) @ syl5eqr addass @ addeq1d @
  syl5eq (addeq1 mul32) @ syl5eqr addmul @ syl6eq mul32 @
  muleq1d @ eqcomd h2);

theorem bgcddvd2lem (h1: $ G -> a != 0 $) (h2: $ G -> x * a = y * b + d $)
  (h3: $ G -> b != 0 $) (h4: $ G -> d * q + r = b $)
  (h5: $ G -> x * q <= u $) (h6: $ G -> y * q < u $):
  $ G -> (u * b - x * q) * a = (u * a - suc (y * q)) * b + r $ =
'(sylib addcan1 @ syl5eqr addass @
  eqtr4d (addeq1d @ syl5eqr addmul @ muleq1d @
    syl npcan @ letrd h5 @ sylib (leeq1 mul12) @ syl lemul2a @ sylibr lt01 h3) @
  syl5eq (addeq2 addcom) @ syl5eqr addass @
  eqtr4d (addeq1d @ syl5eq add32 @ addeq1d @ syl5eqr addmul @ muleq1d @
    syl npcan @ letrd h6 @ sylib (leeq1 mul12) @ syl lemul2a @ sylibr lt01 h1) @
  syl6eqr add32 @ syl6eqr addass @
  syl5eq (addeq1 mul32) @ addeq2d @
  syl5eq mulS1 @ eqtr3d (addeq2d h4) @
  syl5eqr addass @ addeq1d @ syl5eq (addeq1 mul32) @
  syl5eqr addmul @ syl6eq mul32 @ muleq1d @ eqcomd h2);

theorem bgcddvd1: $ bgcd a b || a $ =
'(cases (mpbiri dvd02 dvdeq2) @ mpi (! bgcdbezout a b x y) @ eexd @ eexda @
  casesda (anwr @ mpbii dvdid @ dvdeq2d @ syl6eq bgcd02 bgcdeq2) @
  sylib modeq0 @ mpd (anwll @ syl modlt @ sylib lt01 bgcdpos) @
  syl5bi ltnle @ con1d @ exp @ bgcdled (sylibr lt01 anr) @
  bgcddvd1lem an3l anllr anlr (a1i divmod) (a1i lemax1) (a1i lemax2));

theorem bgcddvd2: $ a != 0 -> bgcd a b || b $ =
'(casesda (anwr @ mpbiri dvd02 dvdeq2) @ mpi (! bgcdbezout a b x y) @ eexd @ eexda @
  sylib modeq0 @ mpd (anwll @ syl modlt @ sylib lt01 bgcdpos) @
  syl5bi ltnle @ con1d @ exp @ bgcdled (sylibr lt01 anr) @
  bgcddvd2lem an3l anlr anllr (a1i divmod) (a1i lemax1) (a1i lemax2));

theorem dvdbgcdb: $ a != 0 -> (d || bgcd a b <-> d || a /\ d || b) $ =
'(ibid
  (exp @ iand (sylc dvdtr anr (a1i bgcddvd1)) (sylc dvdtr anr (anwl bgcddvd2)))
  (a1i dvdbgcd));

theorem gcdbgcd: $ a != 0 -> gcd a b = bgcd a b $ = '(!! eqgcd d dvdbgcdb);

theorem gcd01: $ gcd 0 b = b $ = '(trud @ !! eqgcd d @ a1i @ bicom @ bian1 dvd02);

theorem dvdgcdlem {x} (h: $ G -> (x || d <-> x || a /\ x || b) $):
  $ G -> (c || gcd a b <-> c || a /\ c || b) $ =
'(bitrd (dvdeq2d @ eqgcd h) @
  syl (eale @ bieqd dvdeq1 @ aneqd dvdeq1 dvdeq1) (iald h));

theorem dvdgcd: $ d || gcd a b <-> d || a /\ d || b $ =
'(cases (!! dvdgcdlem x @ bicomd @ syl bian1 @ mpbiri dvd02 dvdeq2) (!! dvdgcdlem x dvdbgcdb));
theorem gcddvd1: $ gcd a b || a $ = '(anl @ mpbi dvdgcd dvdid);
theorem gcddvd2: $ gcd a b || b $ = '(anr @ mpbi dvdgcd dvdid);

theorem gcd02: $ gcd a 0 = a $ = '(eqtr gcdcom gcd01);

theorem bezout: $ a != 0 -> E. x E. y x * a = y * b + gcd a b $ =
'(mpbiri bgcdbezout @ exeqd @ exeqd @ eqeq2d @ addeq2d gcdbgcd);

@_ local def coprime (a b: nat): wff = $ gcd a b = 1 $;

theorem copcom: $ coprime a b <-> coprime b a $ = '(eqeq1 gcdcom);

theorem dvdcop (h1: $ G -> coprime a b $)
  (h2: $ G -> d || a $) (h3: $ G -> d || b $): $ G -> d = 1 $ =
'(sylib dvd12 @ mpbid (dvdeq2d h1) @ sylibr dvdgcd @ iand h2 h3);

theorem dfcop2: $ coprime a b <-> A. x (x || a -> x || b -> x = 1) $ =
'(ibii
  (iald @ exp @ exp @ dvdcop anll anlr anr)
  (!! eqgcd y @ ibid
    (a1i @ iand (mpi dvd11 dvdtr) (mpi dvd11 dvdtr))
    (exp @ sylibr dvd12 @ mpd anrr @ mpd anrl @ anwl @
      eale @ imeqd dvdeq1 @ imeqd dvdeq1 eqeq1)));

theorem copbezout (h1: $ G -> coprime a b $) (h2: $ G -> a != 0 $):
  $ G -> E. x E. y x * a = y * b + 1 $ =
'(mpbid (exeqd @ exeqd @ eqeq2d @ addeq2d h1) (syl bezout h2));

theorem copdvdmul2 (h1: $ G -> coprime a b $) (h2: $ G -> a || b * c $): $ G -> a || c $ =
'(casesda
  (mpbid (dvdeq2d @ syl6eq mul11 @
    muleq1d @ eqtr3d (anwr @ syl6eq gcd01 gcdeq1) (anwl h1)) (anwl h2))
  (mpd (copbezout (anwl h1) anr) @ !! eexd x @ !! eexda y @
    mpbird (syl dvdadd1 @ syl dvdmul11 @ anwll h2) @ mpbii dvdmul1 @
    dvdeq2d @ syl5eq mul32 @ syl6eq (addeq mul32 mul11) @
    syl6eq addmul @ muleq1d @ syl6eq (addeq1 mulcom) anr));

theorem copdvdmul1 (h1: $ G -> coprime a c $) (h2: $ G -> a || b * c $): $ G -> a || b $ =
'(copdvdmul2 h1 @ sylib (dvdeq2 mulcom) h2);

@_ local def invm (a n: nat): nat = $ least {b | mod(n): a * b = 1} $;

theorem mulinvmlem (h: $ G -> mod(n): a * b = 1 $): $ G -> mod(n): a * invm a n = 1 $ =
'(sylib (!! elabe x @ eqmeq2d muleq2) @ syl leastel @ sylibr (elabe @ eqmeq2d muleq2) h);

theorem mulinvm (h: $ G -> coprime a n $):
  $ G -> mod(n): a * invm a n = 1 $ =
'(casesda (mpbiri eqm11 @ eqmeq1d @ eqtr3d (syl6eq gcd01 @ anwr gcdeq1) (anwl h)) @
  casesda (mulinvmlem @ syl eqeqm @ syl5eq mul12 @ eqtr3d (syl6eq gcd02 @ anwr gcdeq2) (anwll h)) @
  mpd (copbezout (anwll h) anlr) @ !! eexd x @ !! eexda y @ mulinvmlem @
  mpbid (eqmeq23d (eqtr3d anr @ a1i mulcom) (a1i add01)) @
  eqmadd1d @ a1i @ mpbir eqm03 dvdmul1);

@_ local def pset (a: nat): set = $ {n | 0 < fst a /\ 0 < snd a /\
  A. x (0 < x /\ x <= n -> x || fst a) /\ suc (fst a * suc n) || snd a} $;

theorem elpset: $ n e. pset (m <> v) <-> 0 < m /\ 0 < v /\
  A. x (0 < x /\ x <= n -> x || m) /\ suc (m * suc n) || v $ =
'(!! elabe y @ aneqd (aneqd (aneqd (lteq2d @ a1i @ fstpr) (lteq2d @ a1i @ sndpr)) @
    !! cbvald x1 _ @ imeqd (aneqd (anwr lteq2) (leeqd anr anl)) (dvdeqd anr (a1i fstpr))) @
  dvdeqd (suceqd @ muleqd (a1i fstpr) suceq) @ a1i sndpr);

theorem elpset1: $ ~n e. pset (m <> 1) $ =
'(inot @ sylbi (!! elpset x) @
  sylc absurd (sylib lenlt @ syl (sylibr mulpos @ iand id @ a1i lt01S) an3l) @
  dvdle (a1i d1ne0) anr);

theorem psetSlem1 (h1: $ G -> A. x (0 < x /\ x < n -> x || m) $)
  (h2: $ G -> i < j $) (h3: $ G -> j < n $):
  $ G -> coprime (suc (m * suc i)) (suc (m * suc j)) $ =
(focus
  '(sylibr dfcop2 @ !! iald u @ exp @ exp @
    sylib dvd12 @ mpbird _ (sylibr (dvdeq2 add12) anlr))
  '(syl dvdadd1 @ syl dvdmul11 @
    sylc dvdtr (mpbird
      (syl dvdadd1 @ anwr dvdmul11)
      (mpbird (dvdeq2d _) (syl dvdmul11 anlr))) @
    sylc (eale @ imeqd (aneqd lteq2 lteq1) dvdeq1) (anwll h1) @
    iand (sylib subpos @ anwll h2) @ lelttrd (a1i subleid) (anwll h3))
  '(syl5eq (addeq1 mulS1) @ syl5eq addass @
    syl6eqr mulS1 @ syl6eq (addeq1 mul32) @ addeq2d @
    syl5eq addS1 @ suceqd @ syl pncan3 @ syl ltle @ anwll h2));

theorem psetSlem2 (h1: $ G -> A. x (0 < x /\ x < n -> x || m) $) (h2: $ G -> a != b $)
  (h3: $ G -> a < n $) (h4: $ G -> b < n $):
  $ G -> coprime (suc (m * suc a)) (suc (m * suc b)) $ =
'(mpd (sylib neltlt h2) @ eorda
  (psetSlem1 (anwl h1) anr (anwl h4))
  (sylib copcom @ psetSlem1 (anwl h1) anr (anwl h3)));

theorem psetS (h1: $ G -> 0 < m $) (h2: $ G -> 0 < v $)
  (h3: $ G -> A. x (0 < x /\ x <= n -> x || m) $): $ G ->
  (a e. pset (m <> v * suc (m * suc n)) <-> a e. pset (m <> v) \/ a = n) $ =
(focus
  '(syl5bb elpset @ syl6bbr (oreq1i elpset) @ ibid
    (exp @ syla orcom @ iand (iand (iand
      (anwll h1)
      (anld @ sylib mulpos @ syl anllr anlr))
      (syl anlr anlr))
      (copdvdmul1 (psetSlem2
        (sylib (!! cbval _ y (imeqd (aneqd lteq2 lteq1) dvdeq1)) @
          sylc _ (syl anlr anlr) (anwll h3))
        anr (a1i lemax1) (a1i lemax2)) (anwl anrr)))
    (eord (animd (a1i @ anim1 @ anim2 @ sylibr mulpos @ iand id @ a1i lt01S)
      (a1i dvdmul11)) @
      syl5ibrcom (aneqd (aneq2d @ aleqd @ imeq1d @ aneq2d leeq2) @
        dvdeq1d @ suceqd @ muleq2d suceq) @
      iand (iand (iand h1 (sylibr mulpos @ iand h2 @ a1i lt01S)) h3) @ a1i dvdmul1))
  '(al2imi @ syl6 (imim1i @ sylib andi @ anim2 @
    sylbi ltmax @ bi2 @ oreqi leltsuc leltsuc) eor));

theorem lcmex: $ E. m (0 < m /\ A. x (0 < x /\ x <= n -> x || m)) $ =
(mk-ind '(! ind u v _ $ E. m (0 < m /\ A. x (0 < x /\ x <= u -> x || m)) $ _ _ _ _)
  '(exeqd @ aneq2d @ aleqd @ imeq1d @ aneq2d leeq2)
  '(iexe (aneqd leeq2 @ aleqd @ imeq2d dvdeq2) @
    ian d0lt1 @ ax_gen @ imp @ sylbi ltnle absurd)
  '(sylbi (!! cbvex _ a @ aneqd leeq2 @ aleqd @ imeq2d dvdeq2) @ eex @ sylan
    (iexe @ aneqd leeq2 @ aleqd @ imeq2d dvdeq2)
    (sylibr mulpos @ iand anl @ a1i lt01S)
    (anwr @ alimi @ sylbi impexp @ sylibr impexp @ imim2 @ syl5bi leloe @ eord
      (syl5bir leltsuc @ imim2i dvdmul11)
      (a1i @ mpbii dvdmul1 @ dvdeq2d muleq2))));

theorem psetsep (p: wff x): $ E. b pset b == {x | x < n /\ p} $ =
(focus
  (have 'h1 $ y < suc v /\ ([y / x] p) <-> y < v /\ ([y / x] p) \/ y = v /\ ([v / x] p) $
    '(bitr (aneq1i @ bitr3 leltsuc leloe) @ bitr andir @ oreq2i @ aneq2a sbeq1))
  (have 'h2 $ 0 < m /\ A. x (0 < x /\ x <= n -> x || m) ->
              E. a (0 < a /\ pset (m <> a) == {x | x < n /\ p}) $
    (mk-ind '(! indlt _ u v _
        $ E. a (0 < a /\ pset (m <> a) == {x | x < u /\ p}) $ _ _ _ _)
      '(exeqd @ aneq2d @ eqseq2d @ abeqd @ aneq1d lteq2)
      '(a1i @ iexe (aneqd lteq2 @ eqseq1d @ pseteqd preq2) @
        ian d0lt1 @ eqab2i @ binth elpset1 @ mt anl lt02)
      '(imp @ casesda
        (syl6ibr (!! cbvex _ b @ aneqd lteq2 @ eqseq1d @ pseteqd preq2) @
          eexda @ syl (iexe @ aneqd lteq2 @ eqseq1d @ pseteqd preq2) @
          iand (sylibr mulpos @ iand anrl @ a1i lt01S) @ !! eqrd y @
          syl6bbr (bitr elab @ sbeh (nfan nfv nfsb1) @ aneqd lteq1 sbq) @
          bitrd (psetS (anld an3l) anrl @
            sylib (!! cbval _ z @ imeqd (aneqd lteq2 leeq1) dvdeq1) @ mpd (anrd an3l) @
            rsyl (syl (letr lesucid) anllr) @ alimd @ imim1d @ anim2d @ com12 letr) @
          bitr4d (oreq1d @ syl6bb
            (bitr elab @ sbeh (nfan nfv nfsb1) @ aneqd lteq1 sbq) @ eleq2d anrr) @
          syl5bb h1 @ oreq2d @ syl bian2 anlr)
        (bi2d @ exeqd @ aneq2d @ eqseq2d @ !! eqrd y @
          syl5bb (bitr elab @ sbeh (nfan nfv nfsb1) @ aneqd lteq1 sbq) @
          syl6bbr (bitr elab @ sbeh (nfan nfv nfsb1) @ aneqd lteq1 sbq) @
          syl5bb h1 @ syl bior2 @ anwr @ con3 anr))))
  '(eex (mpd h2 @ eexda @ !! iexde b @ eqstrd (anwr pseteq) (anwl anrr)) lcmex));

theorem expset: $ finite A <-> E. a pset a == A $ =
(focus
  (have 'h '(sylib (!! elpset y) @ mpbird (eleq2d @ eqstrd (a1i @ pseteq fstsnd) anll) anr))
  '(! ibii $ E. n A. x _ $ _
    (eex @ mpbii psetsep @ exeqd @ eqseq2d @ !! eqab1d y @ syl bian1a @
      eale @ imeqd eleq1 lteq1)
    (eex @ iexde @ iald @ exp @
      letrd (syl (mpi lesucid letr) @
        sylib (leeq1 mul11) @ syl lemul1a @ syl an3l h) @
      letrd (dvdle (syl ltner @ syl anllr h) (anrd h)) @
      syl eqler anlr)));

theorem psetfn (p: wff x) (v: nat x):
  $ finite {x | p} -> E. a A. x (p -> pset a @ x = v) $ =
'(rsyl (sylib expset finlam) @ eximi @
  ialdh (nfeqs nfsv @ nfres (!! nflam x y @ nfsbn1) nfab1) @ exp @
  eqtrd (anwl appeq1) @ syl6eq (eqtr3 (appeq1 cbvlams) applam) @
  anwr @ sylbir abid resapp);

-- simple recursion operator:
--   rec(0) = z
--   rec(n+1) = S(rec(n))
@_ abstract def rec (z: nat) (S: set) (n: nat): nat =
$ the {v | E. a (pset a @ 0 = z /\ pset a @ n = v /\
    A. i (i < n -> pset a @ suc i = S @ (pset a @ i)))} $;

theorem reclem {i}
  (h1: $ G -> pset a @ 0 = z $) (h2: $ G -> pset a @ n = v $)
  (h3: $ G -> A. i (i < n -> pset a @ suc i = S @ (pset a @ i)) $):
  $ G -> rec z S n = v $ =
(focus
  '(!! eqtheabd u @ ibid
    (eexda @ eqtr3d (anwr anlr) @ eqtrd _ (anwl h2))
    (exp @ !! iexde b @ iand (iand
        (eqtrd (appeq1d @ anwr pseteq) (anwll h1))
        (eqtrd (appeq1d @ anwr pseteq) @ eqtr4d (anwll h2) anlr)) @
      mpbird (aleqd @ imeq2d @ eqeqd (appeq1d @ anwr pseteq) @
        appeq2d @ appeq1d @ anwr pseteq) (anwll h3)))
  (mk-ind '(! indlt _ x y _ $ pset b @ x = pset a @ x $ _ _ _ _)
    '(eqeqd appeq2 appeq2)
    '(eqtr4d (anwr anll) (anwl h1))
    '(eqtrd (mpd anlr @ rsyl anllr @ anwr @ eale @ imeqd lteq1 @
        eqeqd (appeq2d suceq) (appeq2d appeq2)) @
      eqtr4d (anwr appeq2) @
      mpd anlr @ anw3l @ rsyl h3 @ eale @ imeqd lteq1 @
        eqeqd (appeq2d suceq) (appeq2d appeq2))));

pub theorem rec0 (z: nat) (S: set): $ rec z S 0 = z $ =
(focus
  (have 'h $ A. x (x = 0 -> pset a @ x = z) -> pset a @ 0 = z $
    '(mpi eqid (eale @ imeqd eqeq1 @ eqeq1d appeq2)))
  '(eex (reclem h h @ a1i @ !! ax_gen i @ absurd lt02) (psetfn snfin)));

pub theorem recS (z: nat) (S: set) (n: nat):
  $ rec z S (suc n) = S @ rec z S n $ =
(focus
  '(trud @ ! indstr _ m k _ $ rec z S (suc m) = S @ rec z S m $ _ _
    (eqeqd (receq3d suceq) (appeq2d receq3))
    (eqeqd (receq3d suceq) (appeq2d receq3)) @ anwr @
    mpi (psetfn lefin) @ ! eexda _ _ $ A. x (x <= suc k ->
      pset a @ x = if (x = suc k) (S @ rec z S k) (rec z S x)) $ _ @
    reclem
      (anwr @ syl6eq rec0 @ mpi le01 @ eale @ imeqd leeq1 @ eqeqd appeq2 @
        eqtrd (syl ifneg @ con2 sucne0) receq3)
      (anwr @ mpi leid @ eale @ imeqd leeq1 @ eqeqd appeq2 ifpos)
      (!! iald y @ syl5bir leltsuc @ exp @
        eqtrd (mpd (sylib lesuc anr) @ rsyl anlr @ eale @ imeqd leeq1 @
          eqeqd appeq2 @ ifeqd (syl6bb peano2 eqeq1) eqidd receq3) _))
  (have 'h
    $ A. m (m < k -> rec z S (suc m) = S @ rec z S m) /\
      A. x (x <= suc k -> pset a @ x = if (x = suc k) (S @ rec z S k) (rec z S x)) /\
      y <= k -> rec z S y = pset a @ y $
    '(mpd anlr @ anwr @ ealde @ syl6 eqcom @ bi1d @
      bitrd (syl biim1 @ mpbird (anwr leeq1) @ letrd anl @ a1i lesucid) @
      eqeqd (anwr appeq2) @
      eqtrd (syl ifneg @ syl ltne @ sylib leltsuc @ imp @ syl5ibrcom leeq1 id) @
      anwr receq3))
  '(casesda
    (eqtr4d (anwr ifpos) @ appeq2d @ eqtr3d (anwl h) (anwr receq3))
    (eqtrd (anwr ifneg) @
      eqtrd (mpd (imp @ syl orcom @ sylib leloe anr) @
        rsyl an3l @ eale @ imeqd lteq1 @
        eqeqd (receq3d suceq) (appeq2d receq3)) @
      appeq2d @ anwl h)));

@_ local def recnaux (z: nat) (S: set) (n: nat): nat =
$ rec (0 <> z) (\ p, suc (fst p) <> S @ p) n $;

theorem recnaux0: $ recnaux z S 0 = 0 <> z $ = (named 'rec0);

theorem recnauxS2: $ recnaux z S (suc n) =
  suc (fst (recnaux z S n)) <> S @ (recnaux z S n) $ =
'(eqtr recS @ ! applame $ recnaux z S n $ _ p _ @
  preqd (suceqd fsteq) appeq2);

theorem recnauxfst: $ fst (recnaux z S n) = n $ =
(mk-ind '(!! ind x y) '(eqeqd (fsteqd recnauxeq3) id)
  '(eqtr (fsteq recnaux0) fstpr)
  '(syl5eq (eqtr (fsteq recnauxS2) fstpr) suceq));

-- recursion operator with iteration variable:
--   recn(0) = z
--   recn(n+1) = S(n, recn(n))
@_ local def recn (z: nat) (S: set) (n: nat): nat = $ snd (recnaux z S n) $;

theorem recn0: $ recn z S 0 = z $ = (named '(eqtr (sndeq rec0) sndpr));
theorem recnS: $ recn z S (suc n) = S @ (n <> recn z S n) $ =
'(eqtr (sndeq recnauxS2) @ eqtr sndpr @ appeq2 @
  eqtr3 fstsnd @ preq1 recnauxfst);

@_ abstract def obind (a: nat) (F: set): nat = $ recn 0 (\ n, F @ fst n) a $;
pub theorem obind0 (F: set): $ obind 0 F = 0 $ = (named 'recn0);
pub theorem obindS (n: nat) (F: set): $ obind (suc n) F = F @ n $ =
'(! eqtr _ $ _ @ (_ <> obind _ _) $ _ recnS @
  !! applame x @ appeq2d @ syl6eq fstpr fsteq);

theorem obindS2: $ obind n (\ x, suc x) = n $ =
(named '(cases (mpbiri obind0 @ eqeqd obindeq1 id) @ sylbi exsuc @ eex @
  mpbiri (eqtr obindS @ applame suceq) (eqeqd obindeq1 id)));

@_ abstract def pow (a b: nat): nat = $ rec 1 (\ n, a * n) b $;
infixr pow: $^$ prec 81;

pub theorem pow0: $ a ^ 0 = 1 $ = '(! rec0 _ (lam n _));
pub theorem powS: $ a ^ suc b = a * a ^ b $ =
'(eqtr recS @ ! applame $ a ^ b $ _ n _ muleq2);
theorem powS2: $ a ^ suc b = a ^ b * a $ = '(eqtr powS mulcom);
theorem pow12: $ a ^ 1 = a $ = '(eqtr powS @ eqtr (muleq2 pow0) mul12);

theorem pow11: $ 1 ^ b = 1 $ =
(mk-ind '(!! ind x y) '(eqeq1d poweq2)
  'pow0 '(syl5eq powS @ syl5eq mul11 id));

theorem powpos: $ 0 < a -> 0 < a ^ b $ =
'(!! indd x y
  (lteq2d @ syl6eq pow0 poweq2) (lteq2d poweq2)
  (lteq2d @ syl6eq powS poweq2) (lteq2d poweq2)
  (a1i d0lt1) (bi2i mulpos));
theorem powne0: $ a != 0 -> a ^ b != 0 $ = '(sylbir lt01 @ sylib lt01 powpos);
theorem pow2ne0: $ 2 ^ b != 0 $ = '(powne0 d2ne0);

theorem powltid2: $ 1 < a -> b < a ^ b $ =
'(!! indd x y
  (lteqd id @ syl6eq pow0 poweq2) (lteqd id poweq2)
  (lteqd id @ syl6eq powS poweq2) (lteqd id poweq2)
  (a1i d0lt1)
  (lelttrd anr @ sylib (lteq1 mul11) @
    mpbid (syl ltmul1 @ syl powpos @ anwl @ lttr d0lt1) anl));

theorem powadd: $ a ^ (b + c) = a ^ b * a ^ c $ =
'(!! ind x y
  (eqeqd (poweq2d @ syl6eq add0 addeq2) (muleq2d @ syl6eq pow0 poweq2))
  (eqeqd (poweq2d addeq2) (muleq2d poweq2))
  (eqeqd (syl6eq powS2 @ poweq2d @ syl6eq addS addeq2) (muleq2d @ syl6eq powS2 poweq2))
  (eqeqd (poweq2d addeq2) (muleq2d poweq2))
  (eqcom mul12) (syl6eq mulass muleq1));

theorem powmul: $ a ^ (b * c) = (a ^ b) ^ c $ =
'(!! ind x y
  (eqeqd (poweq2d @ syl6eq mul0 muleq2) poweq2)
  (eqeqd (poweq2d muleq2) poweq2)
  (eqeqd (syl6eq powadd @ poweq2d @ syl6eq mulS muleq2) (syl6eq powS2 poweq2))
  (eqeqd (poweq2d muleq2) poweq2)
  (eqtr4 pow0 pow0) muleq1);

theorem powdvd: $ b <= c -> a ^ b || a ^ c $ =
'(mpbii dvdmul1 @ dvdeq2d @ syl5eqr powadd @ poweq2d npcan);
theorem lepow2a: $ a != 0 -> b <= c -> a ^ b <= a ^ c $ =
'(exp @ dvdle (anwl powne0) (anwr powdvd));

@_ def shl (a n: nat): nat = $ a * 2 ^ n $;
@_ def shr (a n: nat): nat = $ a // 2 ^ n $;

theorem shl01: $ shl 0 b = 0 $ = 'mul01;
theorem shl02: $ shl a 0 = a $ = '(eqtr (muleq2 pow0) mul12);
theorem shl11: $ shl 1 b = 2 ^ b $ = 'mul11;
theorem shl12: $ shl a 1 = b0 a $ = '(eqtr (muleq2 pow12) b0mul22);
theorem shlshl: $ shl (shl a b) c = shl a (b + c) $ = '(eqtr4 mulass (muleq2 powadd));
theorem shlpow2dvd: $ 2 ^ b || shl a b $ = 'dvdmul1;
theorem shl2dvd: $ 0 < b -> 2 || shl a b $ =
'(sylib (dvdeq1 pow12) @ rsyl powdvd @ mpi shlpow2dvd dvdtr);

theorem shr01: $ shr 0 b = 0 $ = 'div01;
theorem shr02: $ shr a 0 = a $ = '(eqtr (diveq2 pow0) div12);
theorem shr12: $ shr a 1 = a // 2 $ = '(diveq2 pow12);
theorem shrshr: $ shr (shr a b) c = shr a (b + c) $ = '(eqtr4 divdiv (diveq2 powadd));
theorem shrmodadd1: $ shr (a % 2 ^ (b + c)) b = shr a b % 2 ^ c $ =
'(eqtr4 (shreq1 @ modeq2 powadd) divmod1);
theorem shrmodadd2: $ shr (a % 2 ^ (b + c)) c = shr a c % 2 ^ b $ =
'(eqtr (shreq1 @ modeq2 @ poweq2 addcom) shrmodadd1);
theorem shrshlid: $ shr (shl a b) b = a $ = '(muldiv1 pow2ne0);
theorem shrshl1: $ c <= b -> shr (shl a b) c = shl a (b - c) $ =
'(syl6eq shrshlid @ shreq1d @ syl6eqr shlshl @ shleq2d @ eqcomd npcan);
theorem shrshl2: $ b <= c -> shr (shl a b) c = shr a (c - b) $ =
'(syl6eq (shreq1 shrshlid) @ syl6eqr shrshr @ shreq2d @ eqcomd pncan3);

theorem shreq0: $ shr a b = 0 <-> a < 2 ^ b $ = '(diveq0 pow2ne0);

@_ def nel (a b: nat): wff = $ odd (shr b a) $;

@_ def ns (a .x: nat): set = $ {x | nel x a} $; coercion ns: nat > set;

theorem elnel: $ a e. ns b <-> nel a b $ = '(!! elabe x neleq1);
theorem elneqd (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> (a e. ns c <-> b e. ns d) $ = '(eleqd h1 @ nseqd h2);
theorem elneq2d (h: $ G -> b = c $): $ G -> (a e. ns b <-> a e. ns c) $ = '(elneqd eqidd h);
theorem elneq2: $ b = c -> (a e. ns b <-> a e. ns c) $ = '(elneq2d id);

theorem el01: $ 0 e. ns a <-> odd a $ = '(bitr elnel @ oddeq shr02);

theorem elshr: $ a e. shr b c <-> a + c e. ns b $ =
'(bitr elnel @ bitr4 (oddeq @ eqtr shrshr @ shreq2 addcom) elnel);

theorem elshl: $ a e. shl b c <-> c <= a /\ a - c e. ns b $ =
'(bitr elnel @
  rbid (sylbi odddvd @ con1 @ sylbir ltnle @
    mpbird (dvdeq2d @ rsyl ltle shrshl1) (sylbi subpos shl2dvd)) anl @
  bitr4d (syl6bbr elnel @ oddeqd shrshl2) bian1);

theorem shrss: $ a C_ b -> shr a n C_ shr b n $ =
'(!! iald x @ syl5bi elshr @ syl6ibr elshr ssel);
theorem shlss: $ a C_ b <-> shl a n C_ shl b n $ =
'(ibii (!! iald x @ syl5bi elshl @ syl6ibr elshl @ anim2d ssel) @
  sylib (sseq (nseq shrshlid) (nseq shrshlid)) shrss);

theorem eldiv2: $ a e. b // 2 <-> suc a e. ns b $ =
'(bitr3 (elneq2 shr12) @ bitr elshr @ eleq1 add12);
theorem elb0: $ a e. b0 b <-> 0 < a /\ a - 1 e. ns b $ = '(bitr3 (elneq2 shl12) elshl);
theorem elb1: $ a e. b1 b <-> a = 0 \/ a - 1 e. ns b $ =
'(cases (bithd (mpbiri (mpbir el01 b1odd) eleq1) orl) @
  bicomd @ bitrd bior1 @ syl5bb (bitr3 (elneq2 b1div2) eldiv2) @ eleq1d sub1can);

theorem bndextle:
  $ A. x (x < n -> x e. ns a -> x e. ns b) -> a % 2 ^ n <= b % 2 ^ n $ =
(mk-ind '(!! ind i j)
  '(imeqd (aleqd @ imeq1d lteq2) (leeqd (modeq2d poweq2) (modeq2d poweq2)))
  '(a1i @ mpbir (leeq1 @ eqtr (modeq2 pow0) mod12) le01)
  '(rsyl (imim1i @ alimi @ imim1i @ mpi ltsucid lttr) @
    a2i @ rsyl (mpi ltsucid @ eale @ imeqd lteq1 (imeqd eleq1 eleq1)) @ exp @
    sylib (leeq divmod divmod) @
    sylibr (leeq
      (addeq (muleq2 @ eqtr4 (diveq1 @ modeq2 powS2) divmod1) (modmod @ powdvd lesucid))
      (addeq (muleq2 @ eqtr4 (diveq1 @ modeq2 powS2) divmod1) (modmod @ powdvd lesucid))) @
    leaddd (syl lemul2a @ sylibr (letrueb boolmod2) @
      syl5bir dfodd2 @ syl6ib dfodd2 @
      syl5bir elnel @ syl6ib elnel anl) anr));

theorem bndext: $ A. x (x < n -> (x e. ns a <-> x e. ns b)) -> mod(2 ^ n): a = b $ =
'(leasymd (syl bndextle @ alimi @ imim2i bi1) (syl bndextle @ alimi @ imim2i bi2));

theorem ssle: $ ns a C_ ns b -> a <= b $ =
'(sylib (leeq
    (modlteq @ lelttr lemax1 @ powltid2 d1lt2)
    (modlteq @ lelttr lemax2 @ powltid2 d1lt2)) @
  syl bndextle @ !! alimi x ax_1);

pub theorem axext: $ ns a == ns b -> a = b $ =
'(leasymd (syl ssle eqss) (syl ssle eqssr));
theorem nsinj: $ ns a == ns b <-> a = b $ = '(ibii axext nseq);

pub theorem ellt: $ a e. ns b -> a < b $ =
'(sylbi elnel @ sylbi dfodd2 @ con1 @ sylbir lenlt @
  syl6eq mod01 @ modeq1d @ sylibr (diveq0 pow2ne0) @
  mpi (powltid2 d1lt2) lelttr);

theorem el02: $ ~a e. 0 $ = '(mt ellt lt02);
pub theorem nel0: $ ~a e. 0 $ = 'el02;

theorem ss01: $ 0 C_ A $ = '(!! ax_gen x @ absurd el02);
theorem ss02: $ A C_ 0 <-> A == 0 $ = '(ibii (mpi ss01 ssasym) (mpbiri ss01 sseq1));
theorem in01: $ 0 i^i A == 0 $ = '(mpbi eqin1 ss01);
theorem in02: $ A i^i 0 == 0 $ = '(mpbi eqin2 ss01);
theorem inidm: $ A i^i A == A $ = '(mpbi eqin2 ssid);
theorem un01: $ 0 u. A == A $ = '(mpbi equn1 ss01);
theorem un02: $ A u. 0 == A $ = '(mpbi equn2 ss01);
theorem unidm: $ A u. A == A $ = '(mpbi equn2 ssid);
theorem cplv: $ Compl _V == 0 $ = '(!! eqri x @ binth (con2 (bi1 elcpl) elv) el02);
theorem cpl0: $ Compl 0 == _V $ = '(eqstr3 (cpleq cplv) cplcpl);
theorem incpl: $ A i^i Compl A == 0 $ = '(mpbir cplinj @ eqstr cplin @ eqstr4 uncpl cpl0);
theorem incpleq0: $ A i^i Compl B == 0 <-> A C_ B $ =
'(!! aleqi x @ bitr (bibin2 el02) @ bitr4 (noteq @ bitr elin @ aneq2i elcpl) iman);
theorem ineq0: $ A i^i B == 0 <-> A C_ Compl B $ = '(bitr3 (eqseq1 @ ineq2 cplcpl) incpleq0);
theorem ineq0r: $ A i^i B == 0 <-> B C_ Compl A $ = '(bitr (eqseq1 incom) ineq0);
theorem sscpl2: $ A C_ Compl B <-> B C_ Compl A $ = '(bitr3 ineq0 ineq0r);
theorem xp01: $ Xp 0 A == 0 $ = '(!! eqri x @ binth (mt xpfst el02) el02);
theorem xp02: $ Xp A 0 == 0 $ = '(!! eqri x @ binth (mt xpsnd el02) el02);
theorem dm0: $ Dom 0 == 0 $ = '(!! eqri x @ binth (mtbir eldm @ !! ngen y el02) el02);
theorem rn0: $ Ran 0 == 0 $ = '(!! eqri y @ binth (mtbir elrn @ !! ngen x el02) el02);
theorem sseq0: $ A C_ B -> B == 0 -> A == 0 $ = '(syl6ib ss02 @ com12 @ bi1d sseq2);
theorem isf0: $ isfun 0 $ = '(!! ax_gen x @ !! ax_gen y @ !! ax_gen z @ absurd el02);
theorem app01: $ 0 @ a = 0 $ = '(ndmapp @ mtbir (eleq2 dm0) el02);

theorem el12: $ a e. 1 <-> a = 0 $ =
'(ibii (sylib lt12 ellt) (mpbiri (mpbir el01 odd1) eleq1));

theorem elpow2: $ a e. 2 ^ n <-> a = n $ =
'(bitr3 (elneq2 shl11) @ bitr elshl @
  bitr4 (aneq2i @ bitr4 el12 lesubeq0) @ bitr eqcomb eqlele);

theorem finns (a: nat): $ finite a $ =
'(finss (mpbi ssab2 @ !! ax_gen x ellt) ltfin);

@_ def lower (A: set): nat = $ the {n | ns n == A} $;
pub theorem eqlower: $ finite A <-> A == lower A $ =
(focus
  (have 'h1 (mk-ind
    '(! ind y z _ $ E. n A. x (x e. ns n <-> x + y e. A) -> E. n A == ns n $ _ _ _ _)
    '(imeq1d @ exeqd @ aleqd @ bieq2d @ eleq1d addeq2)
    '(eximi @ alimi @ bicomd @ syl6bb (eleq1 add0) id)
    '(imim1i @ sylib (!! cbvex m _ @ !! cbvald y _ @
        bieqd (elneqd anr anl) (eleq1d @ anwr addeq1)) @
      eex @ iexde @ iald @ impcom @ casesda
        (a1d @ mpbiri (bitr el01 @ ibii
            (ax_3 @ mtbird (oddeqd ifneg) (a1i b0odd))
            (mpbiri b1odd @ oddeqd ifpos)) @
          bieqd (elneqd anr anl) (eleq1d @ syl6eq add01 @ anwr addeq1))
        (ealde @ bi1d @ bieqd
          (mpbiri
            (bitr3 (elneq2 @ cases
              (syl6eq b1div2 @ diveq1d ifpos)
              (syl6eq b0div2 @ diveq1d ifneg)) eldiv2)
            (bieqd (eleq1d anr) @ elneqd (eqcomd @ syl sub1can anlr) anll))
          (eleq1d @ syl5eqr addSass @ addeq1d @
            eqtrd (suceqd anr) (syl sub1can anlr))))))
  (have 'h2 $ finite A -> E. n A == ns n $
    '(!! eex z @ syl h1 @ iexde @ iald @
      bitrd (elneq2d anr) @ binthd (a1i el02) @
      mtd (a1i @ mpbi lenlt leaddid2) (anwl @ !! eale y @ imeqd eleq1 lteq1)))
  '(ibii (rsyl h2 @ eex @ eqstrd id @ nseqd @ eqcomd @
      !! eqtheabd x @ syl6bb nsinj eqseq2) (mpbiri finns fineq)));

theorem ellower: $ finite A -> (a e. lower A <-> a e. A) $ = '(bicomd @ eleq2d @ bi1 eqlower);

theorem lowerns (a: nat): $ lower a = a $ = '(eqcom @ axext @ mpbi eqlower finns);

theorem eqlower1 (a: nat): $ finite A -> (A == a <-> lower A = a) $ =
'(ibida (anwr @ syl6eq lowerns lowereq) @ eqstrd (sylib eqlower anl) @ nseqd anr);
theorem eqlower2 (a: nat): $ finite A -> (a == A <-> a = lower A) $ =
'(bitr4g eqscomb eqcomb eqlower1);

@_ abstract def sn (a: nat): nat = $ 2 ^ a $;
pub theorem elsn (a b: nat): $ a e. sn b <-> a = b $ = 'elpow2;

theorem snss: $ sn a C_ A <-> a e. A $ =
'(bitr (!! aleqi x @ imeq1i elsn) @ aleqe eleq1);
@_ abstract def ins (a b: nat): nat = $ lower {x | x = a \/ x e. b} $;
infixr ins: $;$ prec 85;
pub theorem elins (a b c: nat): $ a e. b ; c <-> a = b \/ a e. c $ =
'(bitr (ellower @ finss (mpbi ssab @
    ax_gen @ eor (mpbiri lemax1 leeq1) @
    rsyl ellt @ letrd ltle @ a1i lemax2) lefin) @
  !! elabe x @ oreqd eqeq1 eleq1);

theorem inscom: $ a ; b ; c = b ; a ; c $ =
'(axext @ !! ax_gen x @ bitr4gi elins elins @
  bitr4gi (oreq2 elins) (oreq2 elins) or12);

theorem b0ins: $ b0 (a ; b) = suc a ; b0 b $ =
'(axext @ !! ax_gen x @ bitr4gi elb0 (bitr elins @ oreq2 elb0) @
  rbid anl (eor (mpbiri lt01S lteq2) anl) @
  bitrd bian1 @ syl5bb elins @ oreqd
    (syl5bbr peano2 @ eqeq1d (sylbi lt01 sub1can)) (bicomd bian1));

theorem b1ins: $ b1 n = 0 ; b0 n $ =
'(axext @ !! ax_gen x @ bitr4gi elb1 (bitr elins @ oreq2 elb0) @
  cases (bithd orl orl) @ oreq2d @ bicomd @ sylbir lt01 bian1);

theorem insdiv2: $ (suc a ; b) // 2 = a ; (b // 2) $ =
'(eor (syl6eq b0div2 @ diveq1d @ syl6eqr b0ins inseq2)
  (syl6eq b1div2 @ diveq1d @ syl6eqr b1ins @
    syl6eqr (inseq2 b0ins) @ syl6eq inscom @ inseq2d @ syl6eq b1ins id)
  b0orb1);

theorem insunsn: $ a ; b == sn a u. ns b $ =
'(!! eqri x @ bitr4gi elins elun @ oreq1 @ bicom @ elsn);

theorem insss: $ a ; b C_ A <-> a e. A /\ ns b C_ A $ =
'(bitr (sseq1 insunsn) @ bitr unss @ aneq1i snss);

@_ def upto (n: nat): nat = $ 2 ^ n - 1 $;

theorem upto0: $ upto 0 = 0 $ = '(eqtr (subeq1 pow0) subid);
theorem uptoadd1: $ upto n + 1 = 2 ^ n $ = '(npcan @ powpos d0lt2);
theorem sucupto: $ suc (upto n) = 2 ^ n $ = '(eqtr3 add12 uptoadd1);
theorem uptoS: $ upto (suc n) = b1 (upto n) $ =
'(mpbi addcan1 @ eqtr uptoadd1 @ eqtr powS @ eqtr3 (muleq2 sucupto) @
  eqtr mulS @ eqtr4 (addeq1 b0mul21) addSass);

theorem uptolem: $ shr (upto n) a = upto (n - a) /\ upto n % 2 ^ a = upto (min n a) $ =
'(trud @ eqdivmod
  (ltletrd
    (a1i @ subltid @ ian (powpos d0lt2) d0lt1)
    (a1i @ lepow2a d2ne0 minle2))
  (a1i @ mpbi addcan1 @ eqtr addass @ eqtr4 (addeq2 uptoadd1) @ eqtr4 uptoadd1 @
    eqtr3 (addeq (cases
      (muleq1d @ poweq2d eqmin2)
      (syl (eqtr4d (syl6eq mul0 muleq2) (syl6eq mul0 muleq2)) @
        syl6eq upto0 @ uptoeqd nlesubeq0)) mul12) @
    eqtr3 muladd @ eqtr (muleq2 uptoadd1) @ eqtr3 powadd @ poweq2 minaddsub));

theorem shrupto: $ shr (upto n) a = upto (n - a) $ = '(anl uptolem);

pub theorem elupto (k n: nat): $ k e. upto n <-> k < n $ =
'(bitr elnel @ bitr (oddeq shrupto) @
  bitr4 (ibii
    (mtd (a1i odd0) @ com12 @ bi1d @ oddeqd @ syl6eq upto0 uptoeq)
    (mpbii b1odd @ oddeqd @ syl5eqr uptoS @ uptoeqd sub1can)) @
  bitr subpos lt01);

theorem uptoss: $ upto a C_ upto b <-> a <= b $ =
'(ibii
  (mpi ltirr @ con1d (syl5bir ltnle @ sylib (imeqi elupto elupto) ssel))
  (!! iald x @ sylibr (imeqi elupto elupto) @ com12 ltletr));

theorem dffin2: $ finite A <-> E. n A C_ upto n $ =
'(exeqi @ !! aleqi x @ imeq2i @ bicom elupto);

@_ local def size (A: set): nat = $ least {k | A C_ upto k} $;

theorem sssize: $ finite A <-> A C_ upto (size A) $ =
'(bitr dffin2 @ ! ibii _ $ A C_ upto (size A) $
  (!! eex n @ sylbir (elabe @ sseq2d @ nseqd uptoeq) @
    sylib (!! elabe k @ sseq2d @ nseqd uptoeq) leastel)
  (iexe @ sseq2d @ nseqd uptoeq));
theorem sizess1: $ A C_ upto k -> size A <= k $ =
'(sylbir (!! elabe x @ sseq2d @ nseqd uptoeq) leastle);
theorem sizess: $ finite A -> (A C_ upto k <-> size A <= k) $ =
'(ibid (a1i sizess1) @ syl5bir uptoss (sylbi sssize sstr));
theorem sizeupto: $ size (upto n) = n $ =
'(leasym (mpbi (sizess finns) ssid) (mpbi uptoss @ mpbi sssize finns));

def Bool: nat = $ 0 ; sn 1 $;

theorem elbool: $ n e. Bool <-> bool n $ =
'(bitr elins @ bitr4 (oreq2i elsn) bool01);

theorem boolfin: $ finite Bool $ = '(mpbir (fineq @ !! eqab2i n elbool) ltfin);

@_ def Option (A: set): set = $ {n | n = 0 \/ n - 1 e. A} $;

theorem elopt: $ a e. Option A <-> a = 0 \/ a - 1 e. A $ =
'(!! elabe n @ oreqd eqeq1 (eleq1d subeq1));

theorem opt0: $ 0 e. Option A $ = '(mpbir elopt (orl eqid));
theorem optS: $ a e. A <-> suc a e. Option A $ =
'(bicom @ bitr elopt @ bitr (bior1 peano1) @ eleq1 @ sucsub1);

theorem optfin: $ finite A -> finite (Option A) $ =
'(!! eex n @ !! iexde m @ !! iald x @ casesda
  (a1d @ imp @ syl5ibrcom lteq1 @ anwr @ mpbiri lt01S lteq2)
  (mpbird (imeqd (eleq1d (eqcomd @ anwr sub1can)) (lteqd (eqcomd @ anwr sub1can) anlr)) @
    sylib (imeqi optS ltsuc) @ anwll @ !! eale y @ imeqd eleq1 lteq1));

@_ def Power (A: set): set = $ {x | ns x C_ A} $;

theorem elPower: $ a e. Power A <-> ns a C_ A $ = '(!! elabe x @ sseq1d nseq);

theorem powerfin: $ finite A -> finite (Power A) $ =
'(sylbi dffin2 @ !! eex n @ syl (!! iexe x @ aleqd @ imeq2d lteq2) @
  !! iald a @ syl5bi elPower @ com12 @ syl6 (sylib leltsuc ssle) sstr);

@_ def power (a: nat): nat = $ lower (Power a) $;

theorem elpower (a b: nat): $ a e. power b <-> a C_ b $ =
'(bitr (ellower @ powerfin finns) elPower);

theorem powerupto (a: nat): $ power (upto a) = upto (2 ^ a) $ =
'(axext @ !! ax_gen x @ bitr4 elpower @ bitr4 elupto @ ibii
  (sylib (lteq2 sucupto) @ sylib leltsuc ssle)
  (sylbir shreq0 @ !! iald y @ exp @ sylibr elupto @ mpi el02 @ con1d @ exp @
    mpbid (elneq2d anll) @ sylibr elshr @ mpbird(eleq1d @ syl npcan @ sylibr lenlt anr) anlr));

@(derive-eq 'uni) def sUnion (A: set): set = $ {x | E. y (x e. y /\ y e. A)} $;

theorem eluni: $ a e. sUnion A <-> E. x (a e. x /\ x e. A) $ =
'(!! elabe y @ exeqd @ aneq1d eleq1);
theorem elunii: $ a e. A -> b e. a -> b e. sUnion A $ =
(named '(expcom @ sylibr eluni @ iexe @ aneqd elneq2 eleq1));
theorem elssuni: $ a e. A -> a C_ sUnion A $ = (named '(iald elunii));

theorem finuni: $ finite A -> finite (sUnion A) $ =
(named '(eximi @ iald @ syl5bi eluni @ sylibr eexb @ alimi @
  syl5 ancom @ sylibr impexp @ imim2i @ com12 @ syl lttr ellt));

theorem xabfin (B: set x) (h: $ G -> finite A $) (h2: $ G /\ x e. A -> finite B $):
  $ G -> finite (X\ x e. A, B) $ =
(named '(sylc finss
  (mpbird (sseqd
      (syl5eqs cbvxabs @ xabeq2da @ sylib eqlower @
        sbethh (nfim nfv @ nffin nfsbs1) (imeqd (aneq2d eleq1) (fineqd sbsq)) h2)
      (a1i @ eqscom xabconst)) @
    xabssd @ syl elssuni @ anwr @ elimai @ mpbir ellam @
    iexe (eqeq2d @ preqd id @ lowereqd @ sbseq1d id) eqid)
  (sylc xpfin h @ syl finuni @ syl finlamima h)));

theorem sabfin {x y} (B: set x) (h: $ G -> y e. B -> x e. A $)
  (hA: $ G -> finite A $) (hB: $ G /\ x e. A -> finite B $): $ G -> finite (S\ x, B) $ =
'(mpbird (fineqd @ sabxab h) (xabfin hA hB));

@_ def cons (a b: nat): nat = $ suc (a <> b) $; infixr cons: $:$ prec 91;

theorem consne0: $ a : b != 0 $ = 'peano1;
theorem ltconsid1: $ a < a : b $ = '(mpbi leltsuc leprid1);
theorem ltconsid2: $ b < a : b $ = '(mpbi leltsuc leprid2);
theorem consfstsnd: $ a != 0 -> fst (a - 1) : snd (a - 1) = a $ =
'(syl5eq (suceq fstsnd) sub1can);
theorem excons: $ a != 0 <-> E. x E. y a = x : y $ =
'(ibii
  (rsyl consfstsnd @ iexde @ iexde @ eqtr3d anll @ eqcomd @ conseqd anlr anr)
  (eex @ eex @ mpbiri consne0 neeq1));

theorem consinj: $ a : c = b : d <-> a = b /\ c = d $ = '(bitr peano2 prth);
theorem conscan1: $ a : c = b : c <-> a = b $ = '(bitr consinj @ bian2 eqid);
theorem conscan2: $ a : b = a : c <-> b = c $ = '(bitr consinj @ bian1 eqid);
theorem consfst: $ fst ((a : b) - 1) = a $ = '(eqtr (fsteq sucsub1) fstpr);
theorem conssnd: $ snd ((a : b) - 1) = b $ = '(eqtr (sndeq sucsub1) sndpr);

theorem lecons1: $ a <= b <-> a : c <= b : c $ = '(bitr lepr1 lesuc);
theorem lecons2: $ b <= c <-> a : b <= a : c $ = '(bitr lepr2 lesuc);
theorem ltcons1: $ a < b <-> a : c < b : c $ = '(bitr ltpr1 ltsuc);
theorem ltcons2: $ b < c <-> a : b < a : c $ = '(bitr ltpr2 ltsuc);

@_ abstract def sep (n: nat) (A: set): nat = $ lower (n i^i A) $;
pub theorem elsep (n: nat) (A: set) (a: nat):
  $ a e. sep n A <-> a e. n /\ a e. A $ =
'(bitr (ellower @ finss inss1 finns) elin);

@_ def Arrow (A B: set) (.f: nat): set =
$ {f | isfun f /\ Dom f == A /\ Ran f C_ B} $;

@_ def write (F: set) (a b: nat): set =
  $ opab x y (ifp (x = a) (y = b) (x <> y e. F)) $;

theorem elwrite:
  $ x <> y e. write F a b <-> ifp (x = a) (y = b) (x <> y e. F) $ =
'(!! elopab z w @ ifpeqd (eqeq1d anl) (eqeq1d anr) (eleq1d @ imp preq));

pub theorem writeEq (F a b): $ write F a b @ a = b $ =
'(trud @ !! eqtheabd y @ a1i @ bitr elwrite @ ifppos eqid);
pub theorem writeNe (F a b x): $ x != a -> write F a b @ x = F @ x $ =
'(syl eqapp @ !! iald y @ syl5bb elwrite ifpneg);

theorem writeisf: $ isfun F -> isfun (write F a b) $ =
'(!! iald x @ !! iald y @ !! iald z @ syl5bi elwrite @ eorda
  (syl5bi elwrite @ mpbird (imeq1d (syl ifppos anrl)) (syl eqtr4 anrr))
  (syl5bi elwrite @ mpbird (imeq1d (syl ifpneg anrl)) @ exp @ isfd anll (anwl anrr) anr));

theorem writeres: $ write F a b == (F |` {x | x != a}) u. sn (a <> b) $ =
'(!! eqri p @ bitr3 (eleq1 fstsnd) @ bitr elwrite @
  bitr orcomb @ bitr4 (oreq1 @ bitr4 ancomb @ aneq2i @ elabe neeq1) @
  bitr3 (eleq1 fstsnd) @ bitr elun @ oreq prelres @ bitr elsn prth);

theorem writefin: $ finite F -> finite (write F a b) $ =
'(sylibr (fineq @ !! writeres x) @ sylc unfin resfin @ a1i finns);

theorem dmwrite: $ Dom (write F a b) == Dom F u. sn a $ =
'(!! eqri x @
  bitr4 (ibii
    (sylbi eldm @ !! eex y @ sylbi elwrite @ com12 @ syl6 preldm @ bi1d ifpneg)
    (casesd
      (a1i @ syl preldm @ sylibr elwrite @ mpbiri eqid ifppos)
      (a2i @ syl5bi eldm @ !! eexd y @
        mpbii preldm @ imeq1d @ syl5bb elwrite ifpneg))) @
  bitr elun @ bitr orcomb @ oreq1 elsn);

@_ local def srecaux (S: set) (n: nat) {.a .b: nat}: nat =
$ recn 0 (\\ a, \ b, lower (write b a (S @ b))) n $;

theorem srecaux0: $ srecaux S 0 = 0 $ = (named 'recn0);
theorem srecauxS: $ srecaux S (suc n) ==
  write (srecaux S n) n (S @ srecaux S n) $ =
'(mpbir (eqlower2 @ writefin finns) @
  eqtr recnS @ ! appslame _ $ srecaux S n $ _ a _ @ !! applamed b @
  lowereqd @ writeeqd (nseqd anr) anl (appeq2d anr));

theorem dmsrecaux: $ Dom (srecaux S n) == upto n $ =
(mk-ind '(!! ind x y)
  '(eqseqd (dmeqd @ nseqd srecauxeq2) (nseqd uptoeq))
  '(eqstr (dmeq @ nseq srecaux0) @ eqstr4 dm0 @ nseq upto0)
  '(syl5eqs (eqstr (dmeq srecauxS) dmwrite) @ syl6eqsr
    (!! eqri z @ bitr elupto @ bitr3 leltsuc @ bitr4 leloe @ bitr elun @ oreq elupto elsn)
    uneq1));

theorem srecauxisf: $ isfun (srecaux S n) $ =
(mk-ind '(!! ind x y)
  '(isfeqd @ nseqd srecauxeq2)
  '(mpbir (isfeq @ nseq srecaux0) isf0)
  '(sylibr (isfeq srecauxS) writeisf));

-- strong recursion operator:
--   srec(n) = S(srec(0), ..., srec(n-1))
@_ abstract def srec (S: set) (n: nat): nat = $ srecaux S (suc n) @ n $;

theorem srecauxapp: $ a < n -> srecaux S n @ a = srec S a $ =
(mk-ind '(!! ind x y)
  '(imeqd lteq2 (eqeq1d @ appeq1d @ nseqd @ srecauxeq2))
  '(absurd lt02)
  '(syl5bir leltsuc @ syl5bi leloe @ eord
    (a2i @ bi2d @ eqeq1d @ syl5eq (appeq1 @ srecauxS) (syl writeNe ltne))
    (a1i @ appeq1d @ nseqd @ srecauxeq2d @ suceqd eqcom)));

theorem srecval2: $ srec S n = S @ srecaux S n $ =
'(eqtr3 (srecauxapp ltsucid) @ eqtr (appeq1 srecauxS) writeEq);

theorem srecres: $ (\ i, srec S i) |` upto n == srecaux S n $ =
'(eqstr3 (reslameq @ ax_gen @ sylbi elupto srecauxapp) @
  eqstr3 (reseq2 dmsrecaux) (lamapp srecauxisf));

theorem sreclem (a: nat x):
  $ f = lower ((\ x, a) |` upto n) -> size (Dom (ns f)) = n $ =
'(syl6eq sizeupto @ sizeeqd @ syl6eqs dmreslam @ dmeqd @
  bi2 @ eqlower2 @ finlam finns);

theorem sreclem2 (a b: nat x):
  $ f = lower ((\ x, a) |` upto n) -> b < n -> ns f @ b = N[b / x] a $ =
'(exp @ syl6eq applams @ eqtrd
  (appeq1d @ sylibr (eqlower2 @ finlam finns) anl)
  (syl resapp @ sylibr elupto anr));

pub theorem srecval {i} (S n): $ srec S n = S @ lower ((\ i, srec S i) |` upto n) $ =
'(eqtr4 srecval2 @ appeq2 @ eqtr (lowereq srecres) lowerns);

@_ local def srecpaux (A n) (.f: nat): nat =
$ srec (\ f, nat (size (Dom f) <> lower {x | true (f @ x)} e. A)) n $;

-- strong recursion operator (for wffs):
--   srecp(n) <-> (srecp(0), ..., srecp(n-1)) e. A
@_ abstract def srecp (A: set) (n: nat): wff = $ true (srecpaux A n) $;

theorem srecpauxval:
  $ srecpaux A n = nat (n <> sep (upto n) {i | srecp A i} e. A) $ =
(named '(eqtr {srecval : $ _ = _ @ lower ((\ i, srecpaux A i) |` _) $} @
  eqtr4 (!! applame f @ nateqd @ eleq1d @ preqd sreclem
    (lowereqd @ !! abeqd x @ trueeqd @ appeq1d @
      bi2 @ eqlower2 @ finlam finns)) @
  nateq @ eleq1 @ preq2 @ eqtr3 lowerns @ lowereq @
  eqab2i @ bitr elsep @
  rbid anl (sylib (eleq2 dmreslam) @ con1 ndmapp) @
  bitr4d bian1 @ syl6bbr (elabe srecpeq2) @ trueeqd @
  syl6eq (applame srecpauxeq2) resapp));

pub theorem srecpval (A: set) (n: nat):
  $ srecp A n <-> n <> sep (upto n) {i | srecp A i} e. A $ =
'(bitr (trueeq srecpauxval) truenat);

@_ abstract def card (s .f: nat): nat =
$ srec (\ f, f @ (size (Dom f) // 2) + size (Dom f) % 2) s $;

theorem cardvallem: $ card n = ((\ i, card i) |` upto n) @ (n // 2) + n % 2 $ =
'(eqtr srecval @ ! applame $ lower ((\ i, card i) |` upto n) $ _ f _ @
  addeqd (appeqd (bi2 @ eqlower2 @ finlam finns) (diveq1d sreclem))
    (modeq1d sreclem));

pub theorem card0: $ card 0 = 0 $ =
'(eqtr (!! cardvallem i) @ eqtr (addeq
  (ndmapp @ mtbir (eleq2 @ eqstr dmreslam @ nseq upto0) el02) mod01) add0);

theorem cardval: $ n != 0 -> card n = card (n // 2) + n % 2 $ =
'(syl5eq cardvallem @ addeq1d @ syl6eq (!! applame i cardeq) @
  syl resapp @ sylibr elupto @ sylbir lt01 div2lt);

theorem cardb0: $ card (b0 n) = card n $ =
'(cases (cardeqd @ mpbiri b00 @ eqeqd b0eq id) @
  syl6eq add0 @ syl6eq (addeq (cardeq b0div2) b0mod2) @ sylbir b0ne0 cardval);

theorem cardb1: $ card (b1 n) = suc (card n) $ =
'(eqtr (cardval b1ne0) @ eqtr (addeq (cardeq b1div2) b1mod2) add12);

pub theorem cardS (a s: nat): $ ~a e. s -> card (a ; s) = suc (card s) $ =
'(!! eale z (imeqd (noteqd elneq2) @ eqeqd (cardeqd inseq2) (suceqd cardeq)) @
  trud @ !! indstr x y
    (aleqd @ imeqd (noteqd eleq1) (eqeq1d @ cardeqd inseq1))
    (aleqd @ imeqd (noteqd eleq1) (eqeq1d @ cardeqd inseq1)) @ anwr @
    sylibr (!! cbval z w @
      imeqd (noteqd elneq2) @ eqeqd (cardeqd inseq2) (suceqd cardeq)) @ iald @
    cases
      (a1d @ mpbiri (sylbi (noteq el01) @ sylbi eqb0 @
          eqtr4d (cardeqd @ syl6eqr b1ins inseq2) @
          syl6eqr cardb1 @ suceqd @ syl6eq cardb0 cardeq) @
        imeqd (noteqd eleq1) (eqeq1d @ cardeqd inseq1))
      (ealde @
        mpbird (imeq1d @ syl biim1 @
          mpbird (lteq1d anr) @ sylan subltid (sylibr lt01 anl) (a1i d0lt1)) @
        ealde @ imimd
          (bi2d @ noteqd @ bitrd (elneqd anlr anr) @
            syl5bb eldiv2 @ eleq1d @ syl sub1can anll) @
          sylbi anass @ imp @
          syl5ibrcom (imeq1d @ eqeqd (cardeqd @ syl6eqr insdiv2 @ imp inseq) (suceqd @ cardeqd anr)) @
          bi1d @ casesda
            (syl5bbr peano2 @ eqeqd
              (syl5eqr cardb1 @ cardeqd @
                eqtr4d (b1eqd @ diveq1d @ inseq1d @ anwl sub1can) @
                sylib eqb1 @ sylib el01 @ sylibr elins @ orrd @ sylibr el01 anr)
              (suceqd @ syl5eqr cardb1 @ cardeqd @ eqcomd @ sylib eqb1 anr))
            (eqeqd
              (syl5eqr cardb0 @ cardeqd @
                eqtr4d (b0eqd @ diveq1d @ inseq1d @ anwl sub1can) @
                sylib eqb0 @ sylbir notor @ con3 @
                sylbir el01 @ sylbi elins @ bi1 @ oreq eqcomb el01)
              (suceqd @ syl5eqr cardb0 @ cardeqd @ eqcomd @ sylib eqb0 anr))));

-- list recursion operator:
--   lrec(0) = z
--   lrec(a : l) = S(a, lrec(l))
@_ abstract def lrec (z: nat) (S: set) (n: nat): nat =
$ srec (\ f, N[size (Dom (ns f)) / i]
  if (i = 0) z (S @ (fst (i - 1) <> snd (i - 1) <> (ns f @ snd (i - 1))))) n $;

theorem lrecval: $ lrec z S n =
  if (n = 0) z (S @ (fst (n - 1) <> snd (n - 1) <> lrec z S (snd (n - 1)))) $ =
(focus
  (have 'h '(eqtrd anr @ anwl sreclem))
  '(eqtr {srecval : $ _ = _ @ lower ((\ x, lrec z S x) |` _) $} @
    !! applame f @ !! sbned i @ eqtrd (ifeq1d @ eqeq1d h) @
    syla ifeq3a @ appeq2d @
    preqd (anwl @ fsteqd @ subeq1d h) @ preqd (anwl @ sndeqd @ subeq1d h) @
    eqtrd (appeq2d @ anwl @ sndeqd @ subeq1d h) @ syl6eq (sbne lreceq3) @
    sylc sreclem2 anll @ mpbii ltconsid2 @ lteq2d @ anwr consfstsnd));

pub theorem lrec0 (z: nat) (S: set): $ lrec z S 0 = z $ = '(eqtr lrecval @ ifpos eqid);
pub theorem lrecS (z: nat) (S: set) (a b: nat):
  $ lrec z S (a : b) = S @ (a <> b <> lrec z S b) $ =
'(eqtr lrecval @ eqtr (ifneg consne0) @ appeq2 @
  preq consfst @ preq conssnd @ lreceq3 @ conssnd);

theorem listindd {x a l} (n) (px: wff x) (p0 pn: wff) (pl: wff l) (ps: wff a l)
  (h0: $ x = 0 -> (px <-> p0) $)
  (hl: $ x = l -> (px <-> pl) $)
  (hs: $ x = a : l -> (px <-> ps) $)
  (hn: $ x = n -> (px <-> pn) $)
  (h1: $ G -> p0 $) (h2: $ G /\ pl -> ps $): $ G -> pn $ =
'(!! indstr z w sbeq1 (syl6bb (sbe hn) sbeq1) @ casesda
  (mpbird (sbeq1d anr) @ anwll @ sylibr (sbe h0) h1)
  (mpd (sylib excons anr) @ eexd @ eexd @ anwl @ exp @
    mpbird (syl6bb (sbe hs) @ sbeq1d anr) @
    mpd (mpd (mpbiri ltconsid2 @ lteq2d anr) @
      rsyl anlr @ eale @ imeqd lteq1 @ syl6bb (sbe hl) sbeq1) @
    anwll @ exp h2));

theorem listind {x a l} (n) (px: wff x) (p0 pn: wff) (pl: wff l) (ps: wff a l)
  (h0: $ x = 0 -> (px <-> p0) $)
  (hl: $ x = l -> (px <-> pl) $)
  (hs: $ x = a : l -> (px <-> ps) $)
  (hn: $ x = n -> (px <-> pn) $)
  (h1: $ p0 $) (h2: $ pl -> ps $): $ pn $ =
'(trud @ listindd h0 hl hs hn (a1i h1) (anwr h2));

@_ abstract def lmems (l: nat): nat = $ lrec 0 (\\ x, \\ z, \ y, x ; y) l $;
pub theorem lmems0: $ lmems 0 = 0 $ = (named 'lrec0);
pub theorem lmemsS (a l: nat): $ lmems (a : l) = a ; lmems l $ =
'(eqtr lrecS @ ! appslame _ $ _ <> lmems l $ _ x _ @
  !! appslamed z @ !! applamed y @ inseqd anll anr);

@_ def lmem (a l: nat): wff = $ a e. lmems l $; infixl lmem: $IN$ prec 50;

theorem lmem0: $ ~ a IN 0 $ = '(mtbir (elneq2 lmems0) el02);
theorem lmemS (a b l: nat): $ a IN (b : l) <-> a = b \/ a IN l $ = '(bitr (elneq2 lmemsS) elins);

theorem lmemconsid: $ a IN (a : l) $ = '(mpbir lmemS (orl eqid));

theorem lmemlt: $ a IN l -> a < l $ =
(named @ mk-ind '(listind) '(imeqd lmemeq2 lteq2) '(absurd lmem0)
  '(syl5bi lmemS @ eord (a1i @ mpbiri ltconsid1 lteq1) (imim2i @ mpi ltconsid2 lttr)));

@_ def all (A: set) (l: nat): wff = $ lmems l C_ A $;

theorem all0 (A: set): $ all A 0 $ = '(!! ax_gen x @ absurd lmem0);
theorem allS (A: set) (a b: nat): $ all A (a : b) <-> a e. A /\ all A b $ =
'(bitr (sseq1 @ nseq @ lmemsS) insss);

theorem all1 (A: set) (a: nat): $ all A (a : 0) <-> a e. A $ = '(bitr allS @ bian2 all0);

theorem allal2: $ all A l <-> A. x (x IN l -> x e. A) $ = 'biid;
theorem allal (p: wff x): $ all {x | p} l <-> A. x (x IN l -> p) $ = '(bicom ssab2);

theorem elall: $ all A l -> x IN l -> x e. A $ = (named '(eale @ imeqd eleq1 eleq1));

theorem ssall: $ A C_ B -> all A l -> all B l $ = (named '(alimd @ imim2d ssel));

@_ def List (A: set) (.n: nat): set = $ {n | all A n} $;

theorem elList: $ l e. List A <-> all A l $ = '(!! elabe n alleq2);

theorem elList0: $ 0 e. List A $ = '(mpbir elList all0);
theorem elListS: $ (a : b) e. List A <-> a e. A /\ b e. List A $ =
'(bitr elList @ bitr4 allS @ aneq2i elList);

@_ abstract def len (l: nat): nat = $ lrec 0 (\\ x, \\ z, \ y, suc y) l $;
pub theorem len0: $ len 0 = 0 $ = (named 'lrec0);
pub theorem lenS (a b: nat): $ len (a : b) = suc (len b) $ =
'(eqtr lrecS @ ! appslame _ $ _ <> len b $ _ x _ @
  !! appslamed z @ !! applamed y @ suceqd anr);

theorem len1: $ len (a : 0) = 1 $ = '(eqtr lenS @ suceq len0);

theorem leneq0: $ len n = 0 <-> n = 0 $ =
'(ibii (ax_3 @ syl sucne0 @ syl6eq lenS @ leneqd @ eqcomd consfstsnd)
  (syl6eq len0 leneq));

theorem lenleid: $ len l <= l $ =
(named @ mk-ind '(listind) '(leeqd leneq id) '(eqle len0)
  '(sylibr (leeq1 lenS) @ sylib lesuc @ mpi leprid2 letr));

@_ def Array (A: set) (n .l: nat): set = $ {l | l e. List A /\ len l = n} $;

theorem elArray: $ l e. Array A n <-> l e. List A /\ len l = n $ =
'(!! elabe x @ aneqd eleq1 (eqeq1d leneq));

theorem elArrayList: $ l e. Array A n -> l e. List A $ = '(sylbi elArray anl);
theorem elArraylen: $ l e. Array A n -> len l = n $ = '(sylbi elArray anr);

theorem elArray02: $ l e. Array A 0 <-> l = 0 $ =
'(bitr elArray @ bitr (aneq2i leneq0) @ bian1a @ mpbiri elList0 eleq1);
theorem elArray0: $ 0 e. Array A 0 $ = '(mpbir elArray02 eqid);
theorem elArrayS: $ (a : b) e. Array A (suc n) <-> a e. A /\ b e. Array A n $ =
'(bitr elArray @ bitr (aneq elListS @ bitr (eqeq1 lenS) peano2) @
  bitr4 anass (aneq2i elArray));
theorem elArraySne0: $ l e. Array A (suc n) -> l != 0 $ =
'(sylbi elArray @ anwr @ sylib (noteq leneq0) sucne0);
theorem elArrayS2: $ l e. Array A (suc n) <-> E. a E. b (a e. A /\ b e. Array A n /\ l = a : b) $ =
'(bitr3 (bian2a @ sylib excons elArraySne0) @
  bitr3 exan1 @ exeqi @ bitr3 exan1 @ exeqi @ aneq1a @ syl6bb elArrayS eleq1);

theorem Arrayfin: $ finite A -> finite (Array A n) $ =
(named @ mk-ind '(indd) '(fineqd Arrayeq2)
  '(a1i @ mpbir (fineq (eqri @ bitr4 elArray02 elsn)) finns)
  '(rsyl (imp xpfin) @ syl (mpi lefin finss) @ sylib ssab2 @ iald @
    syl5bi elArrayS2 @ eexd @ eexda @ mpbird (leeq1d anrr) @
    syl ellt @ mpbird (anwl ellower) @ sylibr prelxp anrl));

@_ abstract def append (l1 l2: nat): nat = $ lrec l2 (\\ x, \\ z, \ y, x : y) l1 $;
infixl append: $++$ prec 84;
pub theorem append0 (a: nat): $ 0 ++ a = a $ = (named 'lrec0);
pub theorem appendS (a b c: nat): $ (a : b) ++ c = a : (b ++ c) $ =
'(eqtr lrecS @ ! appslame _ $ _ <> append b $ _ x _ @
  !! appslamed z @ !! applamed y @ conseqd anll anr);

theorem append1: $ a : 0 ++ l = a : l $ = '(eqtr appendS @ conseq2 append0);

theorem append02: $ a ++ 0 = a $ =
(named @ mk-ind '(listind) '(eqeqd appendeq1 id) 'append0 '(syl5eq appendS conseq2));

theorem appendass: $ l1 ++ l2 ++ l3 = l1 ++ (l2 ++ l3) $ =
(named @ mk-ind '(listind) '(eqeqd (appendeq1d appendeq1) appendeq1)
  '(eqtr4 (appendeq1 append0) append0)
  '(syl5eq (appendeq1 appendS) @ syl5eq appendS @ syl6eqr appendS conseq2));

theorem appendlen: $ len (l1 ++ l2) = len l1 + len l2 $ =
(named @ mk-ind '(listind) '(eqeqd (leneqd appendeq1) (addeq1d leneq))
  '(eqtr4 (leneq append0) @ eqtr (addeq1 len0) add01)
  '(syl5eq (eqtr (leneq appendS) lenS) @ syl6eqr (eqtr (addeq1 lenS) addS1) suceq));

theorem leappend2: $ b <= c <-> a ++ b <= a ++ c $ =
(named @ mk-ind '(listind) '(bieq2d @ leeqd appendeq1 appendeq1)
  '(bicom @ leeq append0 append0)
  '(syl6bb (bitr4 lecons2 (leeq appendS appendS)) id));

theorem ltappend2: $ b < c <-> a ++ b < a ++ c $ =
'(bitr4 ltnle @ bitr4 ltnle @ noteq leappend2);

theorem appendcan1: $ a ++ b = a ++ c <-> b = c $ =
'(bitr4 eqlele @ bitr eqlele @ aneq leappend2 leappend2);

theorem leappendid1: $ a <= a ++ b $ =
'(mpbi (leeq1 append02) @ mpbi leappend2 le01);

theorem leappendid2: $ a <= b ++ a $ =
(named @ mk-ind '(listind) '(leeq2d appendeq1) '(eqler append0)
  '(mpi (mpbir (leeq2 appendS) @ ltle ltconsid2) letr));

theorem ltappendid1: $ b != 0 <-> a < a ++ b $ =
'(bitr3 lt01 @ bitr ltappend2 (lteq1 append02));

theorem ltappendid2: $ b != 0 <-> a < b ++ a $ =
(named '(ibii
  (sylbi excons @ eex @ eex @ mpbiri (lelttr leappendid2 ltconsid2) @
    lteq2d @ syl6eq appendS appendeq1)
  (rsyl ltne @ con3 @ eqcomd @ syl6eq append0 appendeq1)));

theorem appendeq0: $ a ++ b = 0 <-> a = 0 /\ b = 0 $ =
'(bitr3 leneq0 @ bitr (eqeq1 appendlen) @ bitr addeq0 @ aneq leneq0 leneq0);

@_ abstract def snoc (l a: nat): nat = $ l ++ (a : 0) $;
infixl snoc: $|>$ prec 84;
pub theorem snoc0 (a: nat): $ 0 |> a = a : 0 $ = 'append0;
pub theorem snocS (a b c: nat): $ (a : b) |> c = a : (b |> c) $ = 'appendS;
pub theorem snoclt (a b: nat): $ a < a |> b $ =
(mk-ind '(!! listind x y z) '(lteqd id snoceq1)
  '(mpbir (lteq2 snoc0) @ mpbir lt01 consne0)
  '(bi1i @ bitr4 ltcons2 @ lteq2 snocS));

theorem appendsnoc: $ l1 ++ (l2 |> b) = l1 ++ l2 |> b $ = (named '(eqcom appendass));

theorem conssnoc: $ a : (l |> b) = a : l |> b $ = '(eqcom appendS);

@_ local def listfn (l .f: nat): nat = $ lrec 0 (\\ a, \\ z, \ f,
  lower ((\ i, if (i = 0) a (f @ (i - 1))) |` upto (suc (size (Dom f))))) l $;

theorem listfn0: $ listfn 0 = 0 $ = (named 'lrec0);
theorem listfnS2: $ listfn (a : l) ==
  (\ i, if (i = 0) a (listfn l @ (i - 1))) |` upto (suc (size (Dom (listfn l)))) $ =
'(mpbir (eqlower2 @ finlam finns) @
  eqtr lrecS @ ! appslame _ $ _ <> listfn l $ _ x _ @ !! appslamed z @ !! applamed y @
  lowereqd @ reseqd (lameqd @ ifeqd biidd anll @ appeq1d @ nseqd anr)
   (nseqd @ uptoeqd @ suceqd @ sizeeqd @ dmeqd @ nseqd anr));

theorem dmlistfn: $ Dom (listfn l) == upto (len l) $ =
(mk-ind '(!! listind x y z)
  '(eqseqd (dmeqd @ nseqd listfneq) (nseqd @ uptoeqd @ leneq))
  '(eqstr (dmeq @ nseq listfn0) @ eqstr4 dm0 @ nseq @ eqtr (uptoeq len0) upto0)
  '(syl5eqs (dmeq @ !! listfnS2 i) @ syl5eqs dmreslam @
    nseqd @ syl6eqr (uptoeq lenS) @ uptoeqd @ suceqd @ syl6eq sizeupto sizeeq));

theorem listfnisf: $ isfun (listfn l) $ =
'(cases
  (mpbiri isf0 @ isfeqd @ nseqd @ syl6eq listfn0 listfneq)
  (mpbii (resisf @ !! lamisf i) @ isfeqd @
    syl5eqsr listfnS2 @ nseqd @ listfneqd @ consfstsnd));

theorem listfnS: $ listfn (a : l) ==
  (\ i, if (i = 0) a (listfn l @ (i - 1))) |` upto (suc (len l)) $ =
'(eqstr listfnS2 @ reseq2 @ nseq @ uptoeq @ suceq @
  eqtr (sizeeq dmlistfn) sizeupto);

theorem listfnSval: $ n < suc (len l) ->
  listfn (a : l) @ n = if (n = 0) a (listfn l @ (n - 1)) $ =
'(syl5eq (appeq1 @ !! listfnS i) @
  syl6eq (applame @ ifeqd eqeq1 eqidd @ appeq2d subeq1) @
  sylbir elupto resapp);

theorem listfnS0: $ listfn (a : l) @ 0 = a $ = '(eqtr (listfnSval lt01S) (ifpos eqid));

theorem listfnSS: $ listfn (a : l) @ suc n = listfn l @ n $ =
'(cases
  (syl6eq (appeq2 sucsub1) @ syl6eq (ifneg peano1) @ sylbi ltsuc listfnSval)
  (eqtr4d
    (sylbir (noteq @ bitr (eleq2 dmlistfn) @
      bitr elupto @ bitr4 (lteq2 lenS) ltsuc) ndmapp)
    (sylbir (noteq @ bitr (eleq2 dmlistfn) elupto) ndmapp)));

@_ abstract def nth (n l: nat): nat = $ if (n < len l) (suc (listfn l @ n)) 0 $;

pub theorem nth0 (n: nat): $ nth n 0 = 0 $ = '(ifneg @ mtbir (lteq2 len0) lt02);
pub theorem nthZ (a l: nat): $ nth 0 (a : l) = suc a $ =
'(eqtr (ifpos @ mpbir (lteq2 lenS) lt01S) @ suceq listfnS0);
pub theorem nthS (n a l: nat): $ nth (suc n) (a : l) = nth n l $ =
'(cases
  (eqtr4d (sylbi (bitr4 ltsuc @ lteq2 lenS) ifpos) @ syl6eqr (suceq listfnSS) ifpos)
  (eqtr4d (sylbi (noteq @ bitr4 ltsuc @ lteq2 lenS) ifneg) ifneg));

theorem nthne0: $ nth n l != 0 <-> n < len l $ =
'(ibii (con1 ifneg) @ syl sucne0 ifpos);

theorem ntheq0: $ nth n l = 0 <-> len l <= n $ =
'(bicom @ bitr lenlt @ con1b nthne0);

theorem lmemnth: $ a IN l <-> E. n nth n l = suc a $ =
(named @ mk-ind '(listind) '(bieqd lmemeq2 @ exeqd @ eqeq1d ntheq2)
  '(binth lmem0 @ nexi @ necom @ mpbir (neeq2 nth0) peano1)
  '(syl5bb lmemS @ syl6bb (bitr3 exor @ exeqi @ bitr3 andir (bian1 em)) @ oreqd
    (a1i @ bicom @ exeqe @ syl6bb eqcomb @ syl6bb peano2 @ eqeq1d @ syl6eq nthZ ntheq1)
    (bi1 @ bieq2 @ bitr (cbvex @ eqeq1d ntheq1) @
      bitr3 (exeqi @ exeqe @ eqeq1d @ syl6eq nthS ntheq1) @
      bitr excomb @ exeqi @ bitr4 exan2 (aneq1i exsuc))));

theorem allnth: $ all A l <-> A. n A. x (nth n l = suc x -> x e. A) $ =
'(bitr4 (aleqi @ imeq1i lmemnth) @ bitr4 alcomb @ aleqi eexb);

theorem nthlmem: $ nth n l = suc a -> a IN l $ =
(named '(sylibr lmemnth @ iexe @ eqeq1d ntheq1));

theorem appendnth1: $ i < len l1 -> nth i (l1 ++ l2) = nth i l1 $ =
(named @ focus
  (def h '(imeqd lteq1 @ eqeqd ntheq1 ntheq1))
  '(eale ,h _)
  (mk-ind '(listind) '(aleqd @ imeqd (lteq2d leneq) (eqeqd (ntheq2d appendeq1) ntheq2))
    '(ax_gen @ sylbi (lteq2 len0) @ absurd lt02)
    '(sylbi (cbval ,h) @ iald @ casesd _ _))
  '(a1i @ a1d @ syl5eq (ntheq2 appendS) @ eqtr4d ntheq1 @ syl6eq (eqtr4 nthZ nthZ) ntheq1)
  '(syl5bi exsuc @ sylibr eexb @ alimi @ com12 @ bi2d @
    imeqd (syl5bb (lteq2 lenS) @ syl6bbr ltsuc lteq1) @
    eqeqd (syl5eq (ntheq2 appendS) @ syl6eq nthS ntheq1) (syl6eq nthS ntheq1)));

theorem appendnth2_: $ nth (len l1 + i) (l1 ++ l2) = nth i l2 $ =
(named @ mk-ind '(listind) '(eqeq1d @ ntheqd (addeq1d leneq) appendeq1)
  '(ntheq (eqtr (addeq1 len0) add01) append0)
  '(syl5eq (eqtr (ntheq (eqtr (addeq1 lenS) addS1) appendS) nthS) id));

theorem appendnth2: $ len l1 <= i -> nth i (l1 ++ l2) = nth (i - len l1) l2 $ =
'(syl6eq appendnth2_ @ ntheq1d @ eqcomd pncan3);

@_ abstract def repeat (a n: nat): nat = $ rec 0 (\ x, a : x) n $;
pub theorem repeat0 (a: nat): $ repeat a 0 = 0 $ =  (named 'rec0);
pub theorem repeatS (a n: nat): $ repeat a (suc n) = a : repeat a n $ =
'(eqtr recS @ ! applame (repeat a n) _ x _ conseq2);

@_ def sublistAt (n L1 L2: nat): wff =
$ E. l E. r (L1 = l ++ L2 ++ r /\ len l = n) $;

@_ local def grecaux1 (K: set) (x z n: nat): nat =
$ recn z (\\ u, \ i, K @ ((x - suc u) <> i)) n $;

theorem grecaux10: $ grecaux1 K x k 0 = k $ = (named 'recn0);
theorem grecaux1S: $ grecaux1 K x k (suc n) =
  K @ ((x - suc n) <> grecaux1 K x k n) $ =
(named '(eqtr recnS @ ! appslame _ $ grecaux1 K x k n $ _ _ _ @
  applamed @ appeq2d @ preqd (subeq2d @ suceqd anl) anr));

theorem grecaux1Sx: $ grecaux1 K (suc x) k (suc n) = grecaux1 K x (K @ (x <> k)) n $ =
(mk-ind '(!! ind a b) '(eqeqd (grecaux1eq4d suceq) grecaux1eq4)
  '(eqtr grecaux1S @ eqtr4 (appeq2 @ preq (eqtr subSS sub02) grecaux10) grecaux10)
  '(eqtr4g grecaux1S grecaux1S @ appeq2d @ preqd (a1i subSS) id));

@_ local def grecaux2 (z: nat) (K F: set) (x n k: nat): nat =
$ recn z (\\ u, \ i, F @ (u <> grecaux1 K x k (x - suc u) <> i)) n $;

theorem grecaux20: $ grecaux2 z K F x 0 k = z $ = (named 'recn0);
theorem grecaux2S: $ grecaux2 z K F x (suc n) k =
  F @ (n <> grecaux1 K x k (x - suc n) <> grecaux2 z K F x n k) $ =
(named '(eqtr recnS @ ! appslame _ $ grecaux2 z K F x n k $ _ _ _ @
  applamed @ appeq2d @ preqd anl @
  preqd (grecaux1eq4d @ subeq2d @ suceqd anl) anr));

theorem grecaux2Sx: $ n <= x -> grecaux2 z K F (suc x) n k = grecaux2 z K F x n (K @ (x <> k)) $ =
(mk-ind '(!! indlt a b) '(eqeqd grecaux2eq5 grecaux2eq5)
  '(a1i @ eqtr4 grecaux20 grecaux20)
  '(eqtr4g grecaux2S grecaux2S @ appeq2d @ preq2d @
    preqd (anwl @ syl6eq grecaux1Sx @ grecaux1eq4d @ syl5eq subSS @
      syl eqsub1 @ syl5eq addSass @ syl npcan @ impcom letr) @
    anr));

-- general recursion operator:
--   grec(0, k) = z
--   grec(n+1, k) = F(n, k, grec(n, K(n, k)))
@_ local def grec (z: nat) (K F: set) (n k: nat): nat = $ grecaux2 z K F n n k $;

theorem grec0: $ grec z K F 0 k = z $ = 'grecaux20;

theorem grecS: $ grec z K F (suc n) k = F @ (n <> k <> grec z K F n (K @ (n <> k))) $ =
'(eqtr grecaux2S @ appeq2 @ preq2 @ preq (eqtr (grecaux1eq4 subid) grecaux10) (grecaux2Sx leid));

@_ local def rev (l: nat): nat = $ lrec 0 (\\ a, \\ z, \ ih, ih |> a) l $;

theorem rev0: $ rev 0 = 0 $ = (named 'lrec0);
theorem revS: $ rev (a : l) = rev l |> a $ =
(named '(! eqtr _ $ _ @ (_ <> _ <> rev l) $ _ lrecS @
  appslame @ appslamed @ applamed @ snoceqd anr anll));

theorem revsn: $ rev (a : 0) = a : 0 $ =
'(eqtr revS @ eqtr (snoceq1 rev0) snoc0);

theorem revappend: $ rev (l1 ++ l2) = rev l2 ++ rev l1 $ =
(named @ mk-ind '(listind) '(eqeqd (reveqd appendeq1) @ appendeq2d reveq)
  '(eqtr4 (reveq append0) @ eqtr (appendeq2 rev0) append02)
  '(syl5eq (eqtr (reveq appendS) revS) @
    syl6eqr (appendeq2 revS) @ syl6eqr appendsnoc snoceq1));

theorem revsnoc: $ rev (l |> a) = a : rev l $ =
'(eqtr revappend @ eqtr (appendeq1 revsn) @ eqtr appendS @ conseq2 append0);

theorem revrev: $ rev (rev l) = l $ =
(named @ mk-ind '(listind) '(eqeqd (reveqd reveq) id)
  '(eqtr (reveq rev0) rev0)
  '(syl5eq (reveq revS) @ syl5eq revsnoc conseq2));

theorem revinj: $ rev l = rev l2 <-> l = l2 $ =
'(ibii (sylib (eqeq revrev revrev) reveq) reveq);

theorem reveq0: $ rev l = 0 <-> l = 0 $ = '(bitr3 (eqeq2 rev0) revinj);

theorem exsnoc: $ l != 0 <-> E. l2 E. a l = l2 |> a $ =
(named '(bitr3 (noteq reveq0) @ bitr4 excons @ bitr4 excomb @ exeqi @
  bitr (exeqi @ bitr (eqeq2 @ eqtr3 revrev (reveq revS)) revinj) @
  ibii (eex @ iexe @ eqeq2d snoceq1)
    (eex @ iexe @ eqeq2d @ snoceq1d @ syl6eq revrev reveq)));

theorem appendcan2: $ a ++ c = b ++ c <-> a = b $ =
'(bitr3 revinj @ bitr (eqeq revappend revappend) @ bitr appendcan1 revinj);

-- map : (A -> B) -> list A -> list B
@_ def map (F: set) (l: nat): nat =
$ lrec 0 (\\ a, \\ z, \ ih, F @ a : ih) l $;
pub theorem map0 (F: set): $ map F 0 = 0 $ = (named 'lrec0);
pub theorem mapS (F: set) (a l: nat):
  $ map F (a : l) = F @ a : map F l $ =
(named '(! eqtr _ $ _ @ (_ <> _ <> map F l) $ _ lrecS @
  appslame @ appslamed @ applamed @ conseqd (appeq2d anll) anr));

theorem maplen: $ len (map F l) = len l $ =
(named @ mk-ind '(listind) '(eqeqd (leneqd mapeq2) leneq)
  '(leneq map0)
  '(eqtr4g (eqtr (leneq mapS) lenS) lenS suceq));

theorem mapnth: $ nth n l = suc a -> nth n (map F l) = suc (F @ a) $ =
(named
  (def h '(imeqd (eqeq1d ntheq1) (eqeq1d ntheq1)))
  '(eale ,h ,(mk-ind '(listind)
    '(aleqd @ imeqd (eqeq1d ntheq2) (eqeq1d @ ntheq2d mapeq2))
    '(ax_gen @ absurd @ mt2 sucne0 nth0)
    '(sylbi (cbval ,h) @ iald @ casesd
      (a1i @ mpbiri (syl5eq nthZ @ sylbi peano2 @ suceqd appeq2) @
        imeqd (eqeq1d @ syl6eq nthZ ntheq1) (eqeq1d @ syl6eq (ntheq2 mapS) ntheq1))
      (syl5bi exsuc @ syl6 (eex @ rsyl ancom @ bi2a @ imeqd
          (eqeq1d @ syl6eq nthS ntheq1)
          (eqeq1d @ syl5eq (ntheq2 mapS) @ syl6eq nthS ntheq1))
        alexan)))));

theorem mapnthb: $ nth n (map F l) = suc b <-> E. a (nth n l = suc a /\ b = F @ a) $ =
'(ibii
  (mpd (sylib exsuc @ sylibr nthne0 @ sylib (lteq2 maplen) @ sylib nthne0 sucne0) @
    eximd @ exp @ iand anr @ sylib peano2 @ eqtr3d anl @ anwr mapnth)
  (eex @ eqtr4d (anwl mapnth) (suceqd anr)));

theorem lmemmapi: $ a IN l -> F @ a IN map F l $ =
(named '(sylbi lmemnth @ eex @ syl nthlmem mapnth));

theorem lmemmap: $ b IN map F l <-> E. a (a IN l /\ b = F @ a) $ =
(named '(bitr lmemnth @ bitr (exeqi mapnthb) @ bitr excomb @
  exeqi @ bitr4 exan2 @ aneq1i lmemnth));

-- ljoin : list (list A) -> list A
@_ def ljoin (L: nat): nat = $ lrec 0 (\\ a, \\ z, \ ih, a ++ ih) L $;
pub theorem ljoin0: $ ljoin 0 = 0 $ = (named 'lrec0);
pub theorem ljoinS (l L: nat): $ ljoin (l : L) = l ++ ljoin L $ =
(named '(! eqtr _ $ _ @ (_ <> _ <> ljoin L) $ _ lrecS @
  appslame @ appslamed @ applamed @ appendeqd anll anr));

@_ local def lfnaux (F: set) (k n: nat): nat =
$ grec 0 (\\ _1, \ x, suc x) (\\ _2, \\ i, \ ih, F @ i : ih) n k $;
theorem lfnaux0: $ lfnaux F k 0 = 0 $ = (named 'grec0);
theorem lfnauxS: $ lfnaux F k (suc n) = F @ k : lfnaux F (suc k) n $ =
(named '(eqtr grecS @
  eqtr (appeq2 @ preq2 @ preq2
    {(greceq5 @ appslame @ applamed @ suceqd anr) : $ _ = lfnaux _ _ _ $}) @
  appslame @ appslamed @ applamed @ conseqd (appeq2d anlr) anr));

theorem lfnauxshift:
  $ A. i F1 @ (k1 + i) = F2 @ (k2 + i) ->
    lfnaux F1 k1 n = lfnaux F2 k2 n $ =
(named @ focus
  (def h '(imeqd
    (aleqd @ eqeqd (appeq2d @ addeq1d anl) (appeq2d @ addeq1d anr))
    (eqeqd (lfnauxeq2d anl) (lfnauxeq2d anr))))
  (def h2 '(eqeqd (appeq2d addeq2) (appeq2d addeq2)))
  '(ealie (ealde @ bi1d ,h) _)
  (mk-ind '(ind)
    '(aleqd @ aleqd @ imeq2d @ eqeqd lfnauxeq3 lfnauxeq3)
    '(ax_gen @ ax_gen @ a1i @ eqtr4 lfnaux0 lfnaux0) _)
  '(sylbi (cbval @ cbvald ,h) @ iald @ iald @
    rsyl (ealie @ ealde @ bi1d ,h) @
    rsyl (imim1i @ sylbi (cbval ,h2) @ iald @
      sylibr (eqeq (appeq2 addSass) (appeq2 addSass)) @ eale ,h2) @
    a2i @ exp @ eqtr4g lfnauxS lfnauxS @
    conseqd (anwl @ eale @
      eqeqd (appeq2d @ syl6eq add0 addeq2) (appeq2d @ syl6eq add0 addeq2)) anr));

theorem lfnauxlen: $ len (lfnaux F k n) = n $ =
(named
  (def h '(aleqd @ eqeqd (leneqd lfnauxeq3) id))
  '(eale (eqeq1d @ leneqd lfnauxeq2) ,(mk-ind '(ind)
    '(aleqd @ eqeqd (leneqd lfnauxeq3) id)
    '(ax_gen @ eqtr (leneq lfnaux0) len0)
    '(sylbi (cbval @ eqeq1d @ leneqd lfnauxeq2) @
      iald @ syl5eq (leneq lfnauxS) @ syl5eq lenS @ suceqd @
      eale @ eqeq1d @ leneqd lfnauxeq2))));

theorem lfnauxnth: $ i < n -> nth i (lfnaux F k n) = suc (F @ (k + i)) $ =
(named
  (def h '(imeqd (lteq1d anl) @
    eqeqd (ntheqd anl (lfnauxeq2d anr)) (suceqd @ appeq2d @ addeqd anr anl)))
  '(ealie (ealde @ bi1d ,h) ,(mk-ind '(ind)
    '(aleqd @ aleqd @ imeqd lteq2 @ eqeq1d @ ntheq2d lfnauxeq3)
    '(ax_gen @ ax_gen @ absurd lt02)
    '(sylbi (cbval @ cbvald ,h) @ iald @ iald @ exp @
      syl5eq (ntheq2 lfnauxS) @ casesd
        (exp @ eqtr4d (syl6eq nthZ @ ntheq1d anr) @ suceqd @ appeq2d @ syl6eq add02 @ addeq2d anr)
        (syl5bi exsuc @ eexdh (nfan nfal1 nfv) nfv @ exp @
          eqtrd (ntheq1d anr) @ syl5eq nthS @
          eqtr4d (mpd (sylibr ltsuc @ mpbid (lteq1d anr) anlr) @ rsyl (anwll eal) @
            eale (imeq2d (eqeqd (ntheq2d lfnauxeq2) (suceqd @ appeq2d addeq1)))) @
          suceqd @ appeq2d @ syl6eqr addSass @ addeq2d anr)))));

@_ local def lfn (F: set) (n: nat): nat = $ lfnaux F 0 n $;

theorem lfn0: $ lfn F 0 = 0 $ = 'lfnaux0;
theorem lfnS: $ lfn F (suc n) = F @ 0 : lfn (\ i, F @ suc i) n $ =
(named '(eqtr4 lfnauxS @ conseq2 @ lfnauxshift @
  ax_gen @ applame @ appeq2d @ syl6eqr addS1 suceq));

theorem lenlfn: $ len (lfn F n) = n $ = 'lfnauxlen;
theorem nthlfn: $ i < n -> nth i (lfn F n) = suc (F @ i) $ =
'(syl6eq (suceq @ appeq2 add01) lfnauxnth);

theorem lfnnth: $ lfn (\ i, nth i l - 1) (len l) = l $ =
(named @ mk-ind '(listind)
  '(eqeqd (lfneqd (lameqd @ subeq1d ntheq2) leneq) id)
  '(eqtr (lfneq2 len0) lfnaux0)
  '(syl5eq (lfneq2 lenS) @ syl5eq lfnS @ syl5eq
    (conseq
      (applame @ syl6eq sucsub1 @ subeq1d @ syl6eq nthZ ntheq1)
      (lfneq1 @ eqstr
        (lameqi @ applame @ subeq1d @ syl6eq nthS ntheq1)
        (cbvlam @ subeq1d ntheq1)))
    conseq2));

theorem nthext2d {i}
  (h1: $ G -> len l1 = n $)
  (h2: $ G -> len l2 = n $)
  (h3: $ G /\ i < n -> nth i l1 = nth i l2 $): $ G -> l1 = l2 $ =
(focus
  (have 'h $ G -> nth i l1 = nth i l2 $
    '(casesda h3 @ eqtr4d
      (imp @ con1d @ syl5bi nthne0 @ bi1d @ lteq2d h1)
      (imp @ con1d @ syl5bi nthne0 @ bi1d @ lteq2d h2)))
  '(eqtr3g lfnnth lfnnth @ lfneqd (lameqd @ subeq1d h) (eqtr4d h1 h2)));

theorem nthext2 {i} (h1: $ len l1 = n $) (h2: $ len l2 = n $)
  (h3: $ i < n -> nth i l1 = nth i l2 $): $ l1 = l2 $ =
'(trud @ nthext2d (a1i h1) (a1i h2) (anwr h3));

theorem nthext: $ l1 = l2 <-> A. n nth n l1 = nth n l2 $ =
(named @ focus
  '(ibii (iald ntheq2) @ nthext2d _ eqidd @ anwl @ eale @ eqeqd ntheq1 ntheq1)
  '(sylibr eqallt1 @ alimi @ bitr3g nthne0 nthne0 neeq1));

@_ local def zip (l1 l2: nat): nat =
$ lfn (\ i, (nth i l1 - 1) <> (nth i l2 - 1)) (min (len l1) (len l2)) $;

theorem ziplen: $ len (zip l1 l2) = min (len l1) (len l2) $ =
(named 'lenlfn);

theorem zipnth (h1: $ G -> nth i l1 = suc a $) (h2: $ G -> nth i l2 = suc b $):
  $ G -> nth i (zip l1 l2) = suc (a <> b) $ =
'(eqtrd (syl nthlfn @ sylibr ltmin @ iand
    (sylib nthne0 @ syl sucne0 h1)
    (sylib nthne0 @ syl sucne0 h2)) @
  suceqd @ !! applamed x ,(let
    ([(f h) '(syl6eq sucsub1 @ subeq1d @ eqtrd (ntheq1d anr) (anwl ,h))])
    '(preqd ,(f 'h1) ,(f 'h2))));

theorem zip01: $ zip 0 l = 0 $ = '(mpbi leneq0 @ eqtr ziplen @ eqtr (mineq1 len0) @ eqmin1 le01);
theorem zip02: $ zip l 0 = 0 $ = '(mpbi leneq0 @ eqtr ziplen @ eqtr (mineq2 len0) @ eqmin2 le01);
theorem zipS: $ zip (a : l1) (b : l2) = (a <> b) : zip l1 l2 $ =
(focus
  '(!! nthext2 n
    (eqtr ziplen @ eqtr4 (mineq lenS lenS) minS)
    (eqtr lenS @ suceq ziplen)
    ,(mk-ind '(!! ind m n)
      '(imeqd lteq1 @ eqeqd ntheq1 ntheq1)
      '(a1i @ eqtr4 (trud @ zipnth (a1i nthZ) (a1i nthZ)) nthZ)
      '(a1i @ sylbir ltsuc @ syl6eqr nthS @ sylbi ltmin _)))
  (have 'h1 '(eqcomd @ syl sub1can @ sylibr nthne0 anl))
  (have 'h2 '(eqcomd @ syl sub1can @ sylibr nthne0 anr))
  '(eqtr4d (zipnth (syl5eq nthS h1) (syl5eq nthS h2)) (zipnth h1 h2)));

@_ local def take (l n: nat): nat =
$ lfn (\ i, nth i l - 1) (min (len l) n) $;

@_ local def drop (l n: nat): nat =
$ lfn (\ i, nth (i + n) l - 1) (len l - n) $;

theorem takelen: $ len (take l n) = min (len l) n $ = (named 'lenlfn);
theorem droplen: $ len (drop l n) = len l - n $ = (named 'lenlfn);

theorem takenth: $ i < n -> nth i (take l n) = nth i l $ =
'(mpi leorlt @ eorda
  (eqtr4d
    (sylibr ntheq0 @ anwr @ letr @ mpbir (leeq1 takelen) minle1)
    (sylibr ntheq0 anr))
  (eqtrd (rsyl ancom @ sylbir ltmin nthlfn) @
    eqtrd (suceqd @ !! applamed x @ subeq1d @ ntheq1d anr) @
    syl sub1can @ sylibr nthne0 anr));

theorem takenth0: $ n <= i -> nth i (take l n) = 0 $ =
'(sylibr ntheq0 @ letr @ mpbir (leeq1 takelen) minle2);

theorem dropnth: $ nth i (drop l n) = nth (i + n) l $ =
'(eor
  (eqtr4d (sylibr ntheq0 @ sylibr (leeq1 droplen) @ bi2i lesubadd) (bi2i ntheq0))
  (eqtrd (sylbi ltaddsub nthlfn) @
    eqtrd (suceqd @ !! applamed x @ subeq1d @ ntheq1d @ addeq1d anr) @
    sylbir nthne0 sub1can)
  leorlt);

theorem takedrop: $ take l n ++ drop l n = l $ =
'(!! nthext2 i (eqtr appendlen @ eqtr (addeq takelen droplen) minaddsub) eqid @
  mpi ltorle @ eorda
    (eqtrd (sylbir (bitr (lteq2 takelen) ltmin) appendnth1) @ anwr takenth)
    (eqtrd (syl appendnth2 @ anwr @ letr @ mpbir (leeq1 takelen) minle2) @
      syl5eq dropnth @ ntheq1d @
      eqtrd (addeq1d @ subeq2d @ syl5eq takelen @ syl eqmin2 @ letrd anr @ anwl ltle) @
      anwr npcan));

theorem take0: $ take l 0 = 0 $ =
'(mpbi leneq0 @ eqtr takelen @ mpbi le02 minle2);

theorem drop0: $ drop l 0 = l $ =
'(eqtr3 append0 @ eqtr3 (appendeq1 take0) takedrop);

theorem dropall: $ len l <= n -> drop l n = 0 $ =
'(sylib leneq0 @ syl5eq droplen @ bi1i lesubeq0);

theorem takeall: $ len l <= n -> take l n = l $ =
'(syl5eqr append02 @ syl6eq takedrop @ appendeq2d @ eqcomd dropall);

theorem takemin: $ take l (min (len l) n) = take l n $ =
'(eor (takeeq2d eqmin2)
  (eqtr4d (takeeq2d eqmin1) @ syl6eqr (takeall leid) takeall) leorle);

theorem takeappend1: $ n <= len l1 -> take (l1 ++ l2) n = take l1 n $ =
(named '(nthext2d
  (syl5eq takelen @ syl eqmin2 @ mpi (mpbir (leeq2 appendlen) leaddid1) letr)
  (syl5eq takelen @ eqmin2)
  (eqtr4d (anwr takenth) @ eqtr4d (anwr takenth) @ syl appendnth1 @ impcom ltletr)));
